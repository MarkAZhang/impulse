(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var dom = require('./core/dom.js');
var main = require('./core/main.js');

window.onload = function() {
  if(dom.isChromeBrowser()) {
    main.executeGame()
  } else {
    dom.centerMessage()
    document.getElementById('continue_btn').addEventListener('click', main.clearMessageAndStartGame);
    document.getElementById('download_btn').addEventListener('click', dom.redirectToChrome);
  }
}

},{"./core/dom.js":3,"./core/main.js":9}],2:[function(require,module,exports){
var saveData = require('../load/save_data.js');

var LEFT_MOUSE_BINDINGS = {
  LEFT_KEY: 37,
  UP_KEY: 38,
  RIGHT_KEY: 39,
  DOWN_KEY: 40,
  PAUSE: 13,
  GOD_MODE_KEY: 71,
  SECONDARY_PAUSE: 27,
  GATEWAY_KEY: 16,
  MUTE_KEY: 77,
  FULLSCREEN_KEY: 70,
  EXIT_KEY: 39,
  SAVE_AND_QUIT_KEY: 37,
  RESTART_KEY: 16,
  QUIT_KEY: 39,
  EXIT_GAME_KEY: 37,
  RESUME_GAME_KEY: 39,
  DELETE_GAME_KEY: 40,
  NEXT_KEY: 13
};

var RIGHT_MOUSE_BINDINGS = {
  LEFT_KEY: 65,
  UP_KEY: 87,
  RIGHT_KEY: 68,
  DOWN_KEY: 83,
  PAUSE: 81,
  GOD_MODE_KEY: 71,
  SECONDARY_PAUSE: 27,
  GATEWAY_KEY: 32,
  MUTE_KEY: 77,
  FULLSCREEN_KEY: 70,
  EXIT_KEY: 69,
  RESTART_KEY: 82,
  SAVE_AND_QUIT_KEY: 83,
  QUIT_KEY: 81,
  EXIT_GAME_KEY: 69,
  RESUME_GAME_KEY: 82,
  DELETE_GAME_KEY: 68,
  NEXT_KEY: 32
};

var RIGHT_KEYBOARD_BINDINGS = {
  LEFT_KEY: 37,
  UP_KEY: 38,
  RIGHT_KEY: 39,
  DOWN_KEY: 40,
  PAUSE: 81,
  GOD_MODE_KEY: 71,
  SECONDARY_PAUSE: 27,
  ILEFT_KEY: 65,
  IUP_KEY: 87,
  IRIGHT_KEY: 68,
  IDOWN_KEY: 83,
  GATEWAY_KEY: 32,
  MUTE_KEY: 77,
  FULLSCREEN_KEY: 70,
  EXIT_KEY: 69,
  RESTART_KEY: 82,
  SAVE_AND_QUIT_KEY: 83,
  QUIT_KEY: 81,
  EXIT_GAME_KEY: 69,
  RESUME_GAME_KEY: 82,
  DELETE_GAME_KEY: 68,
  NEXT_KEY: 32,
};

var controls = {
  keys: RIGHT_MOUSE_BINDINGS
};

controls.setKeyBindings = function () {
  var type = saveData.optionsData.control_hand + " " + saveData.optionsData.control_scheme;
  if(type == "left mouse") {
    controls.keys = LEFT_MOUSE_BINDINGS;
  } else if(type == "right mouse") {
    controls.keys = RIGHT_MOUSE_BINDINGS;
  } else if(type == "right keyboard") {
    controls.keys = RIGHT_KEYBOARD_BINDINGS;
  }
};

module.exports = controls;

},{"../load/save_data.js":69}],3:[function(require,module,exports){
var constants = require('../data/constants.js');
var utils = require('./utils.js');

var dom = {};

dom.setUpDocument = function () {
  window.oncontextmenu = function ()
  {
    return false;     // cancel default menu
  };
  dom.centerCanvas();
};

dom.centerCanvas = function() {
  var dim = utils.getWindowDimensions();
  var canvas_container = document.getElementById('canvas_container');
  var bg_canvas_container = document.getElementById('bg_canvas_container');
  var message = document.getElementById('message');


  if(constants.canvasWidth < dim.w)
  {
    constants.offsetLeft = (dim.w-constants.canvasWidth)/2
    canvas_container.style.left =  Math.round(constants.offsetLeft) + 'px'
    bg_canvas_container.style.left =  Math.round(constants.offsetLeft) + 'px'
  }
  else
  {
    constants.offsetLeft = 0
  }
  if(constants.canvasHeight < dim.h)
  {
    constants.offsetTop = (dim.h-constants.canvasHeight)/2
    canvas_container.style.top = Math.round(constants.offsetTop) + 'px'
    bg_canvas_container.style.top =  Math.round(constants.offsetTop) + 'px'
  }
  else
  {
    constants.offsetTop = 0
  }
  message.style.display = ""
};

dom.centerMessage = function() {
  var message = document.getElementById("message");
  var dim = utils.getWindowDimensions()

  message.setAttribute("style", "display: block" )
  if(message.clientWidth < dim.w)
  {
    constants.offsetLeft = (dim.w-message.clientWidth)/2
    message.style.left =  Math.round(constants.offsetLeft) + 'px'
  }
  else
  {
    constants.offsetLeft = 0
  }
  if(message.clientHeight < dim.h)
  {
    constants.offsetTop = (dim.h-message.clientHeight )/2
    message.style.top = Math.round(constants.offsetTop) + 'px'
  }
  else
  {
    constants.offsetTop = 0
  }
}

dom.redirectToChrome = function() {
  window.location = "https://www.google.com/intl/en/chrome/browser/";
};

dom.clearMessage = function() {
  var message = document.getElementById("message");
  message.setAttribute("style", "display: none" )
};

dom.IsInFullScreen = function () {
  return (document.fullScreenElement && document.fullScreenElement !== null) ||    // alternative standard method
            (document.mozFullScreen || document.webkitIsFullScreen);
}

dom.toggleFullScreen = function () {
  var isFullScreen = dom.IsInFullScreen();
  var docElm = document.documentElement;
  if (!isFullScreen) {

      if (docElm.requestFullscreen) {
          docElm.requestFullscreen();
      }
      else if (docElm.mozRequestFullscreen) {
          docElm.mozRequestFullscreen();
      }
      else if (docElm.webkitRequestFullscreen) {
          docElm.webkitRequestFullscreen ();
      }
  } else {
    if (document.exitFullscreen) {
          document.exitFullscreen();
      }
      else if (document.mozExitFullscreen) {
          document.mozExitFullscreen();
      }
      else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen ();
      }
  }
}

dom.isChromeBrowser = function () {
  return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
};

module.exports = dom;

},{"../data/constants.js":13,"./utils.js":11}],4:[function(require,module,exports){
var constants = require('../data/constants.js');
var controls = require('./controls.js');
var debugVars = require('../data/debug.js');
var dom = require('./dom.js');
var layers = require('./layers.js');
var music_player = require('../core/music_player.js');
var uiRenderUtils = require('../render/ui.js');

var MessageBox = require('../ui/message_box.js');

var GameEngine = function() {
  this.cur_game_state = null;
  this.cur_dialog_box = null;
  this.cur_popup_message = null;
  this.stepId = 0;

  this.bgFile = null;
  this.bgAlpha = 0;
  this.switchBgDuration = null;
  this.switchBgTimer = 0;
  this.altBgAlpha = 0;
  this.altBgFile = null;
  this.lastTime = (new Date()).getTime();
  this.gameStateFactory = null;
  this.background = null;
};

// We inject the game states in here from main.js to avoid circular dependencies.
GameEngine.prototype.injectGameStateFactory = function(gameStateFactory) {
  this.gameStateFactory = gameStateFactory;
};

GameEngine.prototype.switch_game_state = function (gsKey, opts) {
  if (this.cur_game_state) {
    this.cur_game_state.dispose();
  }

  this.cur_game_state = this.gameStateFactory.createGameState(gsKey, opts);
};


GameEngine.prototype.step = function () {
  var cur_time = (new Date()).getTime()
  layers.mainCtx.globalAlpha = 1;
  dt = cur_time - this.lastTime
  if (this.cur_dialog_box != null) {
    this.cur_dialog_box.process(dt);
  }
  if (this.cur_popup_message != null) {
    this.process_popup_message(dt)
  }

  if(!(this.cur_game_state.isImpulseGameState)) {
    layers.mainCtx.clearRect(0, 0, canvas.width, canvas.height);
  } else if(this.cur_game_state.isImpulseGameState &&  this.cur_game_state.ready) {
    if(this.cur_game_state.zoom != 1) {
      layers.mainCtx.fillStyle= this.cur_game_state.dark_color;
      layers.mainCtx.fillRect(constants.sideBarWidth, 0, constants.levelWidth, constants.levelHeight);
    } else {
      layers.mainCtx.clearRect(constants.sideBarWidth, 0, constants.levelWidth, constants.levelHeight);
    }

  }

  if (this.cur_game_state) {
    this.cur_game_state.process(dt)
    if(!(this.cur_game_state.isImpulseGameState)) {
      layers.mainCtx.fillStyle = "black"
      layers.mainCtx.fillRect(0, 0, constants.sideBarWidth, constants.canvasHeight);
      layers.mainCtx.fillRect(constants.canvasWidth - constants.sideBarWidth, 0, constants.sideBarWidth, constants.canvasHeight);
      layers.mainCtx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
      this.cur_game_state.draw(layers.mainCtx, layers.bgCtx);
      layers.mainCtx.translate(-constants.sideBarWidth, 0)//allows us to have a topbar
    } else {
      this.cur_game_state.draw(layers.mainCtx, layers.bgCtx);
      layers.mainCtx.save()
      this.cur_game_state.set_zoom_transparency(layers.mainCtx)
      layers.mainCtx.restore()
    }
  }


  if(this.cur_dialog_box!=null) {
    layers.mainCtx.save();
    layers.mainCtx.globalAlpha = 1
    this.cur_dialog_box.draw(layers.mainCtx)
    layers.mainCtx.restore();
  }

  if (this.cur_popup_message != null) {
    this.draw_popup_message(layers.mainCtx)
  }

  this.lastTime = cur_time
  var temp_dt = (new Date()).getTime() - cur_time
  var _this = this;
  this.stepId = setTimeout(function () {
    _this.step()
  }, Math.max(33 - temp_dt, 1))
};


GameEngine.prototype.set_dialog_box = function(box) {
  this.cur_dialog_box = box
};

GameEngine.prototype.clear_dialog_box = function() {
  this.cur_dialog_box = null
};

GameEngine.prototype.set_popup_message = function(type, duration, color, world_num) {
  this.cur_popup_message = new MessageBox(type, color ? color : "white", world_num ? world_num : 0);
  this.cur_popup_message.set_position(constants.canvasWidth/2, constants.canvasHeight - 10 - this.cur_popup_message.h)
  this.cur_popup_message.set_visible(true)
  this.cur_popup_duration = duration;
  this.cur_popup_timer = duration;
};

GameEngine.prototype.process_popup_message = function(dt) {
  this.cur_popup_timer -= dt;
  if (this.cur_popup_timer < 0) {
    this.cur_popup_message = null;
  }
};

GameEngine.prototype.draw_popup_message = function(ctx) {
  ctx.save();
  var prog = this.cur_popup_timer / this.cur_popup_duration;
  if (prog < 0.2) {
    ctx.globalAlpha *= prog * 5;
  } else if (prog > 0.9) {
    ctx.globalAlpha *= 10 * (1 - prog)
  } else {
    ctx.globalAlpha = 1
  }
  this.cur_popup_message.draw(ctx);
  ctx.restore();
};

GameEngine.prototype.toggle_pause = function () {
  if (this.cur_game_state.isImpulseGameState) {
    this.cur_game_state.toggle_pause()
  }
}

GameEngine.prototype.on_mouse_move = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_mouse_move(mPos.x, mPos.y)
  }

  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_mouse_move(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_mouse_move(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_mouse_down = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_mouse_down(mPos.x, mPos.y)
    return
  }
  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_mouse_down(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_mouse_down(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_right_mouse_down = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_right_mouse_down(mPos.x, mPos.y)
    return
  }
  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_right_mouse_down(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_right_mouse_down(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_mouse_up = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_mouse_up(mPos.x, mPos.y)
    return
  }
  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_mouse_up(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_mouse_up(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_right_mouse_up = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_right_mouse_up(mPos.x, mPos.y)
    return
  }
  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_right_mouse_up(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_right_mouse_up(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_click = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_click(mPos.x, mPos.y)
    return
  }
  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_click(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_click(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_right_click = function(mPos) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_right_click(mPos.x, mPos.y)
    return
  }
  if (this.cur_game_state) {
    if(!(this.cur_game_state.isImpulseGameState)) {
      this.cur_game_state.on_right_click(mPos.x - constants.sideBarWidth, mPos.y)
    } else {
      this.cur_game_state.on_right_click(mPos.x, mPos.y)
    }
  }
};

GameEngine.prototype.on_key_down = function(keyCode) {
  if(keyCode == controls.keys.GOD_MODE_KEY && debugVars.god_mode_enabled) { //G = god mode
    if (debugVars.god_mode == false) {
      debugVars.god_mode = true
      this.set_popup_message("god_mode_alert", 2500, "white", 0)
    }
  }

  if(keyCode == controls.keys.MUTE_KEY) { //X = mute/unmute
    this.toggleMute()
  }

  if(keyCode == controls.keys.FULLSCREEN_KEY) {
    this.toggleFullScreen()
  }

  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_key_down(keyCode)
    return
  }
  if (this.cur_game_state) {
    this.cur_game_state.on_key_down(keyCode)
  }
};

GameEngine.prototype.on_key_up = function(keyCode) {
  if(this.cur_dialog_box) {
    this.cur_dialog_box.on_key_up(keyCode)
    //do not return immediately. Allows player to disengage movement
  }
  if (this.cur_game_state) {
    this.cur_game_state.on_key_up(keyCode)
  }
};

GameEngine.prototype.toggleMute = function () {
  if(!music_player.mute) {
    music_player.mute_bg()
    music_player.mute_effects(true);
  } else {
    music_player.unmute_bg()
    music_player.mute_effects(false)
  }
  if (this.cur_dialog_box && this.cur_dialog_box.isOptionsMenu) {
    this.cur_dialog_box.sendMuteSignal(music_player.mute);
  }
};

GameEngine.prototype.toggleFullScreen = function () {
  dom.toggleFullScreen();
  if (this.cur_dialog_box && this.cur_dialog_box.isOptionsMenu) {
    this.cur_dialog_box.sendFullscreenSignal(!isFullScreen);
  }
}

GameEngine.prototype.switchBg = function(background, duration) {
  if (!this.background || this.background.bgFile != background.bgFile) {
    this.switchBgDuration = duration;
    this.switchBgTimer = duration;
    this.newBackground = background;
  }
};

// Will immediately draw the new bg onto the bg_ctx.
GameEngine.prototype.setBg = function(background) {
  layers.bgCtx.clearRect(0, 0, canvas.width, canvas.height);
  layers.bgCtx.drawImage(background.getCanvas(), 0, 0, constants.levelWidth, constants.levelHeight,
    constants.sideBarWidth, 0, constants.levelWidth, constants.levelHeight);
  this.background = background;
}

GameEngine.prototype.processAndDrawBg = function(dt) {
  if (this.switchBgTimer > 0) {
    var prog = this.switchBgTimer / this.switchBgDuration;

    layers.bgCtx.clearRect(0, 0, canvas.width, canvas.height);
    layers.bgCtx.save();
    layers.bgCtx.globalAlpha = prog;
    layers.bgCtx.drawImage(this.background.getCanvas(), 0, 0, constants.levelWidth, constants.levelHeight, constants.sideBarWidth, 0, constants.levelWidth, constants.levelHeight);
    layers.bgCtx.globalAlpha = (1 - prog);
    layers.bgCtx.drawImage(this.newBackground.getCanvas(), 0, 0, constants.levelWidth, constants.levelHeight, constants.sideBarWidth, 0, constants.levelWidth, constants.levelHeight);
    layers.bgCtx.restore();

    this.switchBgTimer -= dt;
  } else if (this.switchBgDuration != null) {
    // At the end of the transition, directly set the bg.
    this.switchBgDuration = null;
    this.setBg(this.newBackground);
    this.newBackground = null;
  }
}

GameEngine.prototype.isQuestCompleted = function (name) {
  return saveData.isQuestCompleted(name);
}

GameEngine.prototype.setQuestCompleted = function(name) {
  if (!this.isQuestCompleted(name)) {
    saveData.setQuestCompleted(name);
    this.set_popup_message("quest_" + name, 2500, "white", 0)
  }
}

module.exports = new GameEngine();

},{"../core/music_player.js":10,"../data/constants.js":13,"../data/debug.js":14,"../render/ui.js":82,"../ui/message_box.js":89,"./controls.js":2,"./dom.js":3,"./layers.js":7}],5:[function(require,module,exports){
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');

var Background = require('../render/background.js');
var EnemyFactory = require('../enemy/enemy_factory.js');

var graphics = {};

graphics.generateEnemyBufferImages = function () {
  for(var i in enemyData) {
    if(enemyData[i].batch_enemy_image) {
      var temp_enemy = new (EnemyFactory.getEnemyClassFromType(i))(null, 0, 0, 0, null)
      enemyData[i].images = temp_enemy.generate_images();
    }
  }
};

graphics.generateBackgrounds = function () {
    graphics.menuBackground = new Background(constants.colors['menuBg']);
}

module.exports = graphics;

},{"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy_factory.js":31,"../render/background.js":73}],6:[function(require,module,exports){
var dom = require('./dom.js');
var game_engine = require('../core/game_engine.js');
var utils = require('../core/utils.js');

var io = {};

function on_mouse_move(event) {
  var mPos = utils.getCursorPosition(event)

  game_engine.on_mouse_move(mPos);
}

function on_mouse_down(event) {
  event.preventDefault()

  var mPos = utils.getCursorPosition(event)
  if(event.button == 0) {
    game_engine.on_mouse_down(mPos);
  } else if(event.button == 2) {
    game_engine.on_right_mouse_down(mPos);
  }
}

function on_mouse_up(event) {
  event.preventDefault()

  var mPos = utils.getCursorPosition(event)

  if(event.button == 0) {
    game_engine.on_mouse_up(mPos);
  } else if(event.button == 2) {
    game_engine.on_right_mouse_up(mPos);
  }
}

function on_click(event) {

  event.preventDefault()

  var mPos = utils.getCursorPosition(event)

  if(event.button == 0) {
    game_engine.on_click(mPos);
  } else if(event.button == 2) {
    game_engine.on_right_click(mPos);
  }
}

function on_key_down(event) {
  var keyCode = event==null? window.event.keyCode : event.keyCode;
  game_engine.on_key_down(keyCode);
}

function on_key_up(event) {
  var keyCode = event==null? window.event.keyCode : event.keyCode;
  game_engine.on_key_up(keyCode);
}

function on_resize(event) {
  dom.centerCanvas();
}

io.set_up_listeners = function () {
  document.addEventListener('keydown', on_key_down);
  document.addEventListener('keyup', on_key_up);
  document.addEventListener('click', on_click);
  document.addEventListener('mousedown', on_mouse_down);
  document.addEventListener('mouseup', on_mouse_up);
  document.addEventListener('mousemove', on_mouse_move)
  document.addEventListener('resize', on_resize)
}

module.exports = io;

},{"../core/game_engine.js":4,"../core/utils.js":11,"./dom.js":3}],7:[function(require,module,exports){
var constants = require('../data/constants.js');

var layers = {};

layers.setUpLayers = function() {
  var world_menu_bg_canvas = document.createElement('canvas');
  world_menu_bg_canvas.width = constants.levelWidth;
  world_menu_bg_canvas.height = constants.levelHeight;
  layers.worldMenuBgCanvas = world_menu_bg_canvas

  // screen setup
  layers.mainCanvas = document.getElementById("canvas");
  var canvas_container = document.getElementById("canvas_container");
  layers.mainCanvas.width = constants.canvasWidth;
  layers.mainCanvas.height =  constants.canvasHeight;
  canvas_container.style.width = constants.canvasWidth + 'px'
  canvas_container.style.height = constants.canvasHeight + 'px'

  layers.bgCanvas = document.getElementById("bg_canvas");
  var bg_canvas_container = document.getElementById("bg_canvas_container");
  layers.bgCanvas.width = constants.canvasWidth;
  layers.bgCanvas.height =  constants.canvasHeight;
  bg_canvas_container.style.width = constants.canvasWidth + 'px'
  bg_canvas_container.style.height = constants.canvasHeight + 'px'

  layers.mainCtx = layers.mainCanvas.getContext('2d');
  layers.bgCtx = layers.bgCanvas.getContext('2d');
}

module.exports = layers;

},{"../data/constants.js":13}],8:[function(require,module,exports){
var logging = {};

logging.send_logging_to_server = function (msg, tags) {
  if (window.location.host === 'localhost') {
    window.console.log('LOGGING');
    window.console.log(msg);
    window.console.log(tags);
  } else {
    window["Raven"]["captureMessage"](msg, tags);
  }
};

module.exports = logging;

},{}],9:[function(require,module,exports){
var controls = require('./controls.js');
var debugVars = require('../data/debug.js');
var dom = require('./dom.js');
var EnemyFactory = require('../enemy/enemy_factory.js');
var enemyMap = require('../enemy/enemy_map.js');
var enemyRenderUtils = require('../render/enemy.js');
var game_engine = require('../core/game_engine.js');
var gsKeys = require('../data/constants.js').gsKeys;
var io = require('./io.js');
var graphics = require('../core/graphics.js');
var layers = require('./layers.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');

var GameStateFactory = require('../game_states/game_state_factory.js');
var IntroState = require('../game_states/intro_state.js');

var main = {};

main.executeGame = function() {
  EnemyFactory.setEnemyMap(enemyMap);
  saveData.loadGame()
  io.set_up_listeners();
  dom.setUpDocument();
  layers.setUpLayers()
  controls.setKeyBindings()
  graphics.generateEnemyBufferImages();
  graphics.generateBackgrounds();
  music_player.setPlayerOptions();
  game_engine.injectGameStateFactory(GameStateFactory);
  if (debugVars.dev) {
    game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
  } else {
    game_engine.switch_game_state(gsKeys.INTRO_STATE, {});
  }
  game_engine.step()
}

main.clearMessageAndStartGame = function () {
  dom.clearMessage();
  setTimeout(function() {
    main.executeGame();
  }, 50)
};

module.exports = main;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../core/music_player.js":10,"../data/constants.js":13,"../data/debug.js":14,"../enemy/enemy_factory.js":31,"../enemy/enemy_map.js":32,"../game_states/game_state_factory.js":50,"../game_states/intro_state.js":52,"../load/save_data.js":69,"../render/enemy.js":74,"./controls.js":2,"./dom.js":3,"./io.js":6,"./layers.js":7}],10:[function(require,module,exports){
var audioData = require('../data/audio_data.js');
var buzz = require('../vendor/buzz.js');
var saveData = require('../load/save_data.js');

var MusicPlayer = function() {
  this.sounds = {}
  this.multisounds = {}
  this.cur_song = null
  this.initialize_multisounds();
  this.playing = {}
  this.mute = false;
  this.effects_mute = false;
};

MusicPlayer.prototype.setPlayerOptions = function () {
  this.mute = saveData.optionsData.bg_music_mute
  this.effects_mute = saveData.optionsData.effects_mute
};

MusicPlayer.prototype.initialize_multisounds = function() {
  for(var multisound in audioData.multisounds) {
    this.initialize_sound_set(audioData.multisounds[multisound].file, audioData.multisounds[multisound].maxnum);
  }
}

MusicPlayer.prototype.play_sound = function(sound, volume) {
  this.play(audioData.sounds[sound], volume)
}

MusicPlayer.prototype.play = function(file, volume) {
  if(this.effects_mute) return
  if(file in this.multisounds) {
    this.play_multisound(file);
    return;
  }

  if(!(file in this.sounds)) {
    this.sounds[file] = new buzz.sound("audio/"+file+".ogg");
  }

  this.sounds[file].play();
  //this.sounds[file].setVolume(1);//saveData.optionsData.effects_volume);
  if (volume) {
    this.sounds[file].setVolume(volume);
  } else {
    this.sounds[file].setVolume(saveData.optionsData.effects_volume);
  }
}

MusicPlayer.prototype.mute_effects = function(mute) {
  this.effects_mute = mute
  saveData.optionsData.effects_mute = mute
  saveData.saveGame()
}

MusicPlayer.prototype.play_multisound = function(file) {

  for(var i = 0; i < this.multisounds[file].length; i++) {
    if(!this.multisounds[file][i]) {

      this.sounds[file+i].play();
      this.sounds[file+i].setVolume(saveData.optionsData.effects_volume);
      this.multisounds[file][i] = true;
      return;
    }
  }

}

MusicPlayer.prototype.initialize_sound_set = function(file, maxnum) {
  this.multisounds[file] = []
  for(var i = 0; i < maxnum; i++) {
    this.multisounds[file].push(false);
    this.sounds[file+i] = new buzz.sound("audio/"+file+".ogg");
    var _this = this;
    this.sounds[file+i].bind("ended", (function(index, file) {
            return function(e) {
              // unset play flag after done
              _this.multisounds[file][index] = false;
            }
          })(i, file))
  }
}

MusicPlayer.prototype.switch_bg = function(file) {
  console.log('switch bg', file, this.cur_song)
  if(this.cur_song) {
    this.sounds[this.cur_song].stop();
  }
  this.cur_song = null;
  this.play_bg(file);

}

MusicPlayer.prototype.mute_bg = function() {
  this.mute = true
  saveData.optionsData.bg_music_mute = true
  saveData.saveGame()
  if(this.cur_song) {
    this.sounds[this.cur_song].setVolume(0);
    this.playing[this.cur_song] = false
  }
}

MusicPlayer.prototype.unmute_bg = function() {
  this.mute = false
  saveData.optionsData.bg_music_mute = false
  saveData.saveGame()
  if(this.cur_song) {
    this.sounds[this.cur_song].setVolume(saveData.optionsData.bg_music_volume);
    this.playing[this.cur_song] = true
  }
}

MusicPlayer.prototype.change_bg_volume = function(volume, save) {
  saveData.optionsData.bg_music_volume = volume
  if(this.cur_song && !this.mute) {
    this.sounds[this.cur_song].setVolume(saveData.optionsData.bg_music_volume);
  }
  if (save) {
    saveData.saveGame()
  }
}

MusicPlayer.prototype.change_effects_volume = function(volume) {
  saveData.optionsData.effects_volume = volume
  saveData.saveGame()
}

MusicPlayer.prototype.bg_is_playing = function() {
  return this.playing[this.cur_song]
}

MusicPlayer.prototype.play_bg = function(file) {
  console.log('play bg', file, this.cur_song)
  // if a song is playing and it is different from 'file'
  if(this.cur_song != null && this.cur_song != file) {
    var _this = this;

    // if the song is already paused, just switch it immediately
    if(this.sounds[this.cur_song].isPaused()) {
      this.switch_bg(file)
      return
    }

    this.playing[this.cur_song] = false
    this.playing[file] = true

    // switch the song after fading out for 500ms
    this.sounds[this.cur_song].fadeOut(500, function() {
       _this.switch_bg(file)
    })
    return
  }

  // if the file is not loaded yet, load the sound
  if(!(file in this.sounds)) {

    // if the file needs to loop from mid-way through the song, add a listener
    if(file in audioData.song_repeats) {
      this.sounds[file] = new buzz.sound("audio/"+file+".ogg");
      this.sounds[file].bind("ended", function(e) {
             this.setTime(audioData.song_repeats[file]);
             this.play();
          });
    // otherwise, just loop it.
    } else {
      this.sounds[file] = new buzz.sound("audio/"+file+".ogg",{
        loop: true
      });
    }
  }

  // stop the file if it is already playing
  if(!this.mute) {
    this.sounds[file].setVolume(saveData.optionsData.bg_music_volume);
  } else {
    this.sounds[file].setVolume(0);
  }
  this.sounds[file].play();

  this.playing[file] = true
  this.cur_song = file;
}

MusicPlayer.prototype.pause_bg = function() {
  console.log('pausing bg', this.cur_song)
  if(this.cur_song in this.sounds) {
    this.sounds[this.cur_song].pause();
  }
}

MusicPlayer.prototype.stop_bg = function() {
  console.log('stop bg', this.cur_song)
  if(this.cur_song) {
    this.playing[this.cur_song] = false
    var _this = this;
    var current_song = this.cur_song
    _this.sounds[_this.cur_song].fadeOut(300, function() {
        if(_this.cur_song && !_this.playing[_this.cur_song]) {
          _this.sounds[_this.cur_song].stop();
         _this.cur_song = null;
        // in this case, start_bg was called again on the same song before the fade_out happened.
        // in this case, set the volume back to full.
        } else if (_this.cur_song == current_song && _this.playing[_this.cur_song]) {
          _this.sounds[_this.cur_song].setVolume(saveData.optionsData.bg_music_volume)
        }
    })
  }
}

MusicPlayer.prototype.resume_bg = function() {
  console.log('resume bg', this.cur_song)
  if(this.cur_song in this.sounds) {
    this.sounds[this.cur_song].play();
  }
}

MusicPlayer.prototype.getCurrentSong = function() {
  return {
    title: this.cur_song,
    sound: this.sounds[this.cur_song]
  }
}

MusicPlayer.prototype.getCurrentPercent = function() {
  return this.sounds[this.cur_song].getTime()/this.sounds[this.cur_song].getDuration()
}

MusicPlayer.prototype.skip = function(time) {
  this.sounds[this.cur_song].setTime(time)
}

module.exports = new MusicPlayer()

},{"../data/audio_data.js":12,"../load/save_data.js":69,"../vendor/buzz.js":98}],11:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var levelData = require('../data/level_data.js');

var utils = {};

utils.eq = function(a, b) {
  return a.x == b.x && a.y == b.y
};

utils.convertSecondsToTimeString = function(seconds) {
  var a = seconds % 60;
  a = a < 10 ? "0"+a : a;
  return Math.floor(seconds/60)+":"+a;
};

utils.isVisibleThroughPolygon = function (v_i, v_j, polygon) {
  var j = polygon.length - 1
  var ans = false

  for( var i = 0; i < polygon.length; i++)
  {
    if(utils.segIntersection(v_i, v_j, polygon[i], polygon[j])) {
      return false
    }

    j = i
  }
  return true

};

utils.isVisible = function (v_i, v_j, edges, ignore_polygon) {
  // ignore_polygon ignores edges of a certain polygon. Only works with boundary polygons.

  // prevents an obstacle polygon with no p_n from equally ignore_polygon
  if(ignore_polygon === undefined) ignore_polygon = null;
  for(var k = 0; k < edges.length; k++)
  {

    if(utils.eq(v_i, edges[k]["p1"]) || utils.eq(v_i, edges[k]["p2"]) || utils.eq(v_j, edges[k]["p1"]) || utils.eq(v_j, edges[k]["p2"])) {
      continue
    }
    if(edges[k]["p1"]["p_n"] !== ignore_polygon && utils.segIntersection(v_i, v_j, edges[k]["p1"], edges[k]["p2"]))
    {
      return false
    }
  }
  return true
};

utils.pointInPolygon = function (polygon, point)
//polygon is an array of box_2d.b2Vec2
{
  var j = polygon.length - 1
  var ans = false

  for( var i = 0; i < polygon.length; i++)
  {
    if(polygon[i].y < point.y && polygon[j].y >=point.y || polygon[i].y >= point.y && polygon[j].y < point.y)
    {
      if(polygon[i].y!=polygon[j].y && (polygon[i].x + (point.y - polygon[i].y)/(polygon[j].y - polygon[i].y)*(polygon[j].x - polygon[i].x) < point.x))
      {
        ans = !ans
      }
    }
    j = i
  }
  return ans
};

utils.closestPolygonEdgeToPoint = function (polygon, point) {
  var j = polygon.length - 1
  var ans = {p1: null, p2: null, dist: null}

  for(var i = 0; i < polygon.length; i++)
  {

    var dist = utils.segDistFromPt(polygon[i], polygon[j], point)
    if(ans.dist == null || dist < ans.dist) {

      var angle_one = utils.atan(point, polygon[j])
      var angle_two = utils.angleClosestTo(angle_one,utils.atan(point, polygon[i]))
      if(angle_two - angle_one < Math.PI/2) {
        // ensure that the edge is close to the point...necessary for CONCAVE polygons
      } else {
        ans.p1 = polygon[j]
        ans.p2 = polygon[i]
        ans.dist = dist
      }
    }
    j = i
  }
  return ans
};


utils.closestPolygonVertexToPoint = function(polygon, point) {
  var ans = {v: null, dist: null}

  for(var i = 0; i < polygon.length; i++)
  {

    var dist = utils.pDist(polygon[i], point)
    if(ans.dist == null || dist < ans.dist) {

      ans.dist = dist
      ans.v = polygon[i]
    }
  }
  return ans
};

utils.pDist = function(p1, p2)
{
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))
};

utils.segIntersection = function (seg1s, seg1f, seg2s, seg2f)
{
  var seg1d = {x: seg1f.x - seg1s.x, y: seg1f.y - seg1s.y}
  var seg2d = {x: seg2f.x - seg2s.x, y: seg2f.y - seg2s.y}
  var a = {x: seg2s.x - seg1s.x, y: seg2s.y - seg1s.y}
  var b = utils.crossProduct(seg1d, seg2d)
  if(b==0)
  {
    if(utils.crossProduct(a, seg2d)==0)
    {
      return false//lines are collinear. For the purposes of our visibility_graph, this does not count as an intersection
    }
    //lines are parallel
  }
  var t = utils.crossProduct(a, seg2d)/b
  var s = utils.crossProduct(a, seg1d)/b
  return t>=0 && t<=1 && s>=0 && s<=1
};

utils.getSegIntersection = function (seg1s, seg1f, seg2s, seg2f)
{
  var seg1d = {x: seg1f.x - seg1s.x, y: seg1f.y - seg1s.y}
  var seg2d = {x: seg2f.x - seg2s.x, y: seg2f.y - seg2s.y}
  var a = {x: seg2s.x - seg1s.x, y: seg2s.y - seg1s.y}
  var b = utils.crossProduct(seg1d, seg2d)
  if(b==0)
  {
    if(utils.crossProduct(a, seg2d)==0)
    {
      return null//lines are collinear. For the purposes of our visibility_graph, this does not count as an intersection
    }
    //lines are parallel
  }
  var t = utils.crossProduct(a, seg2d)/b
  var s = utils.crossProduct(a, seg1d)/b
  if(t>=0 && t<=1 && s>=0 && s<=1)
  {
    return {x: seg1s.x + seg1d.x * t, y: seg1s.y + seg1d.y * t}
  }
  else
    return null
};

utils.segDistFromPt = function(seg1s, seg1f, pt) {
  return Math.abs(utils.crossProduct({x: seg1f.x - seg1s.x, y: seg1f.y - seg1s.y}, {x: pt.x - seg1s.x, y: pt.y - seg1s.y})) /
         Math.sqrt((seg1f.x - seg1s.x) * (seg1f.x - seg1s.x)  + (seg1f.y -seg1s.y) * (seg1f.y -seg1s.y));
};

utils.pathSafeFromPt = function (path, pt, dist) {
  for(var i = 0; i < path.length-1; i++) {
    if(utils.segDistFromPt(path[i], path[i+1], pt) < dist)
      return false;
  }
  return true;
};

utils.crossProduct = function(v1, v2)
{
  return v1.x*v2.y - v1.y*v2.x
}

utils.dotProduct = function(v1, v2)
{
  return v1.x*v2.x + v1.y*v2.y
}

utils.getCursorPosition = function(e){

    var x;
    var y;
    if (e.pageX || e.pageY) {
      x = e.pageX;
      y = e.pageY;
    }
    else {
      x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    x -= constants.offsetLeft;
    y -= constants.offsetTop;
    return {x: x, y: y}

}

// returns -Math.pi to Math.pi
utils.atan = function(center, ray) {
  if(center == null || ray == null) {
    console.log("ERROR")
  }
  var angle
  if(center.x == ray.x)
  {
    if(center.y > ray.y)
    {
      angle = -Math.PI/2
    }
    else
    {
      angle = Math.PI/2
    }
    return angle
  }
  angle = Math.atan((center.y-ray.y)/(center.x-ray.x))
  if(center.x > ray.x && center.y < ray.y)
  {
    angle +=Math.PI
  } else if(center.x > ray.x && center.y >= ray.y) {
    angle -= Math.PI
  }
  return angle
}

utils.getObjectsWithinRadius = function(pt, r, objects, getLocation)
{
  var ans = []
  for(var i = 0; i < objects.length; i++)
  {
    var loc = getLocation(objects[i])
    if (utils.pDist(pt, loc)<r)
    {
      ans.push(objects[i])
    }
  }
  return ans

}

utils.getBoundaryPolygon = function(polygon, radius) {
  var j = polygon.length - 1
  var ans = []
  for(var i = 0; i < polygon.length; i++)
  {
    var k = (i+1)%polygon.length
    var j_to_i_normal = new box_2d.b2Vec2(polygon[i].y - polygon[j].y, polygon[j].x - polygon[i].x)
    var j_to_i = new box_2d.b2Vec2(polygon[i].x - polygon[j].x, polygon[i].y - polygon[j].y)
    var k_to_i_normal = new box_2d.b2Vec2(polygon[k].y - polygon[i].y, polygon[i].x - polygon[k].x)
    var k_to_i = new box_2d.b2Vec2(polygon[i].x - polygon[k].x, polygon[i].y - polygon[k].y)
    j_to_i_normal.Normalize()
    k_to_i_normal.Normalize()
    j_to_i.Normalize()
    k_to_i.Normalize()
    var first_angle = utils.atan({x: 0, y: 0}, k_to_i_normal)
    var second_angle = utils.atan({x: 0, y: 0}, j_to_i_normal)
    var cur_angle = first_angle - second_angle
    cur_angle = cur_angle < 0? cur_angle+Math.PI * 2 : cur_angle
    cur_angle = cur_angle >= 2 * Math.PI ? cur_angle - Math.PI * 2 : cur_angle
    if (cur_angle > Math.PI) {
      ans.push({"x": polygon[i].x+j_to_i_normal.x*radius - j_to_i.x*1/Math.tan(cur_angle/2 - Math.PI/2)*radius, "y": polygon[i].y + j_to_i_normal.y*radius - j_to_i.y *1/Math.tan(cur_angle/2 - Math.PI/2)* radius})

    }
    else if(cur_angle > 5*Math.PI/6)
    {
      ans.push({"x": polygon[i].x+j_to_i_normal.x*radius+j_to_i.x*radius, "y": polygon[i].y + j_to_i_normal.y*radius + j_to_i.y * radius})
      ans.push({"x": polygon[i].x+k_to_i_normal.x*radius+k_to_i.x*radius, "y": polygon[i].y + k_to_i_normal.y*radius + k_to_i.y * radius})
    }
    else
    {
      ans.push({"x": polygon[i].x+j_to_i_normal.x*radius+j_to_i.x*Math.tan(cur_angle/2)*radius, "y": polygon[i].y + j_to_i_normal.y*radius + j_to_i.y *Math.tan(cur_angle/2)* radius})

    }


   j = i
  }
  return ans
}

utils.checkBounds = function(buffer, pt, draw_factor) {
  var factor = draw_factor ? draw_factor : 1;
  return pt.x >= buffer && pt.y >= buffer && pt.x <= constants.levelWidth/factor - buffer && pt.y <= (constants.levelHeight)/factor - buffer;
}

utils.getSafestSpawnPoint = function(object, player, level_name) {
  //returns the spawn point whose angle is closest to opposite the player

  var spawn_points = levelData.levels[level_name].spawn_points

  var best_point = null
  var best_value = 0

  var angle_to_player = utils.atan(object.body.GetPosition(), player.body.GetPosition())

  for(var i = 0; i < spawn_points.length; i++){
    var angle = utils.angleClosestTo(angle_to_player, utils.atan(object.body.GetPosition(), {x: spawn_points[i][0]/constants.drawFactor, y: spawn_points[i][1]/constants.drawFactor}))
    var diff = Math.abs(angle - angle_to_player)
    if(diff > best_value) {
      best_value = diff
      best_point = spawn_points[i]
    }
  }

  return {x: best_point[0]/constants.drawFactor, y: best_point[1]/constants.drawFactor}

}

utils.getNearestSpawnPoint = function(object, player, level_name) {
  //returns the spawn point whose angle is closest to opposite the player

  var spawn_points = levelData.levels[level_name].spawn_points

  var best_point = null
  var best_value = 1000


  for(var i = 0; i < spawn_points.length; i++){
    var dist = utils.pDist({x: spawn_points[i][0]/constants.drawFactor, y: spawn_points[i][1]/constants.drawFactor}, object.body.GetPosition())
    if(dist < best_value) {
      best_value = dist
      best_point = spawn_points[i]
    }
  }

  return {x: best_point[0], y: best_point[1]}

}

utils.getRandomOutsideLocation = function(buffer, range) {
  var x_anchor, y_anchor
  if(Math.random() < .5)
  {
    x_anchor = Math.random() < .5 ? -buffer-range : constants.levelWidth/constants.drawFactor + buffer
    y_anchor = Math.random() * ((constants.levelHeight)/constants.drawFactor + 2 * buffer + range) - (buffer + range)
  }
  else
  {
    y_anchor = Math.random() < .5 ? -buffer-range : (constants.levelHeight)/constants.drawFactor + buffer
    x_anchor = Math.random() * (constants.levelWidth/constants.drawFactor + 2 * buffer + range) - (buffer + range)
  }

  //buffer is border outside screen which is not okay, range is range of values beyond that which ARE okay
  var r_point = {x: x_anchor + Math.random() * range, y: y_anchor + Math.random() * range }
  return r_point
}

utils.getWindowDimensions = function() {
  var winW = 800, winH = 600;
  if (document.body && document.body.offsetWidth) {
   winW = document.body.offsetWidth;
   winH = document.body.offsetHeight;
  }
  if (document.compatMode=='CSS1Compat' &&
      document.documentElement &&
      document.documentElement.offsetWidth ) {
   winW = document.documentElement.offsetWidth;
   winH = document.documentElement.offsetHeight;
  }
  if (window.innerWidth && window.innerHeight) {
   winW = window.innerWidth;
   winH = window.innerHeight;
  }

  return {w: winW, h: winH}
}

utils.getLines = function(ctx,phrase,maxPxLength,textStyle) {
  var wa=phrase.split(" "),
      phraseArray=[],
      lastPhrase=wa[0],
      l=maxPxLength,
      measure=0;
  if(wa.length == 1) {return wa}
  ctx.font = textStyle;
  for (var i=1;i<wa.length;i++) {
      var w=wa[i];
      measure=ctx.measureText(lastPhrase+w).width;
      if (measure<l && w!= "#") {
          lastPhrase+=(" "+w);
      }else {
          phraseArray.push(lastPhrase);
          if(w != "#")
            lastPhrase=w;
          else
            lastPhrase = ""
      }
      if (i===wa.length-1) {
          phraseArray.push(lastPhrase);
          break;
      }
  }
  return phraseArray;
}

utils.isAngleBetween = function(small, large, angle) {
//assumes large - small < Math.Pi * 2
  var t_small = small
  var t_large = large
  while(t_small < angle) {
    t_small += Math.PI * 2

  }
  while(t_small > angle) {
    t_small -= Math.PI * 2
  }

  while(t_large > angle) {
    t_large -= Math.PI * 2
  }
  while(t_large < angle) {
    t_large += Math.PI * 2
  }

  return t_large - t_small <= Math.PI * 2
}

utils.angleClosestTo = function(this_angle, other_angle) {
  while(other_angle - this_angle > Math.PI) {
    other_angle -= 2 * Math.PI
  }
  while(other_angle - this_angle < -Math.PI) {
    other_angle += 2 * Math.PI
  }
  return other_angle

}

utils.smallAngleBetween = function(angle1, angle2) {
  var ans = angle1 - angle2;

  if(ans > Math.PI * 2) ans -= Math.PI * 2
  if(ans < 0) ans += Math.PI * 2;

  if(ans > Math.PI)
    ans = Math.PI * 2 - ans
  return ans
}

utils.bezierInterpolate = function(mid1, mid2, t) {

 return (Math.pow(1-t,3) * 0 + 3*Math.pow(1-t,2)*t*mid1+ 3*(1-t)*Math.pow(t,2)*mid2+ Math.pow(t,3)*1);
}

utils.createBody = function(world, polygons, x, y, lin_damp, density, categoryBits, maskBits, type, owner, self) {
  var bodyDef = new box_2d.b2BodyDef;
  if(type == "static") {
    bodyDef.type = box_2d.b2Body.b2_staticBody
  } else
    bodyDef.type = box_2d.b2Body.b2_dynamicBody;
  bodyDef.position.x = x;
  bodyDef.position.y = y;
  bodyDef.linearDamping = lin_damp;
  var body = world.CreateBody(bodyDef)

  for(var i = 0; i < polygons.length; i++) {
    var polygon = polygons[i]
    var this_shape = null
    if(polygon.type == "circle") {
      this_shape = new box_2d.b2CircleShape(polygon.r)
      this_shape.SetLocalPosition(new box_2d.b2Vec2(polygon.x, polygon.y))
    }
    if(polygon.type == "polygon") {
      var vertices = []
      for(var j= 0; j < polygon.vertices.length; j++) {
        vertices.push(new box_2d.b2Vec2(polygon.x + polygon.r * polygon.vertices[j][0], polygon.y + polygon.r * polygon.vertices[j][1]))
      }
      this_shape = new box_2d.b2PolygonShape
      this_shape.SetAsArray(vertices, vertices.length)
    }

    var fixDef = new box_2d.b2FixtureDef;//make the shape
    fixDef.density = density;
    fixDef.friction = 0;
    fixDef.restitution = 0.7;
    fixDef.filter.categoryBits = categoryBits
    fixDef.filter.maskBits = maskBits
    fixDef.shape = this_shape
    body.CreateFixture(fixDef).SetUserData({"body": body, "owner": owner, "self": self})

  }

  return body;
}

utils.getNextLevelName = function(level, world_num) {
  if(!level) {
    return utils.getFirstLevelName(world_num);
  } else {
    if(level.level_number < 7) {
      return "HIVE "+world_num+"-"+(level.level_number+1)
    } else {
      return "BOSS "+world_num
    }
  }
}

utils.getFirstLevelName = function (world_num) {
  if (world_num == 0) {
    return "HIVE 0-1"
  }

  return "HIVE "+world_num+"-1"
}

module.exports = utils;

},{"../data/constants.js":13,"../data/level_data.js":16,"../vendor/box2d.js":97}],12:[function(require,module,exports){
var audioData = {};

audioData.songs = {
  "Menu": "complex",
  "Interlude": "complex",
  "Hive 1": "kickit",
  "Hive 2": "breakthru",
  "Hive 3": "emergence",
  "Hive 4": "fire",
  "Tessellation": "driven",
  "Final Tessellation": "wicked"
};
audioData.song_repeats = {
  "driven": 27.460,
  "wicked": 2.922
};
audioData.sounds = {
  "impulse": "effects/impulse",
  "pdeath": "effects/pdeath",
  "ffrenzy": "effects/ffrenzy",
  "multi": "effects/multi",
  "ult": "effects/ult",
  "pwheel": "effects/pwheel",
  "goo": "effects/goo",
  "sshot": "effects/sshot",
  "deathray": "effects/deathray",
  "b1hit": "effects/b1hit",
  "b1shrink": "effects/b1shrink",
  "b1grow": "effects/b1grow",
  "b2bhole": "effects/b2bhole",
  "b3strike": "effects/b3strike",
  "b3select": "effects/b3select",
  "b4spawner": "effects/b4spawner",
  "b4attacker": "effects/b4attacker",
  "b4darkness": "effects/b4darkness",
  "dark_diag": "effects/dark_diag",
  "dark_anger": "effects/dark_anger",
};
audioData.multisounds = {
  "b3tick": {
    file: "effects/b3tick",
    maxnum: 2
  },
  "sdeath": {
    file: "effects/sdeath",
    maxnum: 4
  },
  "tdeath": {
    file: "effects/tdeath",
    maxnum: 4
  },
  "hfire": {
    file: "effects/hfire",
    maxnum: 2
  },
  "hhit": {
    file: "effects/hhit",
    maxnum: 2
  },
  "fbullet": {
    file: "effects/fbullet",
    maxnum: 4
  },
  "fbullethit": {
    file: "effects/fbullethit",
    maxnum: 4
  },
  "b2eat": {
    file: "effects/b2eat",
    maxnum: 4
  },
  "b4spawneract": {
    file: "effects/b4spawneract",
    maxnum: 2
  }
};

for(var multisounds in audioData.multisounds) {
  audioData.sounds[multisounds] = audioData.multisounds[multisounds].file
}

module.exports = audioData;

},{}],13:[function(require,module,exports){
var constants = {};

constants.drawFactor = 15;

constants.canvasWidth = 1200;
constants.canvasHeight = 600;

constants.sideBarWidth = 200;
constants.levelWidth = constants.canvasWidth - 2 * constants.sideBarWidth;
constants.levelHeight = constants.canvasHeight;
constants.offsetLeft = 0;
constants.offsetTop = 0;

constants.enemyCanvasFactor = 1.5;

var impulseColors = {};
impulseColors['bronze'] = "#cc8032"
impulseColors['silver'] = "#c0c0c0"
impulseColors['impulse_target_blue'] = "rgba(0, 128, 255, 0.2)"
impulseColors['impulse_blue'] = "rgb(0, 128, 255)"
impulseColors['impulse_blue_dark'] = "#13527e"
impulseColors['rose'] = "#ff66cc";
impulseColors['gold'] = "#edb900"

impulseColors['menuBg'] = '#231f20';
impulseColors['world 0 bg'] = '#080808';
impulseColors['world 1 bg'] = '#000d00';
impulseColors['world 2 bg'] = '#010310';
impulseColors['world 3 bg'] = '#0f0013';
impulseColors['world 4 bg'] = '#180000';

impulseColors['world 0'] = "#333"
impulseColors['world 0 lite'] = "#999"
impulseColors['world 0 bright'] = "#fff"
impulseColors['world 0 dark'] = "#080808"
impulseColors['world 1'] = "#034903"
impulseColors['world 1 lite'] = "#046a04"
impulseColors['world 1 bright'] = "#00ff00"
impulseColors['world 1 dark'] = "#000d00"
impulseColors['world 2'] = "#0020b0"//"rgb(0, 206, 209)"
impulseColors['world 2 lite'] = "#0028dd"//"rgb(0, 206, 209)"
impulseColors['world 2 bright'] = "#003DFF" //"#2474fe"
impulseColors['world 2 dark'] = "#010310"//"rgb(0, 206, 209)"
impulseColors['world 3'] = "#450555"
impulseColors['world 3 lite'] = "#5f0775"
impulseColors['world 3 dark'] = "#0f0013"
impulseColors['world 3 bright'] = "#C000FF"//"#a00cc5"
impulseColors['world 4'] = "#600"
impulseColors['world 4 lite'] = "#a00"
impulseColors['world 4 dark'] = "#180000"
impulseColors['world 4 bright'] = "#f00"
impulseColors["player_color"] = "rgb(32, 140, 231)"
impulseColors["boss"] = "red"
impulseColors["boss dark"] = "#900"
impulseColors["boss 1"] = "#05c205"
impulseColors["boss 2"] = "#002eff"
impulseColors["boss 3"] = "#C000FF"
impulseColors["boss 4"] = "#f00"

constants.colors = impulseColors;

var gsKeys = {};

gsKeys.CREDITS_STATE = 0;
gsKeys.GAME_OVER_STATE = 1;
gsKeys.IMPULSE_GAME_STATE = 2;
gsKeys.INTRO_STATE = 3;
gsKeys.LEVEL_EDITOR_STATE = 4;
gsKeys.LEVEL_INTRO_STATE = 5;
gsKeys.LOADER_GAME_STATE = 6;
gsKeys.MAIN_GAME_SUMMARY_STATE = 7;
gsKeys.MAIN_GAME_TRANSITION_STATE = 8;
gsKeys.MUSIC_PLAYER_STATE = 9;
gsKeys.QUEST_GAME_STATE = 10;
gsKeys.REWARD_GAME_STATE = 11;
gsKeys.TITLE_STATE = 12;
gsKeys.WORLD_MAP_STATE = 13;

constants.gsKeys = gsKeys;

module.exports = constants;

},{}],14:[function(require,module,exports){
var debugVars = {
  god_mode_enabled: true,
  god_mode: false,
  dev: false,
  old_menu: false,
  show_zero_level: false,
  is_beta: true,
  instant_victory_enabled: false,
  hide_pause_menu: false,
  use_minified_worker: true,
  jukebox_enabled: false
};

if (window.location.host === 'localhost' && window.location.search.indexOf("dev=1") !== -1) {
  debugVars.dev = true;
}
if (window.location.pathname.indexOf("beta") !== -1) {
  debugVars.is_beta = true;
}

module.exports = debugVars;

},{}],15:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');

var enemyData = {};

enemyData["dumb_stunner"] = {
  color: "#00ffff",///"#999",
  density: 2.2,
  lin_damp: 6,
  effective_radius: .5,
  force: 0, // does not move
  score_value: 100,
  attack_rating: 1,
  batch_enemy_image: true,
  true_name: "stunner",
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3)],
    [Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3)]]}],
  draw_polygons: [{type: "polygon", x: -0.1, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3)],
    [Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3)]]}],
  enemy_info: [
    "On collision, stuns you for a short period",
  ],
  snippet: "stuns on collision",
}

enemyData["stunner"] = {
  color: "#00ffff",///"#999",
  density: 1.5,
  lin_damp: 4,
  effective_radius: .5,
  force: .42,
  score_value: 100,
  attack_rating: 1,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3)],
    [Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3)]]}],
  draw_polygons: [{type: "polygon", x: -0.1, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3)],
    [Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3)]]}],
  enemy_info: [
    "On collision, stuns you for a short period",
  ],
  true_name: "shocker",
  snippet: "stuns on collision",
}

enemyData["spear"] = {
  color: "#f86003",
  density: 0.7,
  lin_damp: 4,
  effective_radius: .7,
  force: .24,
  score_value: 500,
  attack_rating: 7,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .7, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 5/6), Math.sin(Math.PI * 5/6)],
    [Math.cos(Math.PI * 7/6), Math.sin(Math.PI * 7/6)]]}],
  enemy_info: [
    "Will dive at you if it has line of sight",
  ],
  snippet: "charges on sight",
}

enemyData["tank"] = {
  color: "#6f27cf",
  density: 2.5,
  lin_damp: 3,
  effective_radius: 1,
  force: 1.5,
  score_value: 1000,
  attack_rating: 8,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 1, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 1), Math.sin(Math.PI * 1)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]}],
  extra_rendering_lines: [{"x1": 0.5, "y1": 0.5, "x2": -0.5, "y2": -0.5},
    {"x1": 0.5, "y1": -0.5, "x2": -0.5, "y2": 0.5},
  ],
  enemy_info: [
    "Explodes on death or collision with player",
    "Will explode on collision with another Tank if recently Impulsed",
    "The explosion radius is outlined around the tank",
  ],
  snippet: "explodes on death",
}

enemyData["mote"] = {
  color: "#ee42ae",
  density: .5,
  lin_damp: 3,
  effective_radius: .5,
  force: .15,
  score_value: 1000,
  attack_rating: .5,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 1), Math.sin(Math.PI * 1)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]}],
  enemy_info: [
    "Cannot be Impulsed # # On collision, disarms you for a few moments",
    "Other enemies can be impulsed into the mote"
  ],
  snippet: "unaffected by impulse",
}

enemyData["goo"] = {
  color: "#e6c43c",
  density: 7,
  lin_damp: 9,
  effective_radius: .5,
  force: 3.5,
  score_value: 3000,
  attack_rating: .25,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 2/5), Math.sin(Math.PI * 2/5)],
  [Math.cos(Math.PI * 4/5), Math.sin(Math.PI * 4/5)],
  [Math.cos(Math.PI * 6/5), Math.sin(Math.PI * 6/5)],
  [Math.cos(Math.PI * 8/5), Math.sin(Math.PI * 8/5)]]}],
  extra_rendering_polygons: [{type: "circle", x: 0, y: 0, r: 1.3, colored: true}],
  enemy_info: [
    "All units within its radius are slowed",
    "When Impulsed, expands its radius for a few moments",
  ],
  snippet: "slows all nearby units",
}

enemyData["harpoon"] = {
  color: "#00aa00",
  density: 5,
  lin_damp: 6,
  effective_radius: 0.7,
  force: 4.5,
  score_value: 3000,
  attack_rating: 6,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .7, vertices:
  [[Math.cos(Math.PI * 1/4) - 0.4, Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 7/8) - 0.4, Math.sin(Math.PI * 7/8)],
  [Math.cos(Math.PI * 9/8) - 0.4, Math.sin(Math.PI * 9/8)],
  [Math.cos(Math.PI * 7/4) - 0.4, Math.sin(Math.PI * 7/4)],
  ]}],
  extra_rendering_polygons: [{type: "polygon", x: -0.1, y: 0, r: .7, colored: false, vertices:
  [[Math.cos(Math.PI * 7/4) - 0.4, Math.sin(Math.PI * 7/4)],
  [((Math.sqrt(2)+Math.sqrt(6))/2 - 0.4)*Math.cos(Math.PI * 0), Math.sin(Math.PI * 0)],
  [Math.cos(Math.PI * 1/4)  - 0.4, Math.sin(Math.PI * 1/4)]]},
    {type: "polygon", x: -0.1, y: 0, r: .7, vertices:
  [[Math.cos(Math.PI * 1/4) - 0.4, Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 7/8) - 0.4, Math.sin(Math.PI * 7/8)],
  [Math.cos(Math.PI * 9/8) - 0.4, Math.sin(Math.PI * 9/8)],
  [Math.cos(Math.PI * 7/4) - 0.4, Math.sin(Math.PI * 7/4)],
  ]}],
  draw_polygons: [],
  enemy_info: [
    "Fires its hook at you and # attempts to yank you in # # Can only fire through the void",
    "The hook range is outlined # around the Harpoon",
    "If you are hooked, # impulse the harpoon to get free",
    "While the hook is detached from the Harpoon, it cannot move",
    "During boss battles, will fire at any time",
  ],
  snippet: "hooks through walls",
}

enemyData["harpoonhead"] = {
  color: "#00dd00",
  density: 1.2,
  lin_damp: 6,
  effective_radius: enemyData["harpoon"].effective_radius * Math.sqrt(6)/3,
  force: 1.5,
  score_value: 1000,
  attack_rating: 6,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: enemyData["harpoon"].effective_radius * Math.sqrt(6)/3, vertices:
  [[Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3)],
  [Math.cos(Math.PI * 0), Math.sin(Math.PI * 0)],
  [Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3)]]
  }],
}

enemyData["fighter"] = {
  color: "#0000ff",
  density: 3,
  lin_damp: 6,
  effective_radius: 0.75,
  force: 2.5,
  score_value: 4000,
  attack_rating: 9,
  true_name: "hunter",
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 0.75, vertices:
  [[Math.cos(Math.PI * 1/4) + 0.3, Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 3/4) + 0.3, Math.sin(Math.PI * 3/4)],
  [Math.cos(Math.PI * 5/4) + 0.3, Math.sin(Math.PI * 5/4)],
  [Math.cos(Math.PI * 7/4) + 0.3, Math.sin(Math.PI * 7/4)]]},
  {type: "polygon", x: 0, y: 0, r: 0.75, vertices:
  [[Math.cos(Math.PI * 3/4)  + 0.3, Math.sin(Math.PI * 3/4)],
  [Math.cos(Math.PI * 1/4)  + 0.3, Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 3/4) - Math.sqrt(6)/4  + 0.3, Math.sqrt(2)]]},
  {type: "polygon", x: 0, y: 0, r: 0.75, vertices:
  [[Math.cos(Math.PI * 7/4)  + 0.3, Math.sin(Math.PI * 7/4)],
  [Math.cos(Math.PI * 5/4)  + 0.3, Math.sin(Math.PI * 5/4)],
  [Math.cos(Math.PI * 3/4) - Math.sqrt(6)/4  + 0.3, -Math.sqrt(2)]]}
  ],
  enemy_info: [
    "Fires projectiles at you on sight # # Is weak to its own projectiles",
    "When its rage meter is full, # the hunter moves faster and its bullets cannot be impulsed",
    "Impulse the hunter to lower its rage meter"
  ],
  snippet: "weak to projectiles",
}

enemyData["fighter_bullet"] = {
  color: "#0000ec",
  density: 1,
  lin_damp: 3,
  effective_radius: .3,
  force: 0.5,
  score_value: 0,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/4), Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 3/4), Math.sin(Math.PI * 3/4)],
  [Math.cos(Math.PI * 5/4), Math.sin(Math.PI * 5/4)],
  [Math.cos(Math.PI * 7/4), Math.sin(Math.PI * 7/4)]]}],
}

enemyData["piercing_fighter_bullet"] = {
  color: "#ff0000",
  density: 1,
  lin_damp: 3,
  effective_radius: .3,
  force: 1,
  score_value: 0,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/4), Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 3/4), Math.sin(Math.PI * 3/4)],
  [Math.cos(Math.PI * 5/4), Math.sin(Math.PI * 5/4)],
  [Math.cos(Math.PI * 7/4), Math.sin(Math.PI * 7/4)]]}],
}


enemyData["disabler"] = {
  color: "#cccccc",
  density: 8,
  lin_damp: 9,
  effective_radius: .5,
  force: 5,
  score_value: 5000,
  attack_rating: .25,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: .5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/3), Math.sin(Math.PI * 1/3)],
  [Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3)],
  [Math.cos(Math.PI * 3/3), Math.sin(Math.PI * 3/3)],
  [Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3)],
  [Math.cos(Math.PI * 5/3), Math.sin(Math.PI * 5/3)]]}
    ],
  extra_rendering_polygons: [{type: "circle", x: 0, y: 0, r: 1.3, colored: true}],
  enemy_info: [
    "Disables all units within its radius. # # Touching disabled units will not reset your multiplier.",
    "When Impulsed, expands its radius for a few moments",
  ],
  true_name: "equalizer",
  snippet: "disables all nearby units",
}

enemyData["troll"] = {
  color: "#159d31",
  density: 1.3,
  lin_damp: 3,
  effective_radius: 0.7,
  force: 0.38,
  score_value: 4000,
  attack_rating: 2,
  true_name: "pinwheel",
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 1, vertices:
  [[0, 0],
  [0.25 * Math.cos(Math.PI * 5/3), 0.25 * Math.sin(Math.PI * 5/3)],
  [Math.sqrt(52)/8 * Math.cos(-0.408), Math.sqrt(52)/8 * Math.sin(-0.408)],
  [0.25 * Math.cos(Math.PI * 1/3), 0.25 * Math.sin(Math.PI * 1/3)]]},
  {type: "polygon", x: 0, y: 0, r: 1, vertices:
  [[0, 0],
  [0.25 * Math.cos(Math.PI * 1/3), 0.25 * Math.sin(Math.PI * 1/3)],
  [Math.sqrt(52)/8 * Math.cos(-0.408 + Math.PI*2/3), Math.sqrt(52)/8 * Math.sin(-0.408 + Math.PI*2/3)],
  [0.25 * Math.cos(Math.PI * 3/3), 0.25 * Math.sin(Math.PI * 3/3)]]},
  {type: "polygon", x: 0, y: 0, r: 1, vertices:
  [[0, 0],
  [0.25 * Math.cos(Math.PI * 3/3), 0.25 * Math.sin(Math.PI * 3/3)],
  [Math.sqrt(52)/8 * Math.cos(-0.408 + Math.PI*4/3), Math.sqrt(52)/8 * Math.sin(-0.408 + Math.PI*4/3)],
  [0.25 * Math.cos(Math.PI * 5/3), 0.25 * Math.sin(Math.PI * 5/3)]]},
  ],
  draw_polygons: [{type: "polygon", x: -0.2, y: 0, r: 1, vertices:
  [[0, 0],
  [0.25 * Math.cos(Math.PI * 5/3 + 0.36), 0.25 * Math.sin(Math.PI * 5/3+ 0.36)],
  [Math.sqrt(52)/8 * Math.cos(-0.408+ 0.36), Math.sqrt(52)/8 * Math.sin(-0.408+ 0.36)],
  [0.25 * Math.cos(Math.PI * 1/3+ 0.36), 0.25 * Math.sin(Math.PI * 1/3+ 0.36)]]},
  {type: "polygon", x: -0.2, y: 0, r: 1, vertices:
  [[0, 0],
  [0.25 * Math.cos(Math.PI * 1/3+ 0.36), 0.25 * Math.sin(Math.PI * 1/3+ 0.36)],
  [Math.sqrt(52)/8 * Math.cos(-0.408 + Math.PI*2/3+ 0.36), Math.sqrt(52)/8 * Math.sin(-0.408 + Math.PI*2/3+ 0.36)],
  [0.25 * Math.cos(Math.PI * 3/3+ 0.36), 0.25 * Math.sin(Math.PI * 3/3+ 0.36)]]},
  {type: "polygon", x: -0.2, y: 0, r: 1, vertices:
  [[0, 0],
  [0.25 * Math.cos(Math.PI * 3/3+ 0.36), 0.25 * Math.sin(Math.PI * 3/3+ 0.36)],
  [Math.sqrt(52)/8 * Math.cos(-0.408 + Math.PI*4/3+ 0.36), Math.sqrt(52)/8 * Math.sin(-0.408 + Math.PI*4/3+ 0.36)],
  [0.25 * Math.cos(Math.PI * 5/3+ 0.22), 0.25 * Math.sin(Math.PI * 5/3+ 0.22)]]},
  ],
  enemy_info: [
    "On collision or if impulsed while spinning, # reverses your controls",
  ],
  snippet: "reverses your controls",
}


enemyData["slingshot"] = {
  color: "#a0522d",
  density: .2,
  lin_damp: 7,
  effective_radius: 1,
  force: .65,
  score_value: 5000,
  attack_rating: 10,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: -0.25, y: 0, r: 1, vertices:
    [[Math.cos(Math.PI * 0) * 1/4, Math.sin(Math.PI*0) * 1/4],
  [Math.cos(Math.PI * 2/3)  * 1/2, Math.sin(Math.PI * 2/3) * 1/2],
  [Math.cos(Math.PI * 4/3) * 1/2, Math.sin(Math.PI * 4/3) * 1/2]]},
    {type: "polygon", x: -0.25, y: 0, r: 1, vertices:
    [[Math.cos(Math.PI * 0) * 1, Math.sin(Math.PI*0) * 1],
  [Math.cos(Math.PI * 2/3)  * 1, Math.sin(Math.PI * 2/3) * 1],
  [Math.cos(Math.PI * 2/3)  * 1, Math.sin(Math.PI * 2/3) * 1/2],
  [Math.cos(Math.PI * 0)  * 1/4, Math.sin(Math.PI * 0) * 1/4]]},
    {type: "polygon", x: -0.25, y: 0, r: 1, vertices:
    [[Math.cos(Math.PI * 0) * 1, Math.sin(Math.PI*0) * 1],
  [Math.cos(Math.PI * 0)  * 1/4, Math.sin(Math.PI * 0) * 1/4],
  [Math.cos(Math.PI * 4/3)  * 1, Math.sin(Math.PI * 4/3) * 1/2],
  [Math.cos(Math.PI * 4/3)  * 1, Math.sin(Math.PI * 4/3) * 1]]}],
  erase_lines: [
    [[Math.cos(Math.PI * 0) * 1/4-0.25, Math.sin(Math.PI*0) * 1/4], [Math.cos(Math.PI * 0) * .75-0.25, Math.sin(Math.PI*0) * 3/4]],
  ],
  true_name: "boomerang",
  enemy_info: [
    "When Impulsed, latches onto its current position # and slingshots back at you",
    "cannot be impulsed while latched",
  ],
  snippet: "slingshots when impulsed",
}

enemyData["orbiter"] = {
  color: "red",
  density: .3,
  lin_damp: 15,
  effective_radius: 0.5,
  force: .96,
  score_value: 5000,
  attack_rating: 10,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 0.5, vertices:
    [[Math.cos(Math.PI * 0) + 0.4, Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 2/3) + 0.4, Math.sin(Math.PI * 2/3)],
  [0.4, 0]]},
   {type: "polygon", x: 0, y: 0, r: 0.5, vertices:
    [[Math.cos(Math.PI * 4/3) + 0.4, Math.sin(Math.PI*4/3)],
  [Math.cos(Math.PI * 0) + 0.4, Math.sin(Math.PI * 0)],
  [0.4, 0]]},
  {type: "polygon", x: 0, y: 0, r: 0.5, vertices:
    [[0.4, 0],
    [-0.6, 0.3],
    [-1.6, 0],
    [-0.6, -0.3]]},
  ],
  erase_lines: [
    [[0.5, 0], [0.2, 0]]
  ],
  enemy_info: [
    "Intelligently avoids your Impulse # # Will charge at you opportunistically",
  ],
  snippet: "intelligent and dangerous",
}

enemyData["deathray"] = {
  color: "#dddddd",//"#169f95",
  interior_color: "black",
  density: 6,
  lin_damp: 6,
  effective_radius: 1,
  force: 7.2,
  score_value: 10000,
  attack_rating: 10,
  batch_enemy_image: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 1.5, vertices:
    [[0.5 * Math.cos(Math.PI * 3/4) + 0.2, 0.5 * Math.sin(Math.PI*3/4)],
    [Math.cos(Math.PI * 3/4)+ 0.2, Math.sin(Math.PI*3/4)],
    [Math.cos(Math.PI * 5/4)+ 0.2, Math.sin(Math.PI*5/4)],
    [0.5 * Math.cos(Math.PI * 5/4)+ 0.2, 0.5 * Math.sin(Math.PI*5/4)]]},
  {type: "polygon", x: 0, y: 0, r: 1.5, vertices:
    [[0.6 * Math.cos(Math.PI * 1/3)+ 0.2, 0.6 * Math.sin(Math.PI*1/3)],
    [Math.cos(Math.PI * 3/4)+ 0.2, Math.sin(Math.PI*3/4)],
    [0.5 * Math.cos(Math.PI * 3/4)+ 0.2, 0.5 * Math.sin(Math.PI*3/4)],
    [0.8 * Math.cos(Math.PI * 1/3)+ 0.2, 0.3 * Math.sin(Math.PI*1/3)]]},
  {type: "polygon", x: 0, y: 0, r: 1.5, vertices:
    [[0.8 * Math.cos(Math.PI * 5/3)+ 0.2, 0.3 * Math.sin(Math.PI*5/3)],
    [0.5 * Math.cos(Math.PI * 5/4)+ 0.2, 0.5 * Math.sin(Math.PI*5/4)],
    [Math.cos(Math.PI * 5/4)+ 0.2, Math.sin(Math.PI*5/4)],
    [0.6 * Math.cos(Math.PI * 5/3)+ 0.2, 0.6 * Math.sin(Math.PI*5/3)]]}
  ],

  enemy_info: [
    "After firing, must recharge for a short period # # During this time, the deathray cannot move",
  ],
  snippet: "giant death ray",
}

enemyData["boss_one"] = {
  color: constants.colors["boss 1"],
  density: 4.5,
  lin_damp: 8,
  effective_radius: 3,
  force: 0,
  score_value: [1000000, 5000000, 15000000],
  attack_rating: 10,
  is_boss: true,
  categoryBits: box_2d.BOSS_ONE_BIT,
  maskBits: box_2d.PLAYER_BIT | box_2d.ENEMY_BIT,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 2/2), Math.sin(Math.PI * 2/2)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]},
  ],
  death_polygons: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 2/2), Math.sin(Math.PI * 2/2)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]},
  ],
  upper_arm_polygon: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 2/2), Math.sin(Math.PI * 2/2)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]}
  ],
  lower_arm_polygon: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 2/2), Math.sin(Math.PI * 2/2)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]}
  ],
  hand_polygon: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/2), Math.sin(Math.PI * 1/2)],
  [Math.cos(Math.PI * 2/2), Math.sin(Math.PI * 2/2)],
  [Math.cos(Math.PI * 3/2), Math.sin(Math.PI * 3/2)]]}
  ],
}

enemyData["boss_two"] = {
  color: constants.colors["boss 2"],
  //color: "gray",//"rgb(244, 164, 96)",
  density: 4.5,
  lin_damp: 8,
  effective_radius: 3,
  force: 0,
  score_value: [1000000, 5000000, 15000000],
  attack_rating: 10,
  is_boss: true,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/4), Math.sin(Math.PI * 1/4)],
  [Math.cos(Math.PI * 2/4), Math.sin(Math.PI * 2/4)],
  [Math.cos(Math.PI * 3/4), Math.sin(Math.PI * 3/4)],
  [Math.cos(Math.PI * 4/4), Math.sin(Math.PI * 4/4)],
  [Math.cos(Math.PI * 5/4), Math.sin(Math.PI * 5/4)],
  [Math.cos(Math.PI * 6/4), Math.sin(Math.PI * 6/4)],
  [Math.cos(Math.PI * 7/4), Math.sin(Math.PI * 7/4)]]}],
  death_polygons: [{type: "polygon", x: 0, y: 0, r: 3, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [0.5 * Math.cos(Math.PI * 2/4), 0.5 * Math.sin(Math.PI * 2/4)],
  [Math.cos(Math.PI * 4/4), Math.sin(Math.PI * 4/4)],
  [0.5 * Math.cos(Math.PI * 6/4), 0.5 * Math.sin(Math.PI * 6/4)]]}],
}

enemyData["boss_three"] = {
  color: "#C000FF",//"rgb(244, 164, 96)",
  density: 2,
  lin_damp: 8,
  effective_radius: 4.5,
  force: 0,
  attack_rating: 10,
  score_value: [1000000, 5000000, 15000000],
  is_boss: true,
  categoryBits: box_2d.BOSS_THREE_BIT,
  maskBits: box_2d.PLAYER_BIT | box_2d.ENEMY_BIT,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 4.5, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 1/8), Math.sin(Math.PI * 1/8)],
  [Math.cos(Math.PI * 2/8), Math.sin(Math.PI * 2/8)],
  [Math.cos(Math.PI * 3/8), Math.sin(Math.PI * 3/8)],
  [Math.cos(Math.PI * 4/8), Math.sin(Math.PI * 4/8)],
  [Math.cos(Math.PI * 5/8), Math.sin(Math.PI * 5/8)],
  [Math.cos(Math.PI * 6/8), Math.sin(Math.PI * 6/8)],
  [Math.cos(Math.PI * 7/8), Math.sin(Math.PI * 7/8)],
  [Math.cos(Math.PI * 8/8), Math.sin(Math.PI * 8/8)],
  [Math.cos(Math.PI * 9/8), Math.sin(Math.PI * 9/8)],
  [Math.cos(Math.PI * 10/8), Math.sin(Math.PI * 10/8)],
  [Math.cos(Math.PI * 11/8), Math.sin(Math.PI * 11/8)],
  [Math.cos(Math.PI * 12/8), Math.sin(Math.PI * 12/8)],
  [Math.cos(Math.PI * 13/8), Math.sin(Math.PI * 13/8)],
  [Math.cos(Math.PI * 14/8), Math.sin(Math.PI * 14/8)],
  [Math.cos(Math.PI * 15/8), Math.sin(Math.PI * 15/8)]
  ]}],
  death_polygons: [{type: "polygon", x: 0, y: 0, r: 4.5, vertices:
    [[0.8 * Math.cos(Math.PI * 1/3), 0.8 * Math.sin(Math.PI*1/3)],
    [0.6 * Math.cos(Math.PI * 2/3), 0.6 * Math.sin(Math.PI*2/3)],
    [0.6 * Math.cos(Math.PI * 4/3), 0.6 * Math.sin(Math.PI*4/3)],
    [0.8 * Math.cos(Math.PI * 5/3), 0.8 * Math.sin(Math.PI * 5/3)]]}
  ],
  arm_polygon: [{type: "polygon", x: 0, y: 0, r: 2, vertices:
    [[0, 0],
  [Math.cos(Math.PI * 0/8), Math.sin(Math.PI * 0/8)],
  [Math.cos(Math.PI * 1/8), Math.sin(Math.PI * 1/8)]]}
  ],
};

enemyData["boss_four"] = {
  color: "#ff0000",
  density: 3,
  lin_damp: 10,
  effective_radius: 4,
  force: 0,
  attack_rating: 10,
  score_value: [1000000, 5000000, 15000000],
  is_boss: true,
  categoryBits: box_2d.BOSS_FOUR_BIT,
  maskBits: box_2d.PLAYER_BIT | box_2d.ENEMY_BIT,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 4, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 2/5), Math.sin(Math.PI * 2/5)],
  [Math.cos(Math.PI * 4/5), Math.sin(Math.PI * 4/5)],
  [Math.cos(Math.PI * 6/5), Math.sin(Math.PI * 6/5)],
  [Math.cos(Math.PI * 8/5), Math.sin(Math.PI * 8/5)]]}
  ],
  body_bud_radius: 2,
  bud_polygon: [{type: "polygon", x: 0, y: 0, r: 2, vertices:
    [[Math.cos(Math.PI * 0) , Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 2/5) , Math.sin(Math.PI * 2/5)],
    [Math.cos(Math.PI * 4/5) , Math.sin(Math.PI * 4/5)],
    [Math.cos(Math.PI * 6/5) , Math.sin(Math.PI * 6/5)],
    [Math.cos(Math.PI * 8/5) , Math.sin(Math.PI * 8/5)]]}
  ],
  death_polygons: [{type: "polygon", x: 0, y: 0, r: 2, vertices:
    [[Math.cos(Math.PI * 0) , Math.sin(Math.PI*0)],
    [Math.cos(Math.PI * 2/5) , Math.sin(Math.PI * 2/5)],
    [Math.cos(Math.PI * 4/5) , Math.sin(Math.PI * 4/5)],
    [Math.cos(Math.PI * 6/5) , Math.sin(Math.PI * 6/5)],
    [Math.cos(Math.PI * 8/5) , Math.sin(Math.PI * 8/5)]]}
  ],
}

enemyData["boss_four_attacker"] = {
  color: "white",
  density: 1.5,
  lin_damp: 1,
  initial_radius: 0.1,
  effective_radius: 2.2,
  force: 360,
  attack_rating: 10,
  score_value: [1000000, 5000000, 15000000],
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 0.1, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 2/5), Math.sin(Math.PI * 2/5)],
  [Math.cos(Math.PI * 4/5), Math.sin(Math.PI * 4/5)],
  [Math.cos(Math.PI * 6/5), Math.sin(Math.PI * 6/5)],
  [Math.cos(Math.PI * 8/5), Math.sin(Math.PI * 8/5)]]}
  ],
}

enemyData["boss_four_spawner"] = {
  color: "rgb(0, 255, 0)",
  density: 4,
  lin_damp: 12,
  initial_radius: 0.1,
  effective_radius: 1,
  force: 0,
  score_value: 5000,
  shape_polygons: [{type: "polygon", x: 0, y: 0, r: 0.1, vertices:
    [[Math.cos(Math.PI * 0), Math.sin(Math.PI*0)],
  [Math.cos(Math.PI * 2/5), Math.sin(Math.PI * 2/5)],
  [Math.cos(Math.PI * 4/5), Math.sin(Math.PI * 4/5)],
  [Math.cos(Math.PI * 6/5), Math.sin(Math.PI * 6/5)],
  [Math.cos(Math.PI * 8/5), Math.sin(Math.PI * 8/5)]]}
  ],
}

module.exports = enemyData;

},{"../data/constants.js":13,"../vendor/box2d.js":97}],16:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');

var levels = {};

//enemy format is [start_spawn_time, spawn_period, number_of_spawn, incr_of_spawn_per_minute, cap]

levels['HIVE 0-1'] = {
  enemies_easy: {
  },
  enemies: {
  },
  initial_spawn_data_easy: {
  },
  initial_spawn_data: {
  },
  obstacle_v: [],
  multi_spawn_points: [],
  spawn_points: [],
  buffer_radius: 1,
  max_rating: 50,
  cutoff_scores: {
    "normal": [0, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 200, y: 300},
  gateway_loc: {x: 600, y: 300},
  impulse_disabled: true,
  no_save: true
}

levels['HIVE 0-2'] = {
  enemies_easy: {
  },
  enemies: {
  },
  initial_spawn_data_easy: {
  },
  initial_spawn_data: {
  },
  // Old design which "isolated" the player
  // obstacle_v: [[[60,120],[120,120],[120,420],[680,420],[680,120],[740,120],[740,480],[60,480]],[[180,120],[620,120],[620,360],[560,360],[560,180],[240,180],[240,360],[180,360]]],
  //obstacle_v: [[[-50,260],[370,260],[370,360],[-50,360]],[[50,460],[751,460],[750,520],[50,520]],[[850,360],[430,360],[430,260],[850,260]]],
  obstacle_v: [[[239,458],[561,458],[561,518],[239,518]],[[340,361],[135,361],[135,630],[-50,630],[-50,260],[340,260]],[[460,260],[850,260],[850,630],[665,630],[665,361],[460,361]]],
  multi_spawn_points: [],
  spawn_points: [[25, 490], [775, 490]],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "normal": [0, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 400, y: 560},
  gateway_loc: {x: 400, y: 200},
  impulse_disabled: true,
  no_save: true
}

levels['HIVE 0-3'] = {
  enemies_easy: {
    "dumb_stunner": [0, 1, 0, 1, 1, 0, 1],
  },
  enemies: {
    "dumb_stunner": [0, 1, 0, 1, 1, 0, 1],
  },
  initial_spawn_data_easy: {
    "dumb_stunner": 1
  },
  initial_spawn_data: {
    "dumb_stunner": 1
  },
  obstacle_v:  [[[50,-50],[50,650],[-50,650],[-50,-50]],[[750,-50],[750,650],[850,650],[850,-50]],[[847,200],[516,200],[516,30],[285,30],[285,200],[-53,200],[-53,-50],[847,-51]],[[-47,400],[284,400],[284,570],[516,570],[516,400],[853,400],[853,650],[-47,651]]],
  multi_spawn_points: [],
  spawn_points: [[200, 300]],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "easy": [200, 300000, 1200000], // scores are irrelevant.
    "normal": [200, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 100, y: 300},
  gateway_loc: {x: 600, y: 300},
  show_score_interface: true,
  no_save: true
}

levels['HIVE 0-4'] = {
  enemies_easy: {
    "dumb_stunner": [0, 1, 0, 1, 1, 0, 4],
  },
  enemies: {
    "dumb_stunner": [0, 1, 0, 1, 1, 0, 4],
  },
  initial_spawn_data_easy: {
    "dumb_stunner": 4
  },
  initial_spawn_data: {
    "dumb_stunner": 4
  },
  obstacle_v:  [[[-50,-51],[850,-51],[850,52],[522,50],[522,129],[278,129],[278,50],[-50,50]],[[-50,550],[278,550],[278,471],[522,471],[522,550],[850,548],[850,651],[-50,651]],[[50,651],[-50,649],[-50,-50],[50,-50],[50,219],[122,219],[122,380],[50,380]],[[750,-51],[850,-49],[850,650],[750,650],[750,381],[678,381],[678,220],[750,220]]],
  multi_spawn_points: [[300, 200], [300, 400], [500, 200], [500, 400]],
  spawn_points: [[300, 300], [500, 300], [400, 200], [400, 400]],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "easy": [2000, 10000, 20000],
    "normal": [2000, 10000, 20000],
  },
  player_loc: {x: 400, y: 300},
  spawn_pattern: "spread",
  show_full_interface: true,
  no_save: true
}

levels['HIVE 1-0'] = {
  enemies_easy: {
  },
  enemies: {
  },
  initial_spawn_data_easy: {
  },
  initial_spawn_data: {
  },
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  multi_spawn_points: [],
  spawn_points: [],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "normal": [0, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 400, y: 500},
  gateway_loc: {x: 400, y: 350},
}

levels['HIVE 1-1'] = {
  enemies_easy: {
    //"stunner": [0, 4, 1.75, 2, 50]
    "stunner": [0, 4, 1, 1, 2, 0, 50]
  },
  enemies: {
    "stunner": [0, 1.5, 0.5, 1, 4, 2, 50]
  },
  initial_spawn_data_easy: {
    "stunner": 2
  },
  initial_spawn_data: {
    "stunner": 4
  },
  obstacle_v: [[[-33,-26],[19,-26],[19,626],[-33,626]],[[833,626],[781,626],[781,-26],[833,-26]],[[144,367],[656,367],[656,626],[144,626]],[[144,-26],[656,-26],[656,233],[144,233]]],
  obstacle_v_easy: [[[-33,-26],[19,-26],[19,626],[-33,626]],[[833,626],[781,626],[781,-26],[833,-26]],[[174,400],[626,400],[626,626],[174,626]],[[174,-26],[626,-26],[626,200],[174,200]]],
  multi_spawn_points: [[81, 75], [81, 525], [719, 75], [719, 525]],
  multi_spawn_points_easy: [[250, 250], [250, 350], [550, 250], [550, 350]],
  spawn_points: [[50, -100], [750, -100], [50, 700], [750, 700]],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "easy": [600, 50000, 300000],
    "normal": [500000, 400000, 800000],
  },
  player_loc: {x: 400, y: 300}
}

levels['HIVE 1-2'] = {
  enemies: {
    "stunner": [3, 3, 0, 3, 3, 2, 25],
    "spear": [0, 3, 0, 3, 2, 2, 25],
  },

  enemies_easy: {
    "stunner": [2, 3, 1, 1, 1, 0, 25],
    "spear": [0, 7, 1, 1, 2, 0, 25],
  },
  initial_spawn_data: {
    "spear": 4,
  },
  initial_spawn_data_easy: {
    "spear": 1,
  },
  //obstacle_v: [[[103,104],[343,104],[103,245]],[[103,356],[343,496],[103,496]],[[697,245],[457,104],[697,104]],[[697,496],[457,496],[697,356]]],
  obstacle_v: [[[112,-6],[688,-6],[688,26],[112,26]],[[-9,96],[30,96],[30,505],[-9,505]],[[809,504],[770,504],[770,95],[809,95]],[[688,606],[112,606],[112,574],[688,574]],[[135,126],[330,126],[135,259]],[[135,341],[330,474],[135,474]],[[665,259],[470,126],[665,126]],[[665,474],[470,474],[665,341]]],
  multi_spawn_points: [[135, 300], [665, 300], [400, 125], [400, 475], [709, 78], [91, 78], [709, 522], [91, 522]],
  spawn_points: [[-50, -50], [850, 650], [850, -50], [-50, 650]],
  buffer_radius: 1,
  cutoff_scores: {

    "easy": [2500, 80000, 400000],
    "normal": [500000, 400000, 1000000],
  },
  player_loc: {x: 400, y: 300}
}

levels['HIVE 1-3'] = {
  enemies_easy: {
    "stunner": [0, 3, 0.5, 1, 3, 0, 40],
    "spear": [15, 6, 1.5, 1.5, 1, 0, 15],
  },
  enemies: {
    "stunner": [0, 3, 1, 1, 4, 0, 50],
    "spear": [4, 4, 0, 4, 1, 1, 15],
  },
  initial_spawn_data_easy: {
    "stunner": 4
  },
  initial_spawn_data: {
    "stunner": 12
  },
  //obstacle_v: [[[103,104],[343,104],[104,275]],[[696,275],[457,104],[697,104]],[[104,325],[343,496],[103,496]],[[697,496],[457,496],[696,325]]] ,
  // obstacle_v: [[[-11,-10],[335,-10],[-11,252]],[[-11,348],[335,610],[-11,610]],[[811,252],[465,-10],[811,-10]],[[811,610],[465,610],[811,348]],[[466,300],[400,348],[335,300],[400,251]]],
  obstacle_v: [[[466,300],[400,348],[335,300],[400,251]],[[-11,-10],[305,-10],[305,12],[10,236],[-11,236]],[[-11,364],[10,364],[305,588],[305,610],[-11,610]],[[811,236],[791,236],[495,12],[495,-10],[811,-10]],[[811,610],[495,610],[495,588],[791,364],[811,364]]],
  spawn_points: [[-100, 300], [400, -100], [900, 300], [400, 700]],
  multi_spawn_points: [[400, 50], [50, 300], [400, 550], [750, 300]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [2500, 120000, 600000],
    "normal": [500000, 300000, 1200000],
  },
  player_loc: {x: 400, y: 400}

}

levels['HIVE 1-4'] = {
  enemies_easy: {
    "spear": [0, 5, 2, 1, 2, 0, 40],
  },
  enemies: {
    "spear": [0, 4, 1, 2, 3, 4, 40],
  },
  initial_spawn_data: {
    "spear": 4
  },
  initial_spawn_data_easy: {
    "spear": 2
  },
  //obstacle_v: [[[-15,73],[323,269],[-15,269]],[[-15,331],[323,331],[-15,528]],[[815,269],[477,269],[815,73]],[[362,387],[362,610],[-15,610]],[[438,213],[438,-10],[815,-10]],[[-15,-10],[362,-10],[362,213]],[[815,610],[438,610],[438,387]],[[815,528],[477,331],[815,331]]],
  obstacle_v: [[[-15,73],[265,253],[-15,269]],[[336,426],[362,610],[-15,610]],[[464,175],[438,-10],[815,-10]],[[-15,331],[265,348],[-15,527]],[[815,269],[535,253],[815,73]],[[-15,-10],[362,-10],[336,175]],[[815,610],[438,610],[464,426]],[[815,527],[535,348],[815,331]]],
  spawn_points: [[-100, 14], [900, 14], [900, 586], [-100, 586], [-100, 300], [400, -100], [900, 300], [400, 700]],
  multi_spawn_points: [[400, 125], [400, 475], [125,300], [675, 300], [177, 145], [623, 145], [177, 455], [623, 455]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy":  [4000, 200000, 750000],
    "normal":  [750000, 400000, 1500000],
  },
  player_loc: {x: 400, y: 300}
}

levels['HIVE 1-6'] = {
  enemies: {
    "spear": [0, 7, 0, 7, 2, 1.5, 15],
    "tank": [1, 5, 0, 5, 3, 2, 25]
  },
  // Okay to make spawn higher since it's already hard to die in EASY
  enemies_easy: {
    "spear": [6, 6, 2, 2, 1.5, 0, 15],
    "tank": [0, 5, 2, 1, 1, 0, 25]
  },
  initial_spawn_data: {
    "spear":8,
  },
  initial_spawn_data_easy: {
    "tank": 6
  },
  //obstacle_v: [[[150, 50], [650, 50], [650, 100], [150, 100]], [[150, 500], [650, 500], [650, 550], [150, 550]], [[50, 150], [100, 150], [100, 450], [50, 450]], [[700, 150], [750, 150], [750, 450], [700, 450]]],
  obstacle_v: [[[103,1],[688,1],[688,27],[103,27]],[[799,483],[770,483],[770,116],[799,116]],[[103,573],[688,573],[688,599],[103,599]],[[1,116],[30,116],[30,483],[1,483]]],
  spawn_points: [[-100, -100], [900, -100], [900, 700], [-100, 700]],
  multi_spawn_points: [[66, 528], [66, 72], [734, 528], [66, 528]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy":   [7500, 200000, 600000],
    "normal":   [1000000, 400000, 1250000],
  },
  player_loc: {x: 400, y: 300}
}

levels['HIVE 1-5'] = {
  enemies: {
    "stunner": [2, 6, 0, 6, 3, 2, 25],
    "tank": [0, 8, 0, 8, 2, 3, 25]
  },
  enemies_easy: {
    "stunner": [0, 6, 2, 2, 1, 0, 25],
    "tank": [0, 6, 2, 2, 1, 0, 25]
  },
  initial_spawn_data: {
    "tank": 4
  },
  initial_spawn_data_easy: {
    "tank": 3,
    "stunner": 1
  },
  //obstacle_v: [[[150, 50], [650, 50], [650, 100], [150, 100]], [[150, 500], [650, 500], [650, 550], [150, 550]], [[50, 150], [100, 150], [100, 450], [50, 450]], [[700, 150], [750, 150], [750, 450], [700, 450]], [[200, 200], [600, 200], [600, 400], [200, 400]]],
  obstacle_v: [[[828,322],[518,8],[554,-32],[823,-32]],[[-28,278],[282,592],[246,632],[-23,632]],[[398,125],[575,300],[399,476],[223,300]],[[107,185],[-25,53],[-25,-34],[325,-34]],[[693,415],[825,547],[825,634],[475,634]]],
  spawn_points: [[400, -100], [400, 700], [-100, 150], [900, 450]],
  multi_spawn_points: [[50, 240], [400, 15], [400, 585], [750, 360]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [4000, 200000, 800000],
    "normal":   [1000000, 500000, 1500000],
  },
  player_loc: {x: 250, y: 150}
}

levels['HIVE 1-7'] = {
  enemies_easy: {
    "stunner": [0, 5, 1, 2, 1, 0, 30],
    "spear": [0, 6, 1.2, 2.4, 1, 0, 15],
    "tank": [0, 10, 2.5, 5, 1, 0, 15]
  },
  enemies: {
    "stunner": [0, 5, 0, 5, 2, 1, 30],
    "spear": [0, 5, 0, 5, 2, 1, 15],
    "tank": [0, 10, 0, 10, 2, 1, 15]
  },
  initial_spawn_data: {
    "stunner": 4,
    "spear":2,
    "tank": 4
  },
  initial_spawn_data_easy: {
    "stunner": 2,
    "spear": 1,
    "tank": 1
  },
  //obstacle_v: [[[75, 75], [362.5, 75], [362.5, 175], [75, 175]], [[437.5, 75], [725, 75], [725, 175], [437.5, 175]], [[75, 250], [362.5, 250], [362.5, 350], [75, 350]], [[437.5, 250], [725, 250], [725, 350], [437.5, 350]], [[75, 425], [362.5, 425], [362.5, 525], [75, 525]], [[437.5, 425], [725, 425], [725, 525], [437.5, 525]]],
  obstacle_v: [[[243,110],[332,144],[243,179],[153,144]],[[310,-3],[400,-38],[489,-3],[400,31]],[[310,300],[400,265],[489,300],[400,334]],[[88,-38],[177,-3],[88,31],[-2,-3]],[[-2,300],[88,265],[177,300],[88,334]],[[-21,125],[25,143],[-21,163]],[[-2,603],[88,569],[177,603],[88,638]],[[802,-3],[712,31],[623,-3],[712,-38]],[[-21,437],[25,457],[-21,475]],[[821,163],[775,143],[821,125]],[[153,456],[243,421],[332,456],[243,490]],[[647,144],[557,179],[468,144],[557,110]],[[712,334],[623,300],[712,265],[802,300]],[[557,490],[468,456],[557,421],[647,456]],[[712,638],[623,603],[712,569],[802,603]],[[400,569],[489,603],[400,638],[310,603]],[[821,475],[775,457],[821,437]]],
  spawn_points: [[-100, 50], [-100, 300], [-100, 550], [900, 50], [900, 300], [900, 550], [240, -100], [560, -100], [240, 700], [560, 700]],
  multi_spawn_points: [[75, 145], [235, 34], [565, 34], [725, 145], [725, 455], [565, 566], [235, 566], [75, 455]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [5000, 150000, 750000],
    "normal":   [1000000, 400000, 1500000],
  },
  player_loc: {x: 400, y: 450}

}

levels['BOSS 1'] = {
  enemies: {
              "boss_one": [0, 1, 0, 1, 0, 0, 1],
           },
 initial_spawn_data: {
  "boss_one": 1
 },
  //obstacle_v: [[[21,25],[375,25],[375,50],[50,50],[50,275],[21,275]],[[779,275],[750,275],[750,50],[425,50],[425,25],[779,25]],[[21,325],[50,325],[50,550],[375,550],[375,576],[21,576]],[[779,576],[425,576],[425,550],[750,550],[750,325],[779,325]]],
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  spawn_points: [[60,62],[60,539],[740,62],[740,539]],
  buffer_radius: 1,
  player_loc: {x: 400, y: 500},
  defeat_time: 40,
}

levels['HIVE 2-0'] = {
  enemies_easy: {
  },
  enemies: {
  },
  initial_spawn_data_easy: {
  },
  initial_spawn_data: {
  },
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  multi_spawn_points: [],
  spawn_points: [],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "normal": [0, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 400, y: 500},
  gateway_loc: {x: 400, y: 350},
}

levels['HIVE 2-1'] = {
  enemies_easy: {
    "stunner": [0, 5, 1.5, 2, 1, 0, 15],
    "tank": [15, 12, 3, 3, 1, 0, 15],
    "mote": [0, 10, 2, 4, 1, 0, 25]
  },
  enemies: {
    "stunner": [1, 4, 0, 4, 1, 1, 15],
    "tank": [0, 8, 0, 8, 1, 1, 15],
    "mote": [5, 7, 0, 7, 2, 1.5, 25]
  },
  initial_spawn_data: {
    "mote": 4,
    "tank": 1
  },
  initial_spawn_data_easy: {
    "mote": 2,
    "stunner": 2
  },
  obstacle_v: [[[-12,-8],[815,-8],[815,609],[748,609],[748,50],[51,50],[51,609],[-12,609]],[[176,609],[176,175],[288,174],[286,286],[228,286],[228,540],[566,540],[566,287],[510,286],[510,175],[626,175],[626,609]],[[324,363],[469,363],[469,466],[324,466]]],
  multi_spawn_points: [[400, 500], [687, 450], [113, 450]],
  spawn_points: [[100, 700], [700, 700]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [5000, 200000, 750000],
    "normal":   [1250000, 450000, 1750000],
  },
  spawn_pattern: "separate_by_type",
  player_loc: {x: 400, y: 235}

}

levels['HIVE 2-2'] = {
  enemies: {
    "stunner": [3, 4, 0, 4, 2, 0, 30],
    "spear": [1, 10, 2, 4, 4, 0, 20],
    "mote": [0, 8, 1, 6, 2, 0, 20]
  },
  enemies_easy: {
    "stunner": [5, 5, 1, 2, 1, 0, 30],
    "spear": [0, 12, 0, 12, 2, 1, 20],
    "mote": [0, 9, 2, 3, 1, 0, 20]
  },
  initial_spawn_data: {
    "mote": 2
  },
  //obstacle_v: [[[75,75],[181,75],[181,175],[75,175]],[[256,75],[362,75],[362,175],[256,175]],[[437,75],[543,75],[543,175],[437,175]],[[618,75],[725,75],[725,175],[618,175]],[[75,250],[181,250],[181,350],[75,350]],[[618,250],[725,250],[725,350],[618,350]],[[75,425],[181,425],[181,525],[75,525]],[[256,425],[362,425],[362,525],[256,525]],[[437,425],[543,425],[543,525],[437,525]],[[618,425],[725,425],[725,525],[618,525]]],
  //obstacle_v: [[[-1,531],[-1,412],[95,472]],[[255,471],[358,412],[358,531]],[[80,600],[175,530],[269,600]],[[270,346],[176,412],[81,346]],[[358,69],[358,188],[255,129]],[[531,600],[625,530],[720,600]],[[269,0],[175,71],[80,0]],[[705,472],[801,412],[801,531]],[[95,129],[-1,188],[-1,69]],[[719,346],[624,412],[530,346]],[[81,254],[176,188],[270,254]],[[442,531],[442,412],[545,471]],[[545,129],[442,188],[442,69]],[[530,254],[624,188],[719,254]],[[801,69],[801,188],[705,129]],[[720,0],[625,71],[531,0]]],
  obstacle_v: [[[-25,253],[143,253],[143,347],[-25,347]],[[825,347],[656,347],[656,253],[825,253]],[[556,347],[454,347],[454,253],[557,253]],[[244,253],[346,253],[346,347],[243,347]],[[-25,-36],[825,-36],[825,148],[758,148],[758,23],[656,23],[658,148],[555,148],[557,23],[454,23],[455,148],[346,148],[346,23],[243,23],[244,148],[143,148],[143,23],[42,23],[42,148],[-25,148]],[[-25,452],[42,452],[42,577],[143,577],[143,452],[244,452],[243,577],[346,577],[346,452],[455,452],[454,577],[557,577],[555,452],[658,452],[656,577],[758,577],[758,452],[825,452],[825,636],[-25,636]]],
  spawn_points: [[-100, 175], [900, 175], [900, 425], [-100, 425]],
  multi_spawn_points: [[95,85],[295, 85], [505, 85], [705, 85], [95, 515], [295, 515], [505, 515], [705,515]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [5000, 200000, 750000],
    "normal":   [1250000, 300000, 1500000],
  },
  player_loc: {x: 400, y: 300}

}

levels['HIVE 2-3'] = {
  enemies_easy: {
    "spear": [0, 6, 2, 2, 2, 0, 30],
    "tank": [0, 8, 1, 5, 3, 0, 30],
    "goo": [0, 10, 0, 10, 1, 0, 1],
  },
  enemies: {
    "spear": [0, 3, 1, 1, 1, 0, 30],
    "tank": [0, 8, 2, 2, 3, 0, 30],
    "goo": [0, 10, 0, 10, 1, 0, 1],
  },
  //obstacle_v: [[[169,549],[630,549],[706,621],[91,622]],[[631,51],[170,51],[94,-21],[709,-22]],[[-24,116],[58,184],[56,416],[-24,483]],[[824,484],[743,416],[744,184],[824,117]]],
  obstacle_v: [[[94,-22],[709,-21],[589,92],[212,92]],[[212,508],[589,508],[709,621],[94,622]],[[-24,117],[104,223],[104,378],[-24,483]],[[824,483],[696,377],[696,222],[824,117]]],
  //obstacle_v: [[[103,1],[688,1],[688,27],[103,27]],[[799,483],[770,483],[770,116],[799,116]],[[103,573],[688,573],[688,599],[103,599]],[[1,116],[30,116],[30,483],[1,483]]],
  spawn_points: [[-100, -100], [900, -100], [900, 700], [-100, 700]],
  multi_spawn_points: [[66, 528], [66, 72], [734, 528], [66, 528]],
  buffer_radius: 1,
   initial_spawn_data: {
    "tank": 4,
    "spear": 8,
    "goo": 1
 },
 initial_spawn_data_easy: {
    "tank": 6,
    "spear": 4,
    "goo": 1
 },
 spawn_pattern: "separate_by_type",
  cutoff_scores: {
    "easy":  [10000, 300000, 1000000],
    "normal":  [1000000, 600000, 2000000],
  },
  player_loc: {x:400, y:300}

}

levels['HIVE 2-4'] = {
  enemies: {
    "stunner": [6, 6, 0, 6, 2, 2, 10],
    "spear": [0, 2, 0.3, 1, 2, 0, 20],
    "mote": [0, 8, 2, 2, 2, 0, 15],
    "goo": [0, 10, 0, 10, 1, 0, 1],
  },
  enemies_easy: {
    "stunner": [8, 8, 0, 8, 2, 1, 10],
    "spear": [0, 12, 3, 2, 2, 0, 20],
    "mote": [0, 8, 1.5, 2, 1, 0, 15],
    "goo": [0, 10, 0, 10, 1, 0, 1],
  },
  initial_spawn_data: {
    "spear": 3,
    "goo": 1,
    "mote": 2,
    "stunner": 2
 },
 initial_spawn_data_easy: {
    "spear": 2,
    "goo": 1,
    "mote": 1,
    "stunner": 2
 },
  //obstacle_v: [[[126,2],[668,2],[668,19],[126,19]],[[1,116],[19,116],[19,483],[1,483]],[[799,483],[781,483],[781,116],[799,116]],[[126,581],[668,581],[668,598],[126,598]],[[124,350],[235,365],[339,349],[326,412],[339,484],[126,484]],[[676,250],[565,235],[461,251],[474,188],[461,116],[674,116]],[[126,116],[339,116],[326,188],[339,251],[235,235],[124,250]],[[674,484],[461,484],[474,412],[461,349],[565,365],[676,350]]],
  //obstacle_v: [[[126,2],[668,2],[668,19],[126,19]],[[1,116],[19,116],[19,483],[1,483]],[[799,483],[781,483],[781,116],[799,116]],[[126,581],[668,581],[668,598],[126,598]],[[228,395],[293,456],[274,473],[211,413]],[[572,205],[507,144],[526,127],[589,187]],[[211,187],[274,127],[293,144],[228,205]],[[589,413],[526,473],[507,456],[572,395]]],
  //obstacle_v: [[[178,108],[337,108],[337,-10],[810,-10],[810,150],[701,150],[701,18],[463,18],[463,150],[178,150]],[[-10,-10],[-10,361],[193,361],[193,493],[240,493],[240,239],[69,239],[69,18],[240,18],[240,-10]],[[623,493],[463,493],[463,610],[-10,610],[-10,450],[99,450],[99,583],[337,583],[337,450],[623,450]],[[810,610],[810,239],[608,239],[608,108],[560,108],[560,361],[731,361],[731,583],[560,583],[560,610]]],
  obstacle_v:[[[-33,-54],[342,-54],[343,201],[191,384],[-33,536]],[[833,536],[609,384],[457,201],[458,-54],[833,-54]],[[526,478],[725,602],[725,641],[75,641],[75,602],[274,478]]],
  //spawn_points: [[-100, 400], [900, 200], [300, -100], [500, 700]],
  spawn_points: [[400, -100], [-125, 700], [925, 700]],
  multi_spawn_points: [[400, 120], [180, 460], [620, 460]],
  buffer_radius: 1,
    cutoff_scores: {
    "easy":  [7500, 200000, 800000],
    "normal":  [1000000, 500000, 2000000],
  },
  spawn_pattern: "separate_by_type",
  player_loc: {x: 400, y: 330}

}

levels['HIVE 2-5'] = {
  enemies_easy: {
    "stunner": [6, 6, 2, 2, 1, 0, 15],
    "mote": [8, 8, 2, 4, 1, 0, 15],
    "harpoon": [0, 15, 3, 6, 1, 0, 15],
  },
  enemies: {
    "stunner": [1, 6, 0, 6, 2, 1, 15],
    "mote": [1, 8, 1, 4, 1, 0, 15],
    "harpoon": [0, 20, 4, 8, 2, 0, 15],
  },
  initial_spawn_data: {
    "harpoon": 2
  },
  initial_spawn_data_easy: {
    "harpoon": 1
  },
  //obstacle_v: [[[509,-31],[537,-31],[537,260],[509,260]],[[656,408],[629,408],[629,191],[656,191]],[[537,631],[509,631],[509,340],[537,340]],[[415,408],[388,408],[388,191],[415,191]],[[291,260],[263,260],[263,-31],[291,-31]],[[145,191],[172,191],[172,408],[145,408]],[[263,340],[291,340],[291,631],[263,631]],[[825,631],[744,631],[744,-31],[825,-31]],[[-25,-31],[56,-31],[56,631],[-25,631]]],
  obstacle_v: [[[-32,-31],[49,-31],[49,631],[-32,631]],[[832,631],[751,631],[751,-31],[832,-31]],[[656,366],[629,366],[629,236],[656,236]],[[144,235],[171,235],[171,364],[144,364]],[[387,235],[414,235],[414,365],[387,365]],[[265,368],[292,368],[292,498],[265,498]],[[535,232],[508,232],[508,102],[535,102]],[[265,102],[292,102],[292,232],[265,232]],[[535,498],[508,498],[508,368],[535,368]],[[659,102],[628,102],[629,18],[414,18],[414,102],[387,102],[387,18],[172,18],[172,102],[143,102],[145,-34],[659,-33]],[[141,498],[172,498],[171,582],[386,582],[386,498],[414,498],[413,582],[628,582],[628,498],[658,498],[655,634],[141,633]]],
  buffer_radius: 1,
  spawn_points: [[100, -50], [700, -50], [100, 650], [700, 650]],
  multi_spawn_points: [[100, 50], [100, 300], [100, 550],[700, 50], [700, 300],[700, 550]],
  cutoff_scores: {
    "easy":   [7500, 300000, 1000000],
    "normal":   [1000000, 600000, 2000000],
  },

  player_loc: {x:400, y: 425}

}

levels['HIVE 2-6'] = {
  enemies: {
    "spear": [1, 10, 2, 2, 2, 0, 10],
    "tank": [2, 15, 3, 6, 2, 0, 12],
    "goo": [0, 20, 0, 20, 1, 0, 1],
    "harpoon": [0, 20, 3, 8, 2, 0, 12]
  },
  enemies_easy: {
    "spear": [0, 8, 2, 4, 1, 0, 10],
    "tank": [2, 12, 4, 3, 1, 0, 12],
    "goo": [0, 20, 0, 20, 1, 0, 1],
    "harpoon": [0, 15, 4, 6, 1, 0, 12]
  },
  //obstacle_v: [[[246,187],[301,187],[301,248],[246,248]],[[246,353],[301,353],[301,414],[246,414]],[[554,248],[499,248],[499,187],[554,187]],[[554,414],[499,414],[499,353],[554,353]],[[103,1],[688,1],[688,27],[103,27]],[[799,483],[770,483],[770,116],[799,116]],[[103,573],[688,573],[688,599],[103,599]],[[1,116],[30,116],[30,483],[1,483]]],
  //obstacle_v: [[[129,568],[674,568],[674,613],[128,613]],[[126,119],[305,119],[305,164],[174,164],[174,236],[126,236]],[[126,364],[174,364],[174,436],[305,436],[305,481],[126,481]],[[674,236],[626,236],[626,164],[495,164],[495,119],[674,119]],[[674,481],[495,481],[495,436],[626,436],[626,364],[674,364]],[[-14,120],[31,120],[31,481],[-14,481]],[[814,480],[769,480],[769,119],[814,119]],[[128,-13],[674,-13],[674,32],[129,32]],[[471,324],[427,324],[427,365],[373,365],[373,324],[330,324],[330,276],[374,276],[373,237],[427,237],[427,276],[471,276]]],
  obstacle_v: [[[325,276],[374,276],[374,231],[427,231],[427,276],[475,276],[475,324],[426,324],[426,371],[373,371],[373,324],[325,324]],[[832,27],[-31,27],[-31,-18],[832,-18]],[[-32,573],[831,573],[831,618],[-32,618]],[[192,369],[246,369],[246,450],[325,450],[325,502],[192,502]],[[192,98],[325,98],[325,150],[246,150],[246,231],[192,231]],[[-25,98],[111,98],[111,502],[-25,502]],[[825,502],[689,502],[689,98],[825,98]],[[608,231],[554,231],[554,150],[475,150],[475,98],[608,98]],[[608,502],[475,502],[475,450],[554,450],[554,369],[608,369]]],
  spawn_points: [[-100, 50], [900, 50], [-100, 550], [900, 550]],
  multi_spawn_points: [[90, 63], [710, 63], [90, 537], [710, 537]],
  initial_spawn_data: {
    "harpoon": 2,
    "goo": 1
  },
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [7500, 250000, 600000],
    "normal": [1250000, 500000, 1250000],
  },

  player_loc: {x: 400, y: 450}
}

levels['HIVE 2-7'] = {
  enemies_easy: {
    "stunner": [0, 30, 5, 15, 2, 0, 16],
    "spear": [2, 30, 5, 15, 2, 0, 16],
    "tank": [12, 30, 5, 15, 2, 0, 16],
    "mote": [6, 30, 5, 15, 2, 0, 16],
    "goo": [18, 30, 5, 15, 1, 0, 1],
    "harpoon": [20, 30, 5, 15, 2, 0, 16]
  },
  enemies: {
    "stunner": [2, 30, 3, 15, 4, 0, 16],
    "spear": [10, 30, 3, 15, 4, 0, 16],
    "tank": [22, 30, 3, 15, 4, 0, 16],
    "mote": [6, 30, 3, 15, 3, 0, 16],
    "goo": [16, 30, 3, 15, 1, 0, 1],
    "harpoon": [0, 30, 3, 15, 3, 0, 16]
  },
  obstacle_v: [[[830,52],[-29,52],[-29,-27],[830,-27]],[[-30,548],[829,548],[829,627],[-30,627]],[[-30,133],[307,133],[307,186],[54,186],[54,415],[307,415],[307,467],[-30,466]],[[830,466],[493,467],[493,415],[746,415],[746,186],[493,186],[493,133],[830,133]],[[229,275],[571,275],[571,325],[229,325]]],
  spawn_points: [[-100, 100], [900, 100], [-100, 500], [900, 500]],
  multi_spawn_points: [[200, 93], [600, 93], [200, 507], [600, 507]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy":[7500, 300000, 1000000],
    "normal":[1500000, 750000, 2250000],
  },
  initial_spawn_data_easy: {
    "stunner": 2
  },
  initial_spawn_data: {
    "harpoon": 3
  },
  player_loc: {x: 400, y: 400}

}

levels['BOSS 2'] = {
  enemies: {
    "boss_two": [0, 1, 0, 1, 0, 0, 1],
    "stunner": [0, 10, 0, 10, 0, 0, 12],
    "spear": [0, 10, 0, 10, 0, 0, 8],
    "tank": [0, 10, 0, 10, 0, 0, 8],
    "mote": [0, 10, 0, 10, 0, 0, 8],
    "goo": [0, 10, 0, 10, 0, 0, 1],
    "harpoon": [0, 10, 0, 10, 0, 0, 8],
  },
  initial_spawn_data: {
    "boss_two": 1
  },
  //obstacle_v: [[[134,599],[50,599],[0,550],[-1,52],[50,2],[749,2],[800,49],[800,551],[750,599],[666,599],[666,552],[700,550],[750,508],[750,93],[700,49],[100,49],[50,93],[49,508],[100,550],[134,552]],[[237,550],[560,550],[560,599],[237,599]]],
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],

  spawn_points: [[60,62],[60,539],[740,62],[740,539]],
  buffer_radius: 1,
  player_loc: {x: 400, y: 500},
  defeat_time: 60,
}

levels['HIVE 3-0'] = {
  enemies_easy: {
  },
  enemies: {
  },
  initial_spawn_data_easy: {
  },
  initial_spawn_data: {
  },
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  multi_spawn_points: [],
  spawn_points: [],
  buffer_radius: 1,
  max_rating: 50,
  cutoff_scores: {
    "normal": [0, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 400, y: 500},
  gateway_loc: {x: 400, y: 350},
}

levels['HIVE 3-1'] = {
  enemies_easy: {
    "stunner": [7, 12, 2, 6, 2, 0, 20],
    "tank":[8, 12, 3, 3, 1, 0, 10],
    "mote": [6, 12, 2, 4, 1, 0, 15],
    "fighter": [0, 24, 4, 8, 1, 0, 12]
  },
  enemies: {
    "stunner": [0, 10, 1.5, 4, 4, 0, 20],
    "tank":[0, 12, 2.4, 4.8, 1, 0, 10],
    "mote": [0, 12, 2.4, 4.8, 1, 0, 15],
    "fighter": [0, 14, 3, 5, 1, 0, 12]
  },
  //SPIKES: obstacle_v: [[[106,180],[38,-35],[170,-35]],[[203,180],[244,300],[203,420],[162,300]],[[638,300],[597,420],[556,300],[597,180]],[[441,300],[400,420],[359,300],[400,180]],[[9,420],[-32,300],[9,180],[50,300]],[[791,180],[832,300],[791,420],[750,300]],[[365,635],[233,635],[301,420]],[[630,-35],[763,-35],[694,180]],[[694,420],[763,635],[630,635]],[[170,635],[38,635],[106,420]],[[301,180],[233,-35],[365,-35]],[[499,420],[567,635],[435,635]],[[435,-35],[567,-35],[499,180]]],
  //SMALLER SQUARES: obstacle_v: [[[468,318],[382,368],[332,282],[418,232]],[[646,366],[559,416],[509,329],[596,279]],[[154,234],[241,184],[291,271],[204,321]],[[598,543],[512,593],[462,507],[548,457]],[[338,93],[252,143],[202,57],[288,7]],[[243,448],[157,498],[107,412],[193,362]],[[557,152],[643,102],[693,188],[607,238]],[[823,413],[737,463],[687,377],[773,327]],[[563,-37],[477,13],[427,-73]],[[237,637],[323,587],[373,673]],[[-23,187],[63,137],[113,223],[27,273]],[[421,496],[334,546],[284,459],[371,409]],[[741,11],[654,61],[604,-26],[691,-76]],[[59,589],[146,539],[196,626],[109,676]],[[871,236],[784,286],[734,199],[821,149]],[[-71,364],[16,314],[66,401],[-21,451]],[[516,141],[429,191],[379,104],[466,54]],[[776,591],[689,641],[639,554],[726,504]],[[24,9],[111,-41],[161,46],[74,96]],[[18,578],[-69,628],[-32,492]],[[782,22],[869,-28],[832,108]]],
  obstacle_v: [[[304,274],[426,204],[496,326],[374,396]],[[72,212],[193,142],[263,263],[142,333]],[[242,507],[363,437],[433,558],[312,628]],[[558,93],[437,163],[367,42],[488,-28]],[[728,388],[607,458],[537,337],[658,267]],[[326,31],[204,101],[134,-20],[256,-90]],[[474,569],[596,499],[666,620],[544,690]],[[10,444],[131,374],[201,496],[80,566]],[[790,156],[669,226],[599,104],[720,34]],[[-160,150],[-39,80],[31,201],[-90,271]],[[960,450],[839,520],[769,399],[890,329]]],
  //SPIKES: spawn_points: [[0, -30], [200, -30], [400,-30], [600, -30], [800, -30], [0, 630], [200, 630], [400, 630], [600, 630], [800, 630]],
  //SMALLER SQUARES: spawn_points: [[-50, 280], [30, 640], [-50, 75], [200, -75], [375, -75], [770, -70], [850, 325], [850, 525], [600, 650], [425, 630]],
  obstacle_v_easy: [[[314,277],[423,214],[486,323],[377,386]],[[82,215],[190,152],[253,260],[145,323]],[[252,510],[360,447],[423,555],[315,618]],[[548,90],[440,153],[377,45],[485,-18]],[[718,385],[610,448],[547,340],[655,277]],[[316,28],[207,91],[144,-17],[253,-80]],[[484,572],[593,509],[656,617],[547,680]],[[20,447],[128,384],[191,493],[83,556]],[[780,153],[672,216],[609,107],[717,44]],[[-150,153],[-42,90],[21,198],[-87,261]],[[950,447],[842,510],[779,402],[887,339]]],

  spawn_points: [[-100, 360], [-100, -100], [900, 200], [900, 700], [200, 700], [400, 700], [360, -100], [600, -100]],

  multi_spawn_points: [[586, 50], [83, 88], [205, 548], [715, 515], [728, 260], [83, 330]],
  buffer_radius: 0.8,
   cutoff_scores: {
    "easy":[10000, 400000, 1000000],
    "normal":[1500000, 750000, 2250000],
  },
  initial_spawn_data: {
    "fighter": 2,
    "tank": 1,
    "mote": 1,
    "stunner": 4,
  },
  initial_spawn_data_easy: {
    "fighter": 1,
    "stunner": 2
  },

  colored_interface: true,
  player_loc: {x: 250, y: 380}

}

levels['HIVE 3-2'] = {
  enemies: {
    "spear": [0, 8, 0, 8, 2, 1, 20],
    "goo": [1, 15, 0, 15, 1, 0, 1],
    "fighter": [0, 20, 4, 12, 2, 0, 12],
    "harpoon": [0, 16, 3, 7, 1, 0, 12]
  },
  enemies_easy: {
    "spear": [10, 10, 1.5, 3, 1, 0, 20],
    "goo": [0, 15, 0, 15, 1, 0, 1],
    "fighter": [0, 24, 4, 8, 2, 0, 12],
    "harpoon": [0, 20, 3, 9, 1, 0, 12]
  },

  //obstacle_v: [[[0,356],[50,356],[49,485],[116,550],[314,550],[314,599],[0,600]],[[217,127],[586,125],[400,234]],[[583,473],[214,475],[400,366]],[[655,406],[487,298],[654,193]],[[145,194],[313,302],[146,407]],[[0,0],[314,1],[314,50],[116,50],[49,115],[50,244],[0,244]],[[800,600],[486,599],[486,550],[684,550],[751,485],[750,356],[800,356]],[[800,244],[750,244],[751,115],[684,50],[486,50],[486,1],[800,0]]],
  //obstacle_v: [[[0,356],[50,356],[49,485],[116,550],[314,550],[314,599],[0,600]],[[0,0],[314,1],[314,50],[116,50],[49,115],[50,244],[0,244]],[[800,600],[486,599],[486,550],[684,550],[751,485],[750,356],[800,356]],[[800,244],[750,244],[751,115],[684,50],[486,50],[486,1],[800,0]]],
  //EYE obstacle_v: [[[0,0],[314,1],[314,28],[116,50],[49,115],[24,244],[0,244]],[[0,356],[24,356],[49,485],[116,550],[314,573],[314,599],[0,600]],[[800,244],[776,244],[751,115],[684,50],[486,28],[486,1],[800,0]],[[800,600],[486,599],[486,573],[684,550],[751,485],[776,356],[800,356]],[[119,263],[166,159],[314,112],[486,112],[636,158],[681,263],[513,210],[474,170],[328,170],[284,210]],[[681,338],[634,442],[486,489],[314,489],[164,443],[119,338],[287,391],[326,431],[472,431],[516,391]],[[513,301],[469,318],[329,318],[284,301],[329,285],[469,285]]],
  //SPLIT PENTAGONS obstacle_v: [[[135,183],[135,107],[206,84],[217,118],[171,133],[171,183]],[[28,239],[57,260],[28,300],[58,340],[28,361],[-16,300]],[[466,177],[537,200],[537,275],[502,275],[502,226],[455,211]],[[274,360],[231,301],[275,239],[303,260],[274,300],[303,340]],[[304,199],[347,139],[419,162],[408,195],[361,180],[332,220]],[[207,516],[135,492],[135,418],[170,418],[170,466],[218,482]],[[546,550],[501,612],[430,589],[441,555],[487,570],[516,529]],[[683,239],[728,300],[684,361],[655,340],[683,301],[654,260]],[[429,12],[502,-12],[545,49],[517,70],[488,31],[441,46]],[[537,325],[538,399],[466,422],[455,389],[502,374],[502,325]],[[418,438],[348,461],[304,400],[332,380],[361,420],[408,405]],[[737,131],[701,131],[701,81],[653,67],[665,32],[737,55]],[[665,568],[654,534],[701,519],[700,469],[737,469],[737,545]]],
  //obstacle_v: [[[419,254],[365,123],[550,200]],[[446,319],[577,265],[500,450]],[[354,281],[223,335],[300,150]],[[-51,355],[59,400],[38,450],[90,471],[24,631],[-63,580]],[[887,260],[741,200],[762,150],[710,129],[776,-31],[898,-13]],[[202,55],[182,102],[234,123],[158,308],[106,286],[87,333],[-51,275],[-33,-42]],[[598,545],[618,498],[566,477],[642,292],[694,314],[713,267],[875,334],[835,642]],[[435,477],[250,400],[381,346]],[[320,688],[89,659],[155,498],[202,518],[223,466],[408,542],[386,594],[433,613]],[[397,-84],[711,-59],[645,102],[598,82],[577,134],[392,58],[414,6],[367,-13]]],
  obstacle_v: [[[438,472],[393,455],[380,425],[413,411]],[[488,230],[474,198],[505,185],[548,205]],[[572,262],[555,307],[525,320],[512,287]],[[228,338],[245,293],[275,280],[288,313]],[[312,370],[326,402],[295,415],[252,395]],[[470,388],[502,374],[515,405],[495,448]],[[330,212],[298,226],[285,195],[305,152]],[[362,128],[407,145],[420,175],[387,189]],[[739,714],[628,449],[692,422],[665,357],[855,279],[972,480]],[[61,-114],[172,151],[108,178],[135,243],[-55,321],[-172,120]],[[677,-232],[737,-7],[547,72],[520,7],[456,33],[347,-232]],[[123,832],[63,607],[253,528],[280,593],[344,567],[453,832]],[[631,276],[672,187],[581,154],[844,45],[894,167]],[[169,324],[128,413],[219,446],[-44,555],[-94,433]],[[145,-144],[267,-194],[376,69],[288,27],[254,119]],[[655,744],[533,794],[424,531],[512,573],[546,481]],[[359,283],[417,259],[441,317],[384,340]]],
  // HARDER 3-2 with bigger obstacles obstacle_v: [[[444,478],[390,458],[375,422],[414,405]],[[485,235],[468,197],[505,181],[557,205]],[[578,256],[558,310],[522,325],[506,286]],[[222,344],[242,290],[278,275],[294,314]],[[315,365],[332,403],[295,419],[243,395]],[[465,385],[503,368],[519,405],[495,457]],[[335,215],[297,232],[281,195],[305,143]],[[356,122],[410,142],[425,178],[386,195]],[[739,714],[628,449],[692,422],[665,357],[855,279],[972,480]],[[61,-114],[172,151],[108,178],[135,243],[-55,321],[-172,120]],[[677,-232],[737,-7],[547,72],[520,7],[456,33],[347,-232]],[[123,832],[63,607],[253,528],[280,593],[344,567],[453,832]],[[631,276],[672,187],[581,154],[844,45],[894,167]],[[169,324],[128,413],[219,446],[-44,555],[-94,433]],[[145,-144],[267,-194],[376,69],[288,27],[254,119]],[[655,744],[533,794],[424,531],[512,573],[546,481]],[[341,276],[424,241],[459,325],[377,358]]],
  //obstacle_v: [[[739,714],[628,449],[692,422],[665,357],[855,279],[972,480]],[[61,-114],[172,151],[108,178],[135,243],[-55,321],[-172,120]],[[677,-232],[737,-7],[547,72],[520,7],[456,33],[347,-232]],[[123,832],[63,607],[253,528],[280,593],[344,567],[453,832]],[[631,276],[672,187],[581,154],[844,45],[894,167]],[[169,324],[128,413],[219,446],[-44,555],[-94,433]],[[145,-144],[267,-194],[376,69],[288,27],[254,119]],[[655,744],[533,794],[424,531],[512,573],[546,481]],[[383,259],[441,283],[417,341],[360,317]],[[295,415],[351,392],[370,400],[393,455]],[[514,405],[492,350],[499,330],[555,307]],[[505,185],[449,208],[430,200],[407,145]],[[286,195],[308,250],[301,270],[245,293]]],
  obstacle_v_easy: [[[433,467],[395,453],[384,427],[412,416]],[[490,226],[479,199],[505,188],[541,205]],[[567,267],[553,305],[527,316],[516,288]],[[233,333],[247,295],[273,284],[284,312]],[[310,374],[321,401],[295,412],[259,395]],[[474,390],[501,379],[512,405],[495,441]],[[326,210],[299,221],[288,195],[305,159]],[[367,133],[405,147],[416,173],[388,184]],[[739,714],[628,449],[692,422],[665,357],[855,279],[972,480]],[[61,-114],[172,151],[108,178],[135,243],[-55,321],[-172,120]],[[677,-232],[737,-7],[547,72],[520,7],[456,33],[347,-232]],[[123,832],[63,607],[253,528],[280,593],[344,567],[453,832]],[[631,276],[672,187],[581,154],[844,45],[894,167]],[[169,324],[128,413],[219,446],[-44,555],[-94,433]],[[145,-144],[267,-194],[376,69],[288,27],[254,119]],[[655,744],[533,794],[424,531],[512,573],[546,481]],[[359,283],[417,259],[441,317],[384,340]]],
  spawn_points: [[-156,410], [-78, 605], [110, -102], [317, -187], [886, -23], [972, 193], [706, 742], [482, 820]],

  multi_spawn_points: [[190,84],[613,89],[610,521],[186,503]],//[[145, 198], [302, 65], [506, 44], [637, 200], [659, 402], [498, 534], [292, 558], [159, 400]],
  buffer_radius: 1,
     cutoff_scores: {
  "easy":[12500, 300000, 1000000],
  "normal":[1500000, 800000, 2000000],
  },
  initial_spawn_data: {
    "fighter": 2,
    "spear": 2,
    "harpoon": 2
  },
  initial_spawn_data_easy: {
    "fighter": 2,
    "harpoon": 1,
    "goo": 1
  },

  colored_interface: true,
  player_loc: {x: 370, y: 380}

}

levels['HIVE 3-3'] = {
  enemies: {
    "tank": [6, 18, 3, 9, 2, 0, 20],
    "harpoon": [0, 20, 3, 11, 2, 0, 15],
    "mote": [1, 14, 3, 5, 2, 0, 10],
    "disabler": [1, 10, 1, 1, 1, 0, 1]
  },
  enemies_easy: {
    "tank": [6, 12, 3, 3, 1, 0, 20],
    "harpoon": [8, 16, 3, 6, 1, 0, 15],
    "mote": [0, 10, 2, 4, 1, 0, 10],
    "disabler": [0, 5, 0, 5, 1, 0, 1]
  },
  // OLD 3-3 obstacle_v: [[[0,-9],[799,-9],[800,287],[395,92],[0,285]],[[1,505],[395,310],[800,505],[800,616],[1,616]],[[84,335],[344,207],[345,236],[85,365]],[[715,365],[455,236],[456,207],[716,335]]],
  //obstacle_v: [[[-50,-25],[850,-25],[850,300],[775,100],[700,300],[625, 100],[550, 300],[475, 100],[400, 300],[325, 100],[250, 300],[175, 100],[100, 300],[25, 100],[-50, 300]],[[-50, 500],[25,300],[100, 500],[175, 300],[250, 500],[325, 300],[400, 500],[475, 300],[550, 500],[625, 300],[700, 500],[775, 300],[850, 500],[850, 650],[-50, 650]]],
  //obstacle_v: [[[-14,343],[25,439],[175,439],[250,239],[325,439],[475,439],[550,239],[625,439],[775,439],[811,341],[850,629],[-50,629]],[[850,161],[775,161],[700,361],[625,161],[475,161],[400,361],[325,161],[175,161],[100,361],[25,161],[-50,161],[-50,-21],[850,-21]]],
  obstacle_v: [[[-14,363],[25,459],[175,459],[250,259],[325,459],[475,459],[550,259],[625,459],[775,459],[811,361],[850,649],[-50,649]],[[850,141],[775,141],[700,341],[625,141],[475,141],[400,341],[325,141],[175,141],[100,341],[25,141],[-50,141],[-50,-41],[850,-41]]],
  obstacle_v_easy: [[[-14,363],[25,459],[175,459],[250,259],[325,459],[475,459],[550,259],[625,459],[775,459],[811,361],[850,649],[-50,649]],[[850,141],[775,141],[700,341],[625,141],[475,141],[400,341],[325,141],[175,141],[100,341],[25,141],[-50,141],[-50,-41],[850,-41]]],
  //obstacle_v: [[[-50,-50],[850,-50],[850,225],[832,225],[775,75],[719,225],[682,225],[625,75],[568,225],[532,225],[475,75],[419,225],[381,225],[325,75],[268,225],[232,225],[175,75],[119,225],[82,225],[25,75],[-31,225],[-50,225]],[[-50,525],[7,375],[44,375],[100,525],[157,375],[193,375],[250,525],[307,375],[344,375],[400,525],[457,375],[494,375],[550,525],[607,375],[643,375],[700,525],[757,375],[793,375],[850,525],[850,648],[-50,648]]],
  spawn_points: [[-100,166],[900,166]],
  multi_spawn_points: [[100,402],[700,402], [250,196],[550,193]],
  buffer_radius: 1.3,
  cutoff_scores: {
    "easy": [12500, 300000, 900000],
    "normal": [1500000, 600000, 1750000]
  },
  initial_spawn_data: {
    "harpoon": 2,
  },

  initial_spawn_data_easy: {
    "disabler": 1,
    "mote": 2,
  },

  colored_interface: true,
  player_loc: {x: 400, y: 400}
}

levels['HIVE 3-4'] = {
  enemies: {
    "spear": [0, 8, 1, 4, 2, 0, 15],
    "fighter": [0, 20, 4, 8, 2, 0, 10],
    "mote": [0, 14, 2, 8, 1, 0, 20],
    "disabler": [0, 10, 0, 10, 1, 0, 1],
  },
  enemies_easy: {
    "spear": [0, 6, 1, 3, 2, 0, 15],
    "fighter": [0, 20, 3, 6, 2, 0, 10],
    "mote": [0, 10, 0, 10, 2, 1, 20],
    "disabler": [0, 5, 0, 5, 1, 0, 1],
  },
  //ORIGINAL 3-4
  //obstacle_v: [[[1,492],[223,439],[166,600],[0,600]],[[166,124],[503,95],[485,158],[333,199],[344,160],[235,174],[200,303],[225,298],[238,339],[106,371]],[[330,288],[454,253],[472,312],[349,348]],[[0,0],[533,0],[526,21],[97,49],[24,390],[0,399]],[[634,477],[297,506],[315,443],[467,402],[456,441],[565,427],[600,298],[575,302],[562,262],[694,230]],[[799,109],[577,162],[634,0],[800,1]],[[800,600],[267,600],[274,580],[703,552],[776,211],[800,202]]],
  //obstacle_v: [[[320,174],[406,151],[383,237]],[[463,317],[549,294],[526,380]],[[480,426],[394,449],[417,363]],[[337,283],[251,306],[274,220]],[[195,142],[109,164],[132,79]],[[179,32],[264,9],[242,95]],[[621,568],[536,591],[558,505]],[[70,61],[47,148],[-16,84]],[[639,202],[663,116],[726,179]],[[5,552],[28,466],[92,529]],[[743,242],[720,328],[656,266]],[[279,626],[216,563],[302,539]],[[366,556],[428,620],[342,643]],[[434,44],[372,-20],[458,-43]],[[521,-26],[584,37],[498,61]],[[470,168],[532,230],[446,254]],[[188,290],[125,227],[211,204]],[[354,346],[330,432],[268,370]],[[496,489],[473,575],[410,512]],[[304,111],[327,25],[390,88]],[[612,310],[675,373],[589,396]],[[286,479],[200,502],[222,415]],[[57,358],[80,272],[144,334]],[[795,48],[772,134],[708,71]],[[782,344],[805,258],[868,321]],[[18,256],[-5,342],[-68,279]],[[161,398],[137,484],[74,421]],[[730,539],[753,452],[816,516]],[[605,458],[691,436],[668,521]],[[715,-79],[778,-14],[692,9]],[[85,679],[22,614],[108,591]],[[515,122],[602,100],[579,186]],[[832,579],[810,664],[746,602]],[[-32,21],[-10,-64],[54,-2]]],

  //TEMP FOUNDATION OF BELOW obstacle_v: [[[388,265],[412,265],[425,285],[375,285]],[[412,335],[388,335],[375,315],[425,315]],[[162,335],[138,335],[125,315],[175,315]],[[662,335],[638,335],[625,315],[675,315]],[[537,335],[513,335],[500,315],[550,315]],[[287,335],[263,335],[250,315],[300,315]],[[300,285],[250,285],[263,265],[287,265]],[[175,285],[125,285],[138,265],[162,265]],[[550,285],[500,285],[513,265],[537,265]],[[675,285],[625,285],[638,265],[662,265]],[[37,335],[13,335],[0,315],[50,315]],[[787,335],[763,335],[750,315],[800,315]],[[800,285],[750,285],[763,265],[787,265]],[[50,285],[0,285],[13,265],[37,265]]],
  // FFAILED 3-4 IDEA obstacle_v: [[[552,582],[567,571],[586,577],[554,601]],[[672,492],[687,481],[706,487],[674,511]],[[792,402],[807,391],[826,397],[794,421]],[[454,594],[486,570],[487,589],[472,600]],[[574,504],[606,480],[607,499],[592,510]],[[694,414],[726,390],[727,409],[712,420]],[[192,102],[207,91],[226,97],[194,121]],[[72,192],[87,181],[106,187],[74,211]],[[312,12],[327,1],[346,7],[314,31]],[[-26,204],[6,180],[7,199],[-8,210]],[[94,114],[126,90],[127,109],[112,120]],[[214,24],[246,0],[247,19],[232,30]],[[432,297],[447,286],[466,292],[434,316]],[[312,387],[327,376],[346,382],[314,406]],[[192,477],[207,466],[226,472],[194,496]],[[72,567],[87,556],[106,562],[74,586]],[[552,207],[567,196],[586,202],[554,226]],[[672,117],[687,106],[706,112],[674,136]],[[792,27],[807,16],[826,22],[794,46]],[[-26,579],[6,555],[7,574],[-8,585]],[[94,489],[126,465],[127,484],[112,495]],[[214,399],[246,375],[247,394],[232,405]],[[334,309],[366,285],[367,304],[352,315]],[[454,219],[486,195],[487,214],[472,225]],[[574,129],[606,105],[607,124],[592,135]],[[694,39],[726,15],[727,34],[712,45]]],
  obstacle_v: [[[424,337],[540,368],[555,310],[613,326],[582,441],[640,457],[624,515],[509,484],[493,541],[436,526],[467,410],[409,395]],[[420,584],[536,615],[551,558],[609,573],[578,689],[405,642]],[[428,90],[544,121],[559,63],[617,78],[586,194],[644,209],[629,267],[513,236],[498,294],[440,279],[471,163],[413,147]],[[177,333],[292,364],[308,306],[366,322],[335,437],[393,453],[377,510],[262,479],[246,537],[188,522],[219,406],[161,391]],[[173,580],[288,611],[304,553],[362,569],[331,685],[157,638]],[[181,86],[297,117],[312,59],[370,74],[339,190],[397,205],[381,263],[266,232],[250,290],[192,274],[223,159],[166,143]],[[401,-42],[385,16],[270,-15],[254,43],[197,27],[228,-89]],[[648,-38],[633,20],[517,-11],[502,47],[444,31],[475,-84]],[[671,341],[787,372],[802,314],[860,330],[829,445],[887,461],[871,519],[756,488],[740,545],[683,530],[714,414],[656,399]],[[895,-34],[880,24],[764,-7],[749,51],[691,35],[722,-80]],[[154,-46],[138,12],[23,-19],[7,39],[-50,23],[-19,-93]],[[667,588],[783,619],[798,562],[856,577],[825,693],[652,646]],[[-66,82],[50,113],[65,55],[123,70],[92,186],[150,201],[134,259],[19,228],[3,286],[-55,270],[-24,155],[-81,139]],[[-74,576],[41,607],[57,549],[115,565],[84,681],[-90,634]],[[-70,329],[45,360],[61,302],[119,318],[88,433],[146,449],[130,506],[15,475],[-1,533],[-59,518],[-28,402],[-86,387]],[[675,94],[791,125],[806,67],[864,82],[833,198],[891,213],[876,271],[760,240],[745,298],[687,283],[718,167],[660,151]]],
  //obstacle_v: [[[434,346],[538,374],[552,322],[604,336],[576,439],[628,454],[614,506],[511,478],[496,529],[445,516],[473,412],[421,398]],[[430,587],[534,615],[548,563],[600,577],[572,681],[416,639]],[[438,99],[542,127],[556,75],[608,88],[580,192],[632,206],[619,258],[515,230],[501,282],[449,269],[477,165],[425,150]],[[187,342],[291,370],[305,318],[357,332],[329,435],[381,450],[367,501],[264,473],[249,525],[197,512],[225,408],[173,394]],[[183,583],[286,611],[301,558],[353,573],[325,677],[168,635]],[[191,95],[295,123],[309,71],[361,84],[333,188],[385,202],[371,254],[268,226],[253,278],[201,264],[229,161],[178,146]],[[390,-39],[375,13],[272,-14],[258,38],[206,23],[234,-81]],[[637,-35],[623,17],[519,-10],[505,42],[453,27],[481,-76]],[[681,350],[785,378],[799,326],[851,340],[823,443],[875,458],[861,510],[758,482],[743,533],[692,520],[720,416],[668,402]],[[884,-31],[870,21],[766,-6],[752,46],[700,31],[728,-72]],[[143,-43],[128,9],[25,-18],[11,34],[-41,19],[-13,-85]],[[677,591],[781,619],[795,567],[847,581],[819,685],[663,643]],[[-56,91],[48,119],[62,67],[114,80],[86,184],[138,198],[124,250],[21,222],[6,274],[-46,260],[-18,157],[-69,142]],[[-64,579],[39,607],[54,554],[106,569],[78,673],[-79,631]],[[-60,338],[44,366],[58,314],[110,328],[82,431],[134,446],[120,497],[17,469],[2,521],[-50,508],[-22,404],[-74,390]],[[685,103],[789,131],[803,79],[855,92],[827,196],[879,210],[866,262],[762,234],[748,286],[696,273],[724,169],[672,154]]],
  obstacle_v_easy:[[[434,346],[538,374],[552,322],[604,336],[576,439],[628,454],[614,506],[511,478],[496,529],[445,516],[473,412],[421,398]],[[430,587],[534,615],[548,563],[600,577],[572,681],[416,639]],[[438,99],[542,127],[556,75],[608,88],[580,192],[632,206],[619,258],[515,230],[501,282],[449,269],[477,165],[425,150]],[[187,342],[291,370],[305,318],[357,332],[329,435],[381,450],[367,501],[264,473],[249,525],[197,512],[225,408],[173,394]],[[183,583],[286,611],[301,558],[353,573],[325,677],[168,635]],[[191,95],[295,123],[309,71],[361,84],[333,188],[385,202],[371,254],[268,226],[253,278],[201,264],[229,161],[178,146]],[[390,-39],[375,13],[272,-14],[258,38],[206,23],[234,-81]],[[637,-35],[623,17],[519,-10],[505,42],[453,27],[481,-76]],[[681,350],[785,378],[799,326],[851,340],[823,443],[875,458],[861,510],[758,482],[743,533],[692,520],[720,416],[668,402]],[[884,-31],[870,21],[766,-6],[752,46],[700,31],[728,-72]],[[143,-43],[128,9],[25,-18],[11,34],[-41,19],[-13,-85]],[[677,591],[781,619],[795,567],[847,581],[819,685],[663,643]],[[-56,91],[48,119],[62,67],[114,80],[86,184],[138,198],[124,250],[21,222],[6,274],[-46,260],[-18,157],[-69,142]],[[-64,579],[39,607],[54,554],[106,569],[78,673],[-79,631]],[[-60,338],[44,366],[58,314],[110,328],[82,431],[134,446],[120,497],[17,469],[2,521],[-50,508],[-22,404],[-74,390]],[[685,103],[789,131],[803,79],[855,92],[827,196],[879,210],[866,262],[762,234],[748,286],[696,273],[724,169],[672,154]]],
  spawn_points: [[-692,162],[958,574],[-114,43],[958,327],[-139,277],[941,70],[-125,530],[105,743],[-125,530],[344,745],[456,-148],[597,738],[203,-140]],
  multi_spawn_points: [[159,48],[646,551],[151,544],[653,58]],
  buffer_radius: 0.8,
  cutoff_scores: {
    "easy": [15000, 600000, 2000000],
    "normal": [1500000, 600000, 2000000],
  },
  player_loc: {x: 400, y: 300},
  initial_spawn_data: {
    "spear": 3,
    "fighter": 2,
    "mote": 2,
    "disabler": 1,
  },
  initial_spawn_data_easy: {
    "fighter": 2,
    "spear": 2,
    "disabler": 1,
  },
}

levels['HIVE 3-6'] = {
  enemies: {
    "spear": [0, 14, 2, 6, 2, 0, 8],
    "tank": [0, 20, 4, 8, 2, 0, 8],
    "harpoon": [0, 18, 3, 6, 1, 0, 8],
    "troll": [0, 13, 2, 6, 2, 0, 10],
  },
  enemies_easy: {
    "spear": [12, 12, 2, 4, 2, 0, 8],
    "tank": [15, 15, 2.5, 4, 1, 0, 8],
    "harpoon": [24, 24, 4, 8, 1, 0, 8],
    "troll": [0, 14, 2, 4, 2, 0, 10],
  },
  //obstacle_v: [[[50,102],[117,102],[117,165],[50,165]],[[750,165],[683,165],[683,102],[750,102]],[[50,436],[117,436],[117,499],[50,499]],[[750,499],[683,499],[683,436],[750,436]],[[606,84],[539,84],[539,20],[606,20]],[[194,517],[261,517],[261,581],[194,581]],[[194,20],[261,20],[261,84],[194,84]],[[606,581],[539,581],[539,517],[606,517]],[[126,267],[194,267],[194,328],[126,328]],[[674,328],[606,328],[606,267],[674,267]],[[539,233],[472,233],[472,170],[539,170]],[[261,368],[328,368],[328,431],[261,431]],[[261,170],[328,170],[328,233],[261,233]],[[539,431],[472,431],[472,368],[539,368]],[[400,202],[506,302],[400,403],[295,305]],[[400,457],[448,500],[401,544],[355,501]],[[355,100],[401,57],[448,101],[400,144]]],
  //obstacle_v: [[[270,341],[400,264],[535,338],[402,418]],[[22,273],[61,199],[132,385],[92,462]],[[600,561],[521,429],[586,384],[656,520]],[[104,115],[193,169],[313,142],[335,207],[178,306]],[[799,152],[709,23],[593,91],[439,69],[401,169],[359,66],[211,95],[91,19],[1,157],[1,0],[800,1]],[[622,306],[465,207],[487,142],[607,169],[696,115]],[[144,520],[214,384],[279,429],[200,561]],[[279,600],[344,473],[401,509],[455,473],[521,599]],[[0,423],[42,532],[120,600],[0,599]],[[800,599],[680,600],[758,532],[800,423]],[[708,462],[668,385],[739,199],[778,273]]],
  obstacle_v: [[[350,123],[400,90],[450,123],[400,156]],[[256,300],[223,350],[190,300],[223,250]],[[400,444],[450,477],[400,510],[350,477]],[[577,250],[610,300],[577,350],[544,300]],[[400,350],[250,450],[350,300],[250,150],[400,250],[550,150],[450,300],[550,450]],[[350,-54],[450,-54],[550,96],[400,-4],[250,96]],[[-4,123],[46,90],[96,123],[46,156]],[[46,444],[96,477],[46,510],[-4,477]],[[754,156],[704,123],[754,90],[804,123]],[[804,477],[754,510],[704,477],[754,444]],[[46,-4],[-41,55],[-4,-54],[96,-54],[196,96]],[[250,504],[400,604],[550,504],[450,654],[350,654]],[[196,150],[96,300],[196,450],[46,350],[-47,412],[-4,300],[-44,190],[46,250]],[[604,450],[704,300],[604,150],[754,250],[847,188],[804,300],[844,410],[754,350]],[[196,504],[96,654],[-4,654],[-41,545],[46,604]],[[604,96],[704,-54],[804,-54],[841,55],[754,-4]],[[754,604],[841,545],[804,654],[704,654],[604,504]]],
  obstacle_v_easy: [[[355,123],[400,93],[445,123],[400,153]],[[253,300],[223,345],[193,300],[223,255]],[[400,447],[445,477],[400,507],[355,477]],[[577,255],[607,300],[577,345],[547,300]],[[400,345],[265,435],[355,300],[265,165],[400,255],[535,165],[445,300],[535,435]],[[355,-47],[445,-47],[535,88],[400,-2],[265,88]],[[1,123],[46,93],[91,123],[46,153]],[[46,447],[91,477],[46,507],[1,477]],[[754,153],[709,123],[754,93],[799,123]],[[799,477],[754,507],[709,477],[754,447]],[[47,-3],[-31,50],[2,-48],[92,-48],[182,87]],[[265,512],[400,602],[535,512],[445,647],[355,647]],[[182,165],[92,300],[182,435],[47,345],[-36,401],[2,300],[-34,201],[47,255]],[[618,435],[708,300],[618,165],[753,255],[836,199],[798,300],[834,399],[753,345]],[[182,513],[92,648],[2,648],[-31,550],[47,603]],[[618,87],[708,-48],[798,-48],[831,50],[753,-3]],[[753,603],[831,550],[798,648],[708,648],[618,513]]],
  spawn_points: [[222,652],[-120,123],[-120,477],[920,123],[920,477],[222,-52],[578,652],[578,-52]],
  multi_spawn_points: [[223,58],[223,543],[577,58],[577,543]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy":  [25000, 400000, 900000],
    "normal":  [1500000, 600000, 1750000],
  },

  player_loc: {x: 400, y: 400},
  initial_spawn_data: {
    "tank": 2,
    "spear": 2,
    "harpoon": 1,
    "troll": 2
  },
  initial_spawn_data_easy: {
    "troll": 2,
    "tank": 1,
    "harpoon": 1
  },
},

levels['HIVE 3-5'] = {
  enemies: {
    "stunner": [0, 12, 2, 6, 2, 0, 15],
    "mote": [0, 20, 2, 14, 1, 0, 15],
    "fighter": [2, 24, 3, 15, 2, 0, 10],
    "troll": [0, 13, 2, 6, 2, 0, 10]
  },
  enemies_easy: {
    "stunner": [5, 10, 0, 10, 1, 1, 15],
    "mote": [0, 15, 2.5, 6, 1, 0, 15],
    "fighter": [10, 20, 3, 8, 1, 0, 10],
    "troll": [0, 15, 2.5, 6, 2, 0, 10]
  },
  multi_spawn_points:[[100, 100]],
  //obstacle_v: [[[40,67],[85,67],[85,228],[40,228]],[[201,18],[252,18],[252,209],[201,209]],[[314,47],[489,47],[489,86],[314,86]],[[137,272],[314,272],[314,317],[137,317]],[[760,228],[715,228],[715,67],[760,67]],[[40,373],[85,373],[85,534],[40,534]],[[760,534],[715,534],[715,373],[760,373]],[[663,317],[486,317],[486,272],[663,272]],[[599,209],[548,209],[548,18],[599,18]],[[201,392],[252,392],[252,583],[201,583]],[[599,583],[548,583],[548,392],[599,392]],[[314,515],[489,515],[489,554],[314,554]],[[380,147],[429,147],[429,450],[380,450]]],
  //obstacle_v: [[[0,1],[224,1],[59,55],[260,102],[59,160],[211,204],[47,259],[167,301],[47,342],[213,395],[59,440],[260,499],[54,543],[224,600],[0,598]],[[371,130],[427,130],[542,167],[430,204],[573,259],[430,301],[573,347],[427,395],[543,432],[430,467],[371,467],[265,433],[371,395],[224,346],[369,301],[227,259],[371,204],[261,167]],[[402,1],[502,30],[403,63],[297,30]],[[297,570],[403,537],[502,570],[402,599]],[[800,598],[576,600],[746,543],[540,499],[741,440],[587,395],[753,342],[633,301],[753,259],[589,204],[741,160],[540,102],[741,55],[576,1],[800,1]]],
  // ROOMS 3-6
  obstacle_v: [[[287,118],[332,136],[351,91],[398,109],[392,122],[281,169],[267,164]],[[209,302],[223,308],[269,420],[264,433],[218,413],[236,368],[191,349]],[[591,298],[577,292],[531,180],[536,167],[582,187],[564,232],[609,251]],[[513,482],[468,464],[449,509],[402,491],[408,478],[519,431],[533,436]],[[531,313],[525,325],[479,305],[498,259],[359,202],[340,248],[294,229],[300,216],[411,170],[486,201]],[[269,287],[275,275],[321,295],[302,341],[441,398],[460,352],[506,371],[500,384],[389,430],[314,399]],[[828,504],[826,846],[-76,645],[-33,148],[136,218],[118,264],[163,284],[145,329],[99,310],[41,449],[178,506],[198,460],[245,479],[226,525],[364,582],[383,536],[430,556],[410,601],[606,520],[560,501],[579,455],[625,475],[645,428]],[[-28,96],[-26,-246],[876,-45],[833,452],[664,382],[682,336],[637,316],[655,271],[701,290],[759,151],[622,94],[602,140],[555,121],[574,75],[436,18],[417,64],[370,44],[390,-1],[194,80],[240,99],[221,145],[175,125],[155,172]]],
  obstacle_v_easy:[[[513,482],[468,464],[449,509],[402,491],[408,478],[519,431],[533,436]],[[591,298],[577,292],[531,180],[536,167],[582,187],[564,232],[609,251]],[[209,302],[223,308],[269,420],[264,433],[218,413],[236,368],[191,349]],[[287,118],[332,136],[351,91],[398,109],[392,122],[281,169],[267,164]],[[269,287],[316,307],[302,341],[441,398],[454,365],[500,384],[389,430],[314,399]],[[531,313],[484,293],[498,259],[359,202],[345,235],[300,216],[411,170],[486,201]],[[-26,81],[-26,-246],[876,-45],[839,439],[669,369],[682,336],[659,327],[678,281],[701,290],[759,151],[622,94],[612,119],[565,99],[574,75],[436,18],[426,42],[380,23],[390,-1],[194,80],[217,88],[198,135],[175,125],[162,159]],[[826,519],[826,846],[-76,645],[-40,160],[132,231],[118,264],[141,273],[122,319],[99,310],[41,449],[178,506],[188,481],[235,501],[226,525],[364,582],[374,558],[420,577],[410,601],[606,520],[583,512],[602,465],[625,475],[638,441]]],
  //obstacle_v: [[[-34,231],[-34,-26],[835,-26],[835,231],[704,231],[704,130],[636,130],[636,212],[526,157],[526,26],[274,26],[274,157],[164,212],[164,130],[96,130],[96,231]],[[164,273],[274,252],[274,348],[164,328]],[[636,328],[526,348],[526,252],[636,273]],[[346,93],[454,93],[454,273],[345,273]],[[96,369],[96,470],[164,470],[164,388],[274,443],[274,574],[526,574],[526,443],[636,388],[636,470],[704,470],[704,369],[835,369],[835,626],[-34,626],[-34,369]],[[345,327],[454,327],[454,507],[346,507]]],
  //obstacle_v: [[[612,300],[566,346],[520,300],[566,254]],[[354,466],[400,420],[446,466],[400,512]],[[446,134],[400,180],[354,135],[400,88]],[[188,300],[234,254],[280,300],[234,346]],[[369,212],[314,267],[250,204],[250,149],[305,149]],[[175,75],[305,75],[354,27],[354,-26],[-30,-26],[-30,254],[127,254],[175,205]],[[175,395],[127,346],[-30,346],[-30,626],[354,626],[354,573],[305,525],[175,525]],[[625,205],[673,254],[830,254],[830,-26],[446,-26],[446,27],[495,75],[625,75]],[[625,525],[495,525],[446,573],[446,626],[830,626],[830,346],[673,346],[625,395]],[[305,451],[250,451],[250,396],[314,333],[369,388]],[[495,149],[550,149],[550,204],[487,267],[432,212]],[[432,388],[487,333],[550,396],[550,451],[495,451]]],
  spawn_points: [[-103,88],[923,515]],
  multi_spawn_points: [[318,106],[482,495],[214,222],[586,379],[202,383],[598,218]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy":   [20000, 400000, 800000],
    "normal":   [1500000, 750000, 1500000],
  },
  initial_spawn_data: {
    "troll": 2,
    "stunner": 2,
    "mote": 1,
  },
  spawn_pattern: "separate_by_type",
  initial_spawn_data_easy: {
    "troll": 2,
  },

  player_loc: {x: 400, y: 300}

}

levels['HIVE 3-7'] = {
  enemies: {
    "stunner": [4, 40, 5, 15, 2, 0, 10],
    "spear": [22, 40, 5, 15, 4, 0, 10],
    "tank": [8, 40, 5, 15, 2, 0, 8],
    "mote": [24, 40, 5, 15, 2, 0, 10],
    "goo": [10, 40, 5, 15, 1, 0, 1],
    "harpoon": [2, 40, 5, 15, 4, 0, 6],
    "fighter": [20, 40, 5, 15, 2, 0, 6],
    "disabler": [28, 40, 5, 15, 1, 0, 2],
    "troll": [0, 40, 5, 15, 4, 0, 10]
  },

  enemies_easy: {
    "stunner": [4, 30, 5, 15, 1, 0, 10],
    "spear": [18, 30, 5, 15, 2, 0, 10],
    "tank": [8, 30, 5, 15, 1, 0, 8],
    "mote": [16, 30, 5, 15, 1, 0, 10],
    "goo": [10, 30, 0, 30, 1, 0, 1],
    "harpoon": [2, 30, 5, 15, 2, 0, 6],
    "fighter": [12, 30, 5, 15, 1, 0, 6],
    "disabler": [20, 30, 0, 30, 1, 0, 1],
    "troll": [0, 30, 5, 15, 2, 0, 10]
  },
  //obstacle_v: [[[221,277],[0,224],[0,0],[800,0],[800,289],[503,220],[489,139],[704,191],[735,83],[589,48],[78,48],[48,161],[213,202]],[[405,137],[284,137],[303,293],[368,307],[395,464],[518,464],[497,308],[432,292]],[[579,324],[800,377],[800,600],[0,600],[0,312],[297,381],[311,462],[96,410],[65,518],[211,552],[722,552],[752,439],[587,399]]],
  //3-RING VERSION OF THIS STAGE..MUCH HARDER obstacle_v: [[[358,133],[347,106],[608,214],[500,475],[488,447],[580,225]],[[444,406],[326,358],[354,346],[433,379],[465,300],[493,289]],[[356,194],[474,242],[446,254],[367,221],[335,300],[307,311]],[[220,375],[442,467],[453,494],[192,386],[300,125],[312,153]],[[283,18],[132,384],[104,396],[272,-9],[677,158],[649,170]],[[517,582],[668,216],[696,204],[528,609],[123,442],[151,430]],[[373,606],[439,691],[-20,688],[-20,-44],[211,-23],[206,-2],[17,459]],[[427,-6],[361,-91],[820,-88],[820,644],[589,623],[594,602],[783,141]]],
  obstacle_v: [[[373,606],[439,691],[-20,688],[-20,-44],[211,-23],[206,-2],[17,459]],[[427,-6],[361,-91],[820,-88],[820,644],[589,623],[594,602],[783,141]],[[309,78],[200,340],[144,363],[285,22],[626,163],[569,187]],[[600,260],[656,237],[515,578],[175,436],[230,413],[492,521]],[[468,364],[448,318],[467,272],[422,254],[402,207],[513,253]],[[332,236],[352,282],[333,328],[378,346],[398,393],[287,347]]],
  spawn_points: [[163,-99],[284,-112],[516,712],[638,699]],
  multi_spawn_points: [[104,420],[696,181],[339,151],[461,450]],
  buffer_radius: 1.5,
  cutoff_scores: {
    "easy":[25000, 500000, 1000000],
    "normal":[2000000, 800000, 2000000],
  },
  initial_spawn_data: {
    "troll": 4,
  },
  colored_interface: true,
  player_loc: {x: 400, y: 300}

}

levels['BOSS 3'] = {
  enemies: {
    "boss_three": [0, 1, 0, 1, 1, 0, 1],
    "stunner": [0, 6, 0, 6, 0, 0, 15],
    "spear": [0, 10, 0, 10, 0, 0, 10],
    "tank": [0, 12, 0, 12, 0, 0, 10],
    "troll": [0, 8, 0, 8, 0, 0, 10],
    "goo": [0, 12, 0, 12, 0, 0, 2],
    "mote": [0, 8, 0, 8, 0, 0, 10],
    "disabler": [0, 10, 0, 10, 0, 0, 2],
    "harpoon": [0, 15, 0, 15, 0, 0, 10],
  },
  //obstacle_v: [[[21,25],[375,25],[375,50],[50,50],[50,275],[21,275]],[[779,275],[750,275],[750,50],[425,50],[425,25],[779,25]],[[21,325],[50,325],[50,550],[375,550],[375,576],[21,576]],[[779,576],[425,576],[425,550],[750,550],[750,325],[779,325]]],
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  //obstacle_v: [[[0,0],[352,0],[352,21],[23,21],[23,254],[0,254]],[[0,346],[23,346],[23,579],[352,579],[352,600],[0,600]],[[800,254],[777,254],[777,21],[448,21],[448,0],[800,0]],[[800,600],[448,600],[448,579],[777,579],[777,346],[800,346]]],
  spawn_points: [[60,62],[60,539],[740,62],[740,539]],
  buffer_radius: 1,
  player_loc: {x: 400, y: 500},
  defeat_time: 60,
  initial_spawn_data: {
    "boss_three": 1
  },
}

levels['HIVE 4-0'] = {
  enemies_easy: {
  },
  enemies: {
  },
  initial_spawn_data_easy: {
  },
  initial_spawn_data: {
  },
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  multi_spawn_points: [],
  spawn_points: [],
  buffer_radius: 1,
  max_rating: 50,
  //cutoff_scores: [100, 500, 1000],
  cutoff_scores: {
    "normal": [0, 300000, 1200000], // scores are irrelevant.
  },
  player_loc: {x: 400, y: 500},
  gateway_loc: {x: 400, y: 350},
}

levels['HIVE 4-1'] = {
  enemies: {
    "spear": [19, 24, 4, 8, 2, 0, 10],
    "troll": [7, 24, 4, 8, 2, 0, 10],
    "tank": [13, 24, 4, 8, 2, 0, 10],
    "harpoon": [1, 24, 4, 8, 2, 0, 10],
    "slingshot": [0, 8, 1, 5, 2, 0, 20]
  },
  enemies_easy: {
    "spear": [6, 28, 0, 28, 2, 1, 10],
    "troll": [13, 28, 0, 28, 2, 1, 10],
    "tank": [20, 28, 0, 28, 2, 1, 10],
    "harpoon": [27, 28, 0, 28, 2, 1, 10],
    "slingshot": [0, 8, 1, 4, 1, 0, 20]
  },
  obstacle_v: [[[-7,472],[61,471],[96,527],[61,581],[-7,581],[-41,526]],[[93,299],[59,354],[-9,354],[-44,300],[-9,244],[59,245]],[[329,74],[363,19],[431,19],[466,73],[431,129],[363,128]],[[621,466],[553,467],[518,411],[553,357],[621,357],[655,412]],[[841,526],[807,581],[739,581],[704,527],[739,471],[807,472]],[[179,135],[247,134],[282,190],[247,244],[179,244],[145,189]],[[145,412],[179,357],[247,357],[282,411],[247,467],[179,466]],[[741,245],[809,244],[844,300],[809,354],[741,354],[707,299]],[[744,20],[812,19],[847,75],[812,129],[744,129],[710,74]],[[330,303],[364,248],[432,248],[467,302],[432,358],[364,357]],[[363,473],[431,472],[466,528],[431,582],[363,582],[329,527]],[[655,189],[621,244],[553,244],[518,190],[553,134],[621,135]],[[90,74],[56,129],[-12,129],[-47,75],[-12,19],[56,20]]] ,
  buffer_radius: 0.5,
  cutoff_scores: {
    "easy": [25000, 600000, 1500000],
    "normal": [2000000, 1250000, 3000000],
  },
  initial_spawn_data: {
    "slingshot": 2
  },
  initial_spawn_data_easy: {
    "slingshot": 1
  },
  player_loc: {x: 400, y: 415},
  multi_spawn_points: [[210,75],[590,75],[210,525],[590,525]],
  spawn_points: [[-75,180],[-75,420],[215,650],[585,650],[215,-50],[585,-50],[875,180],[875,420]],
  colored_interface: true
}

levels['HIVE 4-2'] = {
  enemies_easy: {
    "stunner": [8, 8, 1.2, 2.4, 1, 0, 15],
    "mote": [7, 14, 2, 4, 1, 0, 10],
    "fighter": [0, 25, 4, 9, 1, 0, 8],
    "slingshot": [0, 18, 3, 6, 2, 0, 15],
    "goo": [1, 15, 0, 15, 1, 0, 1]
  },
  enemies: {
    "stunner": [0, 6, 0, 6, 2, 1, 15],
    "mote": [0, 8, 1.5, 3, 1, 0, 10],
    "fighter": [0, 15, 3, 6, 1, 0, 8],
    "slingshot": [0, 6, 1, 3, 1, 0, 15],
    "goo": [1, 15, 0, 15, 1, 0, 1]
  },
  //multi_spawn_points:[[100, 100], [700, 100], [700, 500], [100, 500]],
  //OLD 4-2 obstacle_v: [[[117,243],[117,148],[159,103],[335,102],[335,127],[176,127],[145,162],[145,243]],[[145,357],[145,438],[176,473],[335,473],[335,498],[159,497],[117,452],[117,357]],[[655,243],[655,162],[624,127],[465,127],[465,102],[641,103],[683,148],[683,243]],[[683,357],[683,452],[641,497],[465,498],[465,473],[624,473],[655,438],[655,357]],[[234,198],[335,198],[335,243],[234,243]],[[234,357],[335,357],[335,402],[234,402]],[[566,243],[465,243],[465,198],[566,198]],[[566,402],[465,402],[465,357],[566,357]],[[0,243],[0,0],[800,1],[800,243],[767,243],[767,110],[690,31],[110,31],[33,110],[34,243]],[[34,357],[33,490],[110,569],[690,569],[767,490],[767,357],[800,357],[800,599],[0,600],[0,357]]],
  //spawn_points: [[-100, 300], [900, 300]],
  obstacle_v: [[[282,254],[311,254],[311,280],[338,280],[338,319],[312,319],[312,347],[282,347]],[[354,418],[354,389],[380,389],[380,362],[419,362],[419,388],[447,388],[447,418]],[[447,182],[447,212],[419,212],[419,238],[380,238],[380,211],[354,211],[354,182]],[[820,619],[605,619],[605,542],[642,542],[642,505],[820,505]],[[282,619],[282,542],[354,542],[354,505],[447,505],[446,542],[518,542],[518,619]],[[820,418],[642,418],[642,346],[605,346],[605,253],[642,254],[642,182],[820,182]],[[-20,505],[158,505],[158,542],[195,542],[195,619],[-20,619]],[[-20,-19],[195,-19],[195,58],[158,58],[158,95],[-20,95]],[[820,95],[642,95],[642,58],[605,58],[605,-19],[820,-19]],[[518,347],[488,347],[488,319],[462,319],[462,280],[489,280],[489,254],[518,254]],[[-20,182],[158,182],[158,254],[195,253],[195,346],[158,346],[158,418],[-20,418]],[[518,-19],[518,58],[446,58],[447,95],[354,95],[354,58],[282,58],[282,-19]]],
  obstacle_v_easy: [[[345,447],[345,412],[376,412],[376,379],[423,379],[423,411],[456,411],[456,447]],[[-94,536],[120,536],[120,580],[164,580],[164,673],[-94,673]],[[547,356],[511,356],[511,323],[479,323],[479,276],[512,276],[512,245],[547,245]],[[456,153],[456,189],[423,189],[423,221],[376,221],[376,188],[345,188],[345,153]],[[253,245],[288,245],[288,276],[321,276],[321,323],[289,323],[289,356],[253,356]],[[-94,-73],[164,-73],[164,20],[120,20],[120,64],[-94,64]],[[894,673],[636,673],[636,580],[680,580],[680,536],[894,536]],[[894,64],[680,64],[680,20],[636,20],[636,-73],[894,-73]],[[904,447],[680,447],[680,355],[636,355],[636,244],[680,245],[680,153],[904,153]],[[-104,153],[120,153],[120,245],[164,245],[164,356],[120,355],[120,447],[-104,447]],[[253,673],[253,580],[345,580],[344,536],[455,536],[455,580],[547,580],[547,673]],[[547,-73],[547,20],[455,20],[455,64],[344,64],[345,20],[253,20],[253,-73]]],
  spawn_points: [[-100, 450], [-100, 150], [900, 450], [900, 150], [240, -100], [560, -100], [240, 700], [560, 700]],
  multi_spawn_points: [[114,150],[114,451],[686,150],[686,451],[561,41],[561,560],[239,41],[239,560]],
  multi_spawn_points_easy: [[61,107],[61,493],[739,107],[739,493]],
  buffer_radius: 1,
        cutoff_scores: {

    "normal": [25000, 1500000, 3000000],
  },
  initial_spawn_data: {
    "stunner": 2,
    "mote": 2,
    "slingshot": 2,
    "fighter": 1,
  },

  initial_spawn_data_easy: {
    "slingshot": 2,
    "fighter": 1,
  },
  colored_interface: true,
  player_loc: {x: 400, y: 300}

}

levels['HIVE 4-3'] = {
  enemies_easy: {
    "spear": [20, 20, 4, 8, 1, 0, 10],
    "tank": [17, 20, 4, 8, 1, 0, 15],
    "mote": [14, 20, 4, 8, 1, 0, 10],
    "harpoon": [17, 30, 5, 10, 1, 0, 10],
    "orbiter": [0, 12, 1.5, 6, 1, 0, 15]
  },
  enemies: {
    "spear": [6, 12, 2.4, 4.8, 1, 0, 10],
    "tank": [4, 12, 2.4, 4.8, 1, 0, 15],
    "mote": [4, 12, 2.4, 4.8, 1, 0, 10],
    "harpoon": [1, 18, 3, 6, 1, 0, 10],
    "orbiter": [0, 12, 1.5, 7.5, 2, 0, 15]
  },
  multi_spawn_points: [[159,301],[641,301],[208,94],[208,507],[592,94],[592,507]],
  obstacle_v: [[[309,161],[492,161],[492,249],[456,249],[456,199],[343,199],[343,249],[309,249]],[[309,351],[343,351],[343,401],[456,401],[456,351],[492,351],[492,440],[309,440]],[[230,209],[230,392],[141,392],[141,356],[191,356],[191,243],[141,243],[141,209]],[[571,391],[571,208],[659,208],[659,244],[609,244],[609,357],[659,357],[659,391]],[[191,-49],[609,-49],[609,68],[571,68],[571,31],[230,31],[230,68],[191,68]],[[609,649],[191,649],[191,532],[230,532],[230,569],[571,569],[571,532],[609,532]],[[-40,119],[191,119],[191,158],[37,158],[37,442],[191,442],[191,480],[-40,480]],[[840,481],[609,481],[609,442],[763,442],[763,158],[609,158],[609,120],[840,120]]],
  obstacle_v_easy: [[[191,-49],[609,-49],[609,68],[571,68],[571,31],[230,31],[230,68],[191,68]],[[609,649],[191,649],[191,532],[230,532],[230,569],[571,569],[571,532],[609,532]],[[-40,120],[141,119],[141,158],[37,158],[37,442],[141,442],[141,481],[-40,481]],[[840,480],[659,481],[659,442],[763,442],[763,158],[659,158],[659,119],[840,119]],[[481,269],[447,269],[447,219],[354,219],[354,269],[318,269],[318,180],[481,180]],[[481,420],[318,420],[318,331],[354,331],[354,381],[447,381],[447,331],[481,331]],[[568,381],[568,218],[657,218],[657,254],[607,254],[607,347],[656,347],[657,381]],[[232,219],[232,382],[143,382],[143,346],[193,346],[193,253],[144,253],[143,219]]],
  spawn_points: [[-100,-100],[-100,700],[900,700],[900,-100]],
  buffer_radius: 1.3,
  cutoff_scores: {
    "normal":  [25000, 1200000, 2500000],
  },
  initial_spawn_data: {
    "orbiter": 2,
  },
  initial_spawn_data_easy: {
    "orbiter": 1,
  },
  colored_interface: true,
  player_loc: {x: 400, y: 300}

}

levels['HIVE 4-4'] = {
  enemies_easy: {
    "goo":  [1, 10, 0, 10, 1, 0, 1],
    "troll": [4, 20, 3, 6, 1, 0, 5],
    "fighter": [2, 30, 4, 9, 1, 0, 5],
    "slingshot": [1, 20, 3, 6, 1, 0, 5],
    "orbiter": [0, 12, 2, 6, 1, 0, 10]
  },
  enemies: {
    "goo":  [2, 20, 0, 20, 1, 0, 1],
    "troll": [0, 25, 4, 8, 2, 0, 5],
    "fighter": [12, 24, 4, 8, 1, 0, 5],
    "slingshot": [10, 18, 3, 6, 1, 0, 5],
    "orbiter": [1, 18, 3, 6, 2, 0, 10]
  },
  //obstacle_v: [[[40,67],[85,67],[85,228],[40,228]],[[201,18],[252,18],[252,209],[201,209]],[[314,47],[489,47],[489,86],[314,86]],[[137,272],[314,272],[314,317],[137,317]],[[760,228],[715,228],[715,67],[760,67]],[[40,373],[85,373],[85,534],[40,534]],[[760,534],[715,534],[715,373],[760,373]],[[663,317],[486,317],[486,272],[663,272]],[[599,209],[548,209],[548,18],[599,18]],[[201,392],[252,392],[252,583],[201,583]],[[599,583],[548,583],[548,392],[599,392]],[[314,515],[489,515],[489,554],[314,554]],[[380,147],[429,147],[429,450],[380,450]]],
  //obstacle_v: [[[1,383],[297,600],[1,599]],[[799,599],[503,600],[799,383]],[[1,2],[297,1],[1,218]],[[799,218],[503,1],[799,2]],[[101,255],[348,75],[348,255]],[[348,346],[348,526],[101,346]],[[452,255],[452,75],[699,255]],[[699,346],[452,526],[452,346]]],
  obstacle_v: [[[51,190],[76,190],[76,215],[51,215]],[[126,190],[151,190],[151,215],[126,215]],[[351,190],[376,190],[376,215],[351,215]],[[426,190],[451,190],[451,215],[426,215]],[[676,215],[651,215],[651,190],[676,190]],[[751,215],[726,215],[726,190],[751,190]],[[237,115],[262,115],[262,140],[237,140]],[[488,140],[313,140],[313,115],[488,115]],[[563,140],[538,140],[538,115],[563,115]],[[-27,-30],[830,-30],[830,54],[-27,54]],[[-27,546],[830,546],[830,630],[-27,630]],[[237,460],[262,460],[262,485],[237,485]],[[488,485],[313,485],[313,460],[488,460]],[[563,485],[538,485],[538,460],[563,460]],[[751,410],[726,410],[726,385],[751,385]],[[676,410],[651,410],[651,385],[676,385]],[[426,385],[451,385],[451,410],[426,410]],[[351,385],[376,385],[376,410],[351,410]],[[126,385],[151,385],[151,410],[126,410]],[[51,385],[76,385],[76,410],[51,410]],[[51,460],[188,460],[188,485],[51,485]],[[749,140],[612,140],[612,115],[749,115]],[[749,485],[612,485],[612,460],[749,460]],[[51,115],[188,115],[188,140],[51,140]],[[201,385],[301,385],[301,410],[201,410]],[[599,216],[499,216],[499,190],[599,191]],[[599,410],[499,410],[499,385],[599,385]],[[201,191],[301,190],[301,216],[201,216]]],
  obstacle_v_easy: [[[327,190],[364,190],[364,215],[327,215]],[[439,190],[477,190],[477,215],[439,215]],[[156,115],[193,115],[193,140],[156,140]],[[532,140],[270,140],[270,115],[532,115]],[[645,140],[607,140],[607,115],[645,115]],[[-51,-30],[847,-30],[847,54],[-51,54]],[[156,460],[193,460],[193,485],[156,485]],[[532,485],[270,485],[270,460],[532,460]],[[645,485],[607,485],[607,460],[645,460]],[[439,385],[477,385],[477,410],[439,410]],[[327,385],[364,385],[364,410],[327,410]],[[102,385],[252,385],[252,410],[102,410]],[[699,216],[549,216],[549,190],[699,191]],[[699,410],[549,410],[549,385],[699,385]],[[102,191],[252,190],[252,216],[102,216]],[[-51,546],[847,546],[847,630],[-51,630]]],
  spawn_points: [[-100, 350], [900, 350], [-100, 250], [900, 250]],
  multi_spawn_points: [[99,164],[99,437],[701,164],[701,437],[400,165],[400,436]],
  buffer_radius: 1,
  cutoff_scores: {
    "normal":   [25000, 1000000, 2000000],
  },
  initial_spawn_data: {
    "troll": 2,
  },
  initial_spawn_data_easy: {
    "orbiter": 1,
  },
  colored_interface: true,
  player_loc: {x: 400, y: 300}

}

levels['HIVE 4-6'] = {
  enemies: {
    "tank": [9, 18, 3, 9, 2, 0, 15],
    "mote": [4, 15, 3, 6, 1, 0, 10],
    "harpoon": [1, 20, 3, 11, 2, 0, 10],
    "fighter": [10, 20, 3, 11, 1, 0, 6],
    "disabler": [0, 20, 0, 20, 1, 0, 2],
    "deathray": [30, 30, 4, 18, 1, 0, 3]
  },
  enemies_easy: {
    "tank": [2, 15, 3, 6, 1, 0, 15],
    "mote": [4, 12, 2.5, 4, 1, 0, 15],
    "harpoon": [6, 18, 3, 6, 1, 0, 10],
    "fighter": [8, 24, 4, 8, 1, 0, 6],
    "disabler": [0, 16, 0, 16, 1, 0, 1],
    "deathray": [40, 40, 8, 24, 1, 0, 3]
  },
  //obstacle_v:[[[208,265],[178,265],[178,235],[148,235],[148,205],[118,205],[118,175],[178,175],[178,205],[208,205]],[[525,83],[495,83],[495,113],[435,113],[435,83],[465,83],[465,53],[495,53],[495,23],[525,23]],[[208,83],[178,83],[178,113],[118,113],[118,83],[148,83],[148,53],[178,53],[178,23],[208,23]],[[275,205],[305,205],[305,175],[365,175],[365,205],[335,205],[335,235],[305,235],[305,265],[275,265]],[[-8,54],[22,54],[22,84],[52,84],[52,114],[-8,114]],[[275,335],[305,335],[305,365],[335,365],[335,395],[365,395],[365,425],[305,425],[305,395],[275,395]],[[525,265],[495,265],[495,235],[465,235],[465,205],[435,205],[435,175],[495,175],[495,205],[525,205]],[[525,395],[495,395],[495,425],[435,425],[435,395],[465,395],[465,365],[495,365],[495,335],[525,335]],[[208,395],[178,395],[178,425],[118,425],[118,395],[148,395],[148,365],[178,365],[178,335],[208,335]],[[592,205],[622,205],[622,175],[682,175],[682,205],[652,205],[652,235],[622,235],[622,265],[592,265]],[[592,335],[622,335],[622,365],[652,365],[652,395],[682,395],[682,425],[622,425],[622,395],[592,395]],[[275,23],[305,23],[305,53],[335,53],[335,83],[365,83],[365,113],[305,113],[305,83],[275,83]],[[-9,175],[51,175],[51,205],[21,205],[21,235],[-9,235]],[[592,23],[622,23],[622,53],[652,53],[652,83],[682,83],[682,113],[622,113],[622,83],[592,83]],[[-9,365],[21,365],[21,395],[51,395],[51,425],[-9,425]],[[809,425],[749,425],[749,395],[779,395],[779,365],[809,365]],[[809,235],[779,235],[779,205],[749,205],[749,175],[809,175]],[[808,114],[748,114],[748,84],[778,84],[778,54],[808,54]],[[-8,486],[52,486],[52,516],[22,516],[22,546],[-8,546]],[[208,577],[178,577],[178,547],[148,547],[148,517],[118,517],[118,487],[178,487],[178,517],[208,517]],[[275,517],[305,517],[305,487],[365,487],[365,517],[335,517],[335,547],[305,547],[305,577],[275,577]],[[525,577],[495,577],[495,547],[465,547],[465,517],[435,517],[435,487],[495,487],[495,517],[525,517]],[[592,517],[622,517],[622,487],[682,487],[682,517],[652,517],[652,547],[622,547],[622,577],[592,577]],[[808,546],[778,546],[778,516],[748,516],[748,486],[808,486]]],
  // skinnier version obstacle_v: [[[180,104],[244,104],[244,142],[180,142]],[[430,104],[494,104],[494,142],[430,142]],[[120,459],[120,497],[-50,497],[-50,459]],[[680,142],[680,104],[850,104],[850,142]],[[-50,-50],[850,-50],[850,50],[620,50],[620,400],[556,400],[556,50],[370,50],[370,400],[306,400],[306,50],[120,50],[120,400],[-50,400]],[[370,496],[306,496],[306,458],[370,458]],[[620,496],[556,496],[556,458],[620,458]],[[850,650],[-50,650],[-50,550],[180,550],[180,200],[244,200],[244,550],[430,550],[430,200],[494,200],[494,550],[680,550],[680,200],[850,200]]],
  obstacle_v_easy: [[[187,104],[237,104],[237,142],[187,142]],[[613,497],[563,497],[563,459],[613,459]],[[437,104],[487,104],[487,142],[437,142]],[[313,459],[363,459],[363,497],[313,497]],[[850,650],[-50,650],[-50,550],[187,550],[187,200],[237,200],[237,550],[437,550],[437,200],[487,200],[487,550],[687,550],[687,200],[850,200]],[[113,459],[113,497],[-50,497],[-50,459]],[[687,142],[687,104],[850,104],[850,142]],[[-50,-50],[850,-50],[850,50],[613,50],[613,400],[563,400],[563,50],[363,50],[363,400],[313,400],[313,50],[113,50],[113,400],[-50,400]]],
  obstacle_v: [[[187,104],[237,104],[237,142],[187,142]],[[613,497],[563,497],[563,459],[613,459]],[[437,104],[487,104],[487,142],[437,142]],[[313,459],[363,459],[363,497],[313,497]],[[850,650],[-50,650],[-50,550],[187,550],[187,200],[237,200],[237,550],[437,550],[437,200],[487,200],[487,550],[687,550],[687,200],[850,200]],[[113,459],[113,497],[-50,497],[-50,459]],[[687,142],[687,104],[850,104],[850,142]],[[-50,-50],[850,-50],[850,50],[613,50],[613,400],[563,400],[563,50],[363,50],[363,400],[313,400],[313,50],[113,50],[113,400],[-50,400]]],
  //obstacle_v: [[[-50,393],[-55,-44],[846,-44],[846,38],[652,38],[584,179],[683,394],[608,393],[509,178],[578,37],[382,38],[314,179],[413,393],[338,393],[239,178],[308,37],[112,38],[44,178],[143,393]],[[850,207],[855,644],[-46,644],[-46,562],[150,563],[216,422],[117,206],[192,207],[291,422],[222,563],[420,563],[486,422],[387,207],[462,207],[561,422],[492,563],[690,563],[756,422],[657,207]],[[150,87],[225,88],[192,154],[116,154]],[[420,87],[495,87],[462,154],[387,154]],[[-46,447],[144,447],[112,513],[-46,513]],[[846,153],[656,153],[688,87],[846,87]],[[650,513],[575,512],[608,446],[684,446]],[[380,513],[305,513],[338,446],[413,446]]],
  //obstacle_v_easy:[[[151,93],[215,93],[189,149],[123,149]],[[421,93],[485,93],[459,149],[394,149]],[[846,149],[664,149],[691,92],[846,92]],[[-46,451],[138,451],[109,508],[-46,508]],[[379,507],[315,507],[341,451],[406,451]],[[649,507],[585,507],[611,451],[677,451]],[[-46,562],[155,562],[208,451],[272,451],[217,563],[425,563],[478,451],[542,451],[487,563],[695,563],[761,421],[662,207],[850,207],[855,644],[-46,644]],[[122,207],[187,207],[214,265],[149,265]],[[182,336],[247,336],[274,394],[209,394]],[[392,207],[457,207],[484,265],[419,265]],[[451,335],[516,335],[543,393],[478,393]],[[846,38],[645,38],[592,149],[528,149],[583,37],[375,37],[322,149],[258,149],[313,37],[105,37],[39,179],[138,393],[-50,393],[-55,-44],[846,-44]],[[678,393],[613,393],[586,336],[651,336]],[[349,265],[284,265],[257,208],[322,208]],[[408,393],[343,393],[316,336],[381,336]],[[618,264],[553,264],[526,207],[591,207]]],
  //obstacle_v_easy: [[[-46,447],[139,447],[107,513],[-46,513]],[[846,153],[661,153],[693,87],[846,87]],[[850,207],[855,644],[-46,644],[-46,562],[155,563],[221,422],[123,207],[186,207],[286,422],[217,563],[425,563],[491,422],[392,207],[457,207],[556,422],[487,563],[695,563],[761,422],[662,207]],[[-50,393],[-55,-44],[846,-44],[846,38],[645,37],[579,178],[677,393],[614,393],[514,178],[583,37],[375,37],[309,178],[408,393],[343,393],[244,178],[313,37],[105,37],[39,178],[138,393]],[[377,513],[313,512],[343,446],[408,447]],[[423,87],[487,88],[457,154],[392,153]],[[613,448],[679,448],[647,512],[583,512]],[[187,152],[121,152],[153,88],[217,88]]],
  //spawn_points: [[-92,138],[-89,298],[-92,462],[892,138],[892,462],[890,298],[83,-85],[83,685],[717,-85],[717,685],[402,-84],[402,684],[238,-85],[238,685],[563,-85],[563,685]],
  spawn_points: [[-50, 430], [850, 80], [-50, 520], [850, 170]],
  multi_spawn_points: [[337,429],[461,171],[461,76],[338,524]],
  buffer_radius: 1,
  cutoff_scores: {
    "easy": [30000, 1000000, 2500000],
    "normal": [2000000, 1000000, 2500000],
  },
  initial_spawn_data: {
    "deathray": 1,
    "disabler": 1
  },
  colored_interface: true,
  player_loc: {x: 400, y: 300}
}

levels['HIVE 4-5'] = {
  enemies_easy: {
    "stunner": [6, 8, 2, 3, 1, 0, 40],
    "spear": [13, 10, 2, 4, 1, 0, 20],
    "troll":[9, 20, 4, 8, 1, 0, 10],
    "slingshot": [11, 20, 4, 8, 1, 0, 10],
    "orbiter": [15, 15, 3, 6, 1, 0, 10],
    "deathray": [30, 30, 5, 10, 1, 1, 3],
    // Usually, the first number should be zero so that if the player kills the enemy fast, another will respawn.
    // With deathrays, they are so strong that we don't do this.
  },
  enemies: {
    "stunner": [2, 8, 1, 5, 2, 0, 40],
    "spear": [1, 10, 2, 4, 1, 1, 20],
    "troll":[9, 16, 2, 10, 1, 1, 10],
    "slingshot": [7, 15, 3, 6, 1, 1, 10],
    "orbiter": [1, 16, 2, 10, 1, 1, 10],
    "deathray": [30, 30, 6, 12, 1, 1, 3],
  },
  multi_spawn_points: [[163,471],[163,130],[637,471],[637,130]] ,
  //OLD 4-5 obstacle_v: [[[-34,231],[-34,-26],[835,-26],[835,231],[704,231],[704,130],[636,130],[636,212],[526,157],[526,26],[274,26],[274,157],[164,212],[164,130],[96,130],[96,231]],[[164,273],[274,252],[274,348],[164,328]],[[636,328],[526,348],[526,252],[636,273]],[[346,93],[454,93],[454,273],[345,273]],[[96,369],[96,470],[164,470],[164,388],[274,443],[274,574],[526,574],[526,443],[636,388],[636,470],[704,470],[704,369],[835,369],[835,626],[-34,626],[-34,369]],[[345,327],[454,327],[454,507],[346,507]]],
  // 4-5 with an extra layer obstacle_v: [[[326,261],[326,339],[284,362],[284,238]],[[516,238],[516,362],[474,339],[474,261]],[[521,180],[484,216],[316,216],[279,180]],[[279,420],[316,384],[484,384],[521,420]],[[234,209],[234,391],[164,427],[164,173]],[[636,173],[636,427],[566,391],[566,209]],[[628,72],[571,130],[229,130],[172,72]],[[172,528],[229,470],[571,470],[628,528]],[[84,129],[84,471],[-20,527],[-20,73]],[[820,73],[820,527],[716,471],[716,129]],[[685,584],[719,616],[81,616],[115,584]],[[115,16],[81,-16],[719,-16],[685,16]]],
  obstacle_v: [[[521,180],[484,216],[316,216],[279,180]],[[279,420],[316,384],[484,384],[521,420]],[[234,209],[234,391],[164,427],[164,173]],[[636,173],[636,427],[566,391],[566,209]],[[628,72],[571,130],[229,130],[172,72]],[[172,528],[229,470],[571,470],[628,528]],[[84,129],[84,471],[-20,527],[-20,73]],[[820,73],[820,527],[716,471],[716,129]],[[685,584],[719,616],[81,616],[115,584]],[[115,16],[81,-16],[719,-16],[685,16]]],
  obstacle_v_easy: [[[234,209],[234,391],[164,427],[164,173]],[[636,173],[636,427],[566,391],[566,209]],[[628,72],[571,130],[229,130],[172,72]],[[172,528],[229,470],[571,470],[628,528]],[[84,129],[84,471],[-20,527],[-20,73]],[[820,73],[820,527],[716,471],[716,129]],[[685,584],[719,616],[81,616],[115,584]],[[115,16],[81,-16],[719,-16],[685,16]]],
  spawn_points: [[-100, -100], [900, -100], [900, 700], [-100, 700]],
  buffer_radius: 0.8,
  cutoff_scores: {

    "normal": [30000, 1200000, 2500000],
  },
  initial_spawn_data: {
    "deathray": 1,
  },
  colored_interface: true,
  player_loc: {x: 400, y: 300}
}

levels['HIVE 4-7'] = {
  enemies_easy: {
    "stunner": [1, 30, 6, 12, 2, 0, 6],
    "spear": [5, 30, 6, 12, 2, 0, 6],
    "tank": [3, 30, 5, 10, 1, 0, 5],
    "mote": [10, 30, 5, 10, 2, 0, 6],
    "goo": [8, 20, 0, 20, 1, 0, 1],
    "harpoon": [18, 30, 8, 16, 1, 0, 6],
    "fighter": [12, 30, 8, 16, 1, 0, 4],
    "disabler": [14, 15, 3, 6, 1, 0, 1],
    "troll": [16, 30, 6, 12, 1, 0, 4],
    "slingshot": [28, 30, 8, 16, 1, 0, 4],
    "orbiter": [30, 30, 6, 12, 1, 0, 5],
    "deathray": [2, 35, 9, 18, 1, 0, 3]
  },
  enemies: {
    "stunner": [1, 20, 2, 14, 2, 0, 6],
    "spear": [3, 20, 2, 14, 2, 0, 6],
    "tank": [4, 25, 3, 16, 2, 0, 5],
    "mote": [5, 20, 2, 14, 2, 0, 6],
    "goo": [8, 20, 0, 20, 1, 0, 1],
    "harpoon": [10, 25, 3, 16, 1, 0, 6],
    "fighter": [6, 25, 3, 16, 1, 0, 4],
    "disabler": [9, 15, 0, 15, 1, 0, 1],
    "troll": [8, 25, 3, 16, 1, 0, 4],
    "slingshot": [2, 25, 3, 16, 1, 0, 4],
    "orbiter": [30, 30, 3, 21, 1, 0, 5],
    "deathray": [1, 30, 3, 21, 1, 0, 3]
  },
  //obstacle_v: [[[198,229],[355,295],[200,366],[172,295]],[[180,600],[134,505],[1,458],[0,600]],[[0,0],[1,143],[134,96],[180,1]],[[536,67],[445,37],[445,1],[507,2]],[[620,1],[666,96],[799,143],[800,0]],[[800,600],[799,458],[666,505],[620,600]],[[799,366],[701,406],[742,294],[710,191],[799,232]],[[264,534],[355,563],[355,600],[293,599]],[[293,2],[355,1],[355,37],[264,67]],[[507,599],[445,600],[445,563],[536,534]],[[248,154],[354,120],[355,213]],[[552,447],[446,481],[445,387]],[[445,213],[446,120],[552,154]],[[628,295],[600,366],[445,295],[602,229]],[[355,387],[354,481],[248,447]],[[1,232],[90,191],[58,294],[99,406],[1,366]]],
  //obstacle_v: [[[325,225],[475,225],[475,375],[325,375]],[[175,450],[250,450],[250,525],[175,525]],[[625,150],[550,150],[550,75],[625,75]],[[625,525],[550,525],[550,450],[625,450]],[[175,75],[250,75],[250,150],[175,150]],[[700,225],[663,225],[663,188],[700,188]],[[700,412],[663,412],[663,375],[700,375]],[[100,188],[137,188],[137,225],[100,225]],[[100,1],[137,1],[137,38],[100,38]],[[100,562],[137,562],[137,599],[100,599]],[[700,38],[663,38],[663,1],[700,1]],[[700,599],[663,599],[663,562],[700,562]],[[287,1],[324,1],[324,38],[287,38]],[[287,562],[324,562],[324,599],[287,599]],[[513,599],[476,599],[476,562],[513,562]],[[513,38],[476,38],[476,1],[513,1]],[[100,375],[137,375],[137,412],[100,412]],[[61,246],[79,246],[79,264],[61,264]],[[739,354],[721,354],[721,336],[739,336]],[[61,336],[79,336],[79,354],[61,354]],[[739,264],[721,264],[721,246],[739,246]],[[153,246],[171,246],[171,264],[153,264]],[[153,336],[171,336],[171,354],[153,354]],[[647,264],[629,264],[629,246],[647,246]],[[647,354],[629,354],[629,336],[647,336]],[[61,154],[79,154],[79,172],[61,172]],[[61,428],[79,428],[79,446],[61,446]],[[739,172],[721,172],[721,154],[739,154]],[[739,446],[721,446],[721,428],[739,428]],[[61,520],[79,520],[79,538],[61,538]],[[61,62],[79,62],[79,80],[61,80]],[[739,538],[721,538],[721,520],[739,520]],[[739,80],[721,80],[721,62],[739,62]],[[338,520],[356,520],[356,538],[338,538]],[[338,62],[356,62],[356,80],[338,80]],[[462,538],[444,538],[444,520],[462,520]],[[462,80],[444,80],[444,62],[462,62]],[[-21,-25],[33,-25],[33,626],[-21,626]],[[821,625],[768,625],[768,-26],[821,-26]]],
  obstacle_v: [[[-34,-17],[833,-17],[833,18],[-34,18]],[[-34,58],[335,58],[335,93],[-34,93]],[[834,543],[466,543],[466,508],[834,508]],[[-34,133],[245,133],[245,168],[-34,168]],[[834,468],[555,468],[555,433],[834,433]],[[-34,583],[833,583],[833,618],[-34,618]],[[-34,208],[150,208],[150,243],[-32,243]],[[277,208],[335,208],[335,243],[277,243]],[[277,358],[335,358],[335,393],[277,393]],[[-34,508],[335,508],[335,543],[-34,543]],[[834,93],[466,93],[466,58],[834,58]],[[523,243],[466,243],[466,208],[523,208]],[[523,393],[466,393],[466,358],[523,358]],[[-32,358],[150,358],[150,393],[-34,393]],[[833,243],[651,243],[651,208],[834,208]],[[834,393],[651,393],[651,358],[833,358]],[[-34,433],[245,433],[245,468],[-34,468]],[[834,168],[555,168],[555,133],[834,133]],[[370,433],[430,433],[430,468],[370,468]],[[430,168],[370,168],[370,133],[430,133]],[[185,283],[245,283],[245,318],[185,316]],[[-34,283],[60,283],[60,318],[-34,318]],[[834,318],[740,318],[740,283],[834,283]],[[615,316],[555,318],[555,283],[615,283]],[[430,318],[370,318],[370,283],[430,283]]],
  obstacle_v_easy: [[[-34,-17],[833,-17],[833,18],[-34,18]],[[-34,58],[335,58],[335,93],[-34,93]],[[834,543],[466,543],[466,508],[834,508]],[[-34,133],[245,133],[245,168],[-34,168]],[[834,468],[555,468],[555,433],[834,433]],[[-34,583],[833,583],[833,618],[-34,618]],[[-34,208],[150,208],[150,243],[-32,243]],[[-34,508],[335,508],[335,543],[-34,543]],[[834,93],[466,93],[466,58],[834,58]],[[-32,358],[150,358],[150,393],[-34,393]],[[833,243],[651,243],[651,208],[834,208]],[[834,393],[651,393],[651,358],[833,358]],[[-34,433],[245,433],[245,468],[-34,468]],[[834,168],[555,168],[555,133],[834,133]],[[-34,283],[60,283],[60,318],[-34,318]],[[834,318],[740,318],[740,283],[834,283]],[[430,243],[369,243],[369,208],[430,208]],[[466,283],[527,283],[527,318],[466,318]],[[334,318],[273,318],[273,283],[334,283]],[[430,392],[369,392],[369,357],[430,357]]],
  spawn_points: [[869,37],[869,563],[-69,37],[-69,563],[-69,112],[-69,489],[869,112],[869,489],[869,190],[869,411],[-69,190],[-69,411],[-69,336],[-69,264],[869,336],[869,264]],
  multi_spawn_points: [[307,152],[307,449],[493,152],[493,449],[212,224],[212,377],[588,224],[588,377]],
  buffer_radius: 1,

  cutoff_scores: {
    "easy":  [40000, 600000, 1250000],
    "normal":  [2500000, 1250000, 2500000],
  },
  initial_spawn_data: {
    "orbiter": 2
  },

  colored_interface: true,
  player_loc: {x: 400, y: 370},
  player_loc_easy: {x: 400, y: 300}

}

levels['BOSS 4'] = {
  enemies: {
    "boss_four": [0, 1, 0, 0, 1, 0, 1],
    "stunner": [0, 0, 0, 0, 0, 0, 15],
    "spear": [0, 0, 0, 0, 0, 0, 15],
    "tank": [0, 0, 0, 0, 0, 0, 10],
    "mote": [0, 0, 0, 0, 0, 0, 15],
    "goo": [0, 0, 0, 0, 0, 0, 2],
    "disabler": [0, 0, 0, 0, 0, 0, 1],
    "troll": [0, 0, 0, 0, 0, 0, 12],
    "orbiter": [0, 0, 0, 0, 0, 0, 10],
    "fighter": [0, 0, 0, 0, 0, 0, 8],
    "harpoon": [0, 0, 0, 0, 0, 0, 12],
    "slingshot": [0, 0, 0, 0, 0, 0, 12],
    "deathray": [0, 0, 0, 0, 0, 0, 4],
  },
  //obstacle_v: [[[21,25],[375,25],[375,50],[50,50],[50,275],[21,275]],[[779,275],[750,275],[750,50],[425,50],[425,25],[779,25]],[[21,325],[50,325],[50,550],[375,550],[375,576],[21,576]],[[779,576],[425,576],[425,550],[750,550],[750,325],[779,325]]],
  //obstacle_v: [[[800,300],[773,301],[773,26],[26,26],[26,301],[0,300],[0,0],[800,0]],[[0,301],[26,301],[26,575],[773,575],[773,301],[800,301],[800,600],[0,600]]] ,
  //obstacle_v: [[[0, 0], [375, 0], [375, 50], [50, 50], [50, 275], [0, 275]], [[425, 0], [800, 0], [800, 275], [750, 275], [750, 50], [425, 50]], [[750, 325], [800, 325], [800, 600], [425, 600], [425, 550], [750, 550]], [[0, 325], [50, 325], [50, 550], [375, 550], [375, 600], [0, 600]]],
  obstacle_v: [[[-25,-25],[400,-25],[400,25],[25,25],[25,300],[-25,300]],[[-25,300],[25,300],[25,575],[400,575],[400,625],[-25,625]],[[825,300],[775,300],[775,25],[400,25],[400,-25],[825,-25]],[[825,625],[400,625],[400,575],[775,575],[775,300],[825,300]]],
  spawn_points: [[60,62],[60,539],[740,62],[740,539]],
  buffer_radius: 1,
  player_loc: {x: 400, y: 500},
  defeat_time: 90,
  initial_spawn_data: {
    "boss_four": 1
  },
}

for(i in levels) {
  levels[i].level_name = i;
  if(levels[i].cutoff_scores &&  (typeof levels[i].cutoff_scores["easy"] === "undefined"))
    levels[i].cutoff_scores["easy"] = levels[i].cutoff_scores["normal"].map(function(x){return x/2})

  // provide a get_obstacle_vertices method if none provided
  if(typeof(levels.get_obstacle_vertices) === "undefined") {
    levels[i].get_obstacle_vertices = function (index) {
      var ob_v = this.obstacle_v

      var ans = ob_v[index]
      var ans_array = []
      for(var i = 0; i < ans.length; i++) {
        ans_array.push(new box_2d.b2Vec2(ans[i][0]/constants.drawFactor, ans[i][1]/constants.drawFactor))
      }

      return ans_array
    };
  }
}

var levelData = {};
levelData.levels = levels;

levelData.bossNames = {
  1: "IGNAVIAM",
  2: "CONSUMENDI",
  3: "NEGLIGENTIA",
  4: "ADROGANTIA"
};

levelData.hiveNames = {
  1: "HIVE OF HIDING",
  2: "HIVE OF EATING",
  3: "HIVE OF LAUGHING",
  4: "HIVE OF PURGING"
};

levelData.lastTutorialLevel = 'HIVE 0-3';

module.exports = levelData;

// var other_arena = [[[103,104],[354,104],[354,197],[220,197],[220,263],[103,263]],[[697,263],[580,263],[580,197],[446,197],[446,104],[697,104]],[[103,338],[220,338],[220,404],[354,404],[354,496],[103,496]],[[697,496],[446,496],[446,404],[580,404],[580,338],[697,338]],[[354,263],[446,263],[446,338],[354,338]]]*/

//COOL LEVEL BUT NOT USABLE FOR 3-4 obstacle_v: [[[519,335],[450,316],[436,367],[505,386],[335,431],[386,380],[349,344],[299,395],[344,225],[362,293],[413,280],[394,211]],[[510,644],[492,576],[442,589],[460,658],[335,533],[405,552],[418,502],[349,484],[519,438],[469,489],[506,526],[556,475]],[[73,269],[141,287],[154,236],[86,218],[257,173],[205,223],[242,260],[293,209],[247,379],[228,310],[178,324],[196,393]],[[695,334],[747,284],[710,247],[660,297],[706,127],[724,196],[774,183],[755,113],[880,238],[811,220],[797,271],[867,289]],[[-25,528],[26,477],[-11,440],[-62,491],[-16,320],[3,390],[52,376],[33,307],[158,431],[90,413],[76,464],[147,481]],[[153,740],[47,647],[60,597],[-10,579],[161,533],[111,583],[148,620],[198,570]],[[249,586],[267,655],[318,641],[300,572],[424,697],[204,755]],[[782,600],[714,582],[701,632],[562,660],[608,490],[627,559],[677,545],[659,476]],[[608,283],[589,213],[539,227],[557,296],[432,171],[502,190],[515,140],[445,122],[616,76],[566,126],[603,163],[653,113]],[[695,437],[763,455],[777,405],[709,386],[879,341],[851,479],[800,492],[819,561]],[[80,-39],[99,30],[149,16],[131,-53],[256,72],[186,54],[173,104],[243,121],[72,167],[122,117],[85,80],[35,130]],[[548,-44],[534,7],[603,25],[432,71],[483,20],[447,-16],[396,35],[441,-136]],[[169,-90],[389,-150],[344,21],[325,-48],[274,-35],[293,35]],[[-59,-40],[-22,-3],[28,-53],[-18,117],[-36,48],[-85,60]],[[977,-20],[919,201],[794,77],[862,95],[876,45],[806,27]]] ,

},{"../data/constants.js":13,"../vendor/box2d.js":97}],17:[function(require,module,exports){
var questData = {};

questData["beat_hive"] = {
	text: ["DEFEAT A HIVE"]
}

questData["final_boss"] = {
	text: ["DEFEAT THE FINAL BOSS"]
}

questData["untouchable"] = {
	text: ["BEAT ANY HIVE", "WITHOUT GETTING HIT"]
}

questData["high_roller"] = {
	score_cutoff: 250000,
	text: ["SCORE 250000 PTS OR MORE",
		  "ON A SINGLE ENEMY"]
}

questData["pacifist"] = {
	text: ["BEAT ANY LEVEL", "WITHOUT USING IMPULSE"]
}

questData["blitz_hive1"] = {
	text: ["BEAT HIVE 1 IN HARD MODE", "UNDER 12 MINUTES"],
	time_cutoff: 720
}

questData["blitz_hive2"] = {
	text: ["BEAT HIVE 2 IN HARD MODE", "UNDER 6 MINUTES"],
	time_cutoff: 400
}

questData["blitz_hive3"] = {
	text: ["BEAT HIVE 3 IN HARD MODE", "UNDER 7 MINUTES"],
	time_cutoff: 500
}

questData["blitz_hive4"] = {
	text: ["BEAT HIVE 4 IN HARD MODE", "UNDER 8 MINUTES"],
	time_cutoff: 600
}

questData["beat_hard"] = {
	text: ["DEFEAT ALL HIVES", "IN HARD MODE"]
}

module.exports = questData;

},{}],18:[function(require,module,exports){
var spriteData = {};

spriteData.spriteSheetData = {
  //x, y, w, h
  //"player_normal": [60, 0, 60, 60],
  "player_normal": [0, 0, 40, 40],
  // not sure why this offset is necessary...
  "player_red": [40, -1, 40, 40],
  "player_yellow": [80, 0, 41, 41],
  "player_gray": [120, 0, 41, 41],
  "player_green": [160, 0, 41, 41],
  "player_white": [200, 0, 40, 40],
  "spark": [0, 41, 40, 40],
  "multi": [0, 81, 40, 40],
  "white_glow": [40, 40, 100, 100],
  "white_gateway": [148, 41, 150, 150],
  "lives_icon": [0, 0, 40, 40],
  "sparks_icon": [0, 41, 40, 40],
  "white_flower": [0, 155, 42, 42],
  "blue_flower": [43, 155, 42, 42],
  "world1_starblank": [85, 199, 41, 38],
  "world1_starhalf": [127, 199, 19, 38],
  "world1_star": [127, 199, 41, 38],
  "world2_starblank": [85, 237, 41, 38],
  "world2_starhalf": [127, 237, 19, 38],
  "world2_star": [127, 237, 41, 38],
  "world3_starblank": [0, 199, 41, 38],
  "world3_starhalf": [42, 199, 19, 38],
  "world3_star": [42, 199, 41, 38],
  "world4_starblank": [0, 237, 41, 38],
  "world4_starhalf": [42, 237, 19, 38],
  "world4_star": [42, 237, 41, 38],
  "silver_trophy": [0, 277, 90, 78],
  "gold_trophy": [89, 277, 90, 78],
  "world1_timer": [189, 211, 48, 61],
  "world2_timer": [241, 211, 48, 61],
  "world3_timer": [189, 277, 48, 62],
  "world4_timer": [241, 277, 48, 62],
  "spark_powerup": [310, 6, 37, 36],
  "multi_powerup": [310, 58, 37, 36],
  "ult_powerup": [304, 105, 49, 48],
  "pink_one": [300, 201, 40, 40],
  "dark_one": [301, 240, 40, 41],
  "dark_aura": [300, 299, 100, 101],

  "immunitas_arm": [0, 0, 90, 90],
  "immunitas_arm_red": [150, 135, 90, 90],
  "immunitas_hand": [90, 0, 90, 90],
  "immunitas_hand_red": [240, 135, 90, 90],
  "immunitas_logo_gray": [330, 135, 90, 90],
  "immunitas_head": [0, 90, 108, 108],
  "immunitas_head_red": [450, 123, 108, 108],
  "immunitas_glow": [180, 0, 135, 135],
  "immunitas_red_glow": [315, 0, 135, 135],
  "immunitas_aura": [450, 0, 123, 123],
  "immunitas_aura_red": [573, 0, 123, 123],
  "immunitas_arrow": [0, 200, 70, 70],
  "immunitas_lockon" : [573, 123, 120, 120],

  "consumendi_head": [0, 0, 180, 180],
  "consumendi_head_red": [720, 136, 135, 135],
  "consumendi_aura": [181, 0, 269, 269],
  "consumendi_small_diamond": [94, 180, 30, 56],
  "consumendi_small_diamond_filled": [64, 180, 30, 56],
  "consumendi_small_arrow": [124, 180, 30, 16],
  "consumendi_glow": [720, 0, 135, 135],
  "consumendi_logo": [450, 0, 120, 119],
  "consumendi_mini": [450, 119, 120, 120],
  "consumendi_mini_gray": [570, 0, 120, 120],

  "negligentia_head": [0, 0, 180, 180],
  "negligentia_head_red": [0, 180, 180, 180],
  "negligentia_arm_striking": [180, 0, 244, 100],
  "negligentia_arm_striking_red": [180, 100, 244, 100],
  "negligentia_wheel": [424, 0, 134, 134],
  "negligentia_wheel_red": [424, 270, 134, 134],
  "negligentia_wheel_complete": [423, 135, 135, 135],
  "negligentia_glow": [560, 0, 115, 115],
  "negligentia_glow_red": [560, 115, 115, 115],
  "negligentia_aura": [559, 270, 39, 65],
  "negligentia_aura_open": [598, 270, 39, 65],
  "negligentia_arm_ring": [180, 200, 180, 180],
  "negligentia_logo": [680, 0, 120, 120],
  "negligentia_logo_gray": [680, 120, 120, 120],

  "adrogantia_attack_bud": [0, 0, 80, 80],
  "adrogantia_spawner": [0, 80, 80, 80],
  "adrogantia_body_bud": [80, 0, 80, 80],
  "adrogantia_attack_bud_firing": [80, 80, 80, 80],
  "adrogantia_body_bud_red": [80, 160, 80, 80],
  "adrogantia_head": [181, 1, 160, 160],
  "adrogantia_head_red": [181, 161, 160, 160],
  "adrogantia_glow": [340, 0, 135, 135],
  "adrogantia_logo": [476, 0, 125, 125],
  "adrogantia_logo_gray": [476, 125, 125, 125],
}

spriteData.tessellationGlowMap = {
  "0": "white_glow",
  "1": "immunitas_glow",
  "2": "consumendi_glow",
  "3": "negligentia_glow",
  "4": "adrogantia_glow"
}
spriteData.tessellationLogoMap = {
  "0": "white_gateway",
  "1": "immunitas_arm",
  "2": "consumendi_logo",
  "3": "negligentia_logo",
  "4": "adrogantia_logo"
}
spriteData.tessellationGrayLogoMap = {
  "0": "world_logo",
  "1": "immunitas_logo_gray",
  "2": "consumendi_mini_gray",
  "3": "negligentia_logo_gray",
  "4": "adrogantia_logo_gray"
}

spriteData.bgFiles = {
  "Hive 0": "bg/hive0",
  "Title Alt1": "bg/titlebg_alt1",
  "Title Alt2": "bg/titlebg_alt2",
  "Title Alt3": "bg/titlebg_alt3",
  "Title Alt4": "bg/titlebg_alt4",
  "Hive 1": "bg/hive1",
  "Hive 2": "bg/hive2",
  "Hive 3": "bg/hive3",
  "Hive 4": "bg/hive4",
};

spriteData.tessellationLogoFactor = {
  "0": 1.4,
  "1": 1,
  "2": 1.4,
  "3": 1.4,
  "4": 1.6
};

spriteData.bg_opacity = 0.3;
spriteData.hive0_bg_opacity = 0.6; /* hive0 gets rendered differently, needs to be brighter */
spriteData.menuBgOpacity = 0.1; /* hive0 gets rendered differently, needs to be brighter */

module.exports = spriteData;

},{}],19:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

var Boss = function(world, x, y, id, impulse_game_state) {
  //empty constructor since Enemy should not be constructed
}
Boss.prototype = new Enemy()

Boss.prototype.constructor = Boss
Boss.prototype.init = function(world, x, y, id, impulse_game_state) {

  this.enemy_init(world, x, y, id, impulse_game_state)
  this.spawn_interval = 1000
  this.impulse_extra_factor = 10
  if(this.impulse_game_state.first_time && this.impulse_game_state.level.main_game)
    this.spawn_interval = 6600
  this.require_open = false;
  this.default_dying_length = 5000

  this.spawn_duration = this.spawn_interval
  this.aura_radius = 600;

  this.initial_dark_aura_ratio = 0;
  this.initial_dark_aura_inflection_prop = 0.95;

  if (this.type == "boss_four") {
    this.initial_dark_aura_inflection_prop = 0.9;
  }

  this.spawn_particles = [];
  this.spawn_particle_num = 10;
  this.spawn_particle_timer = 0;
  this.spawn_particle_radius = 30;
  this.spawn_particle_radius_max = 60;
  this.spawn_particle_duration = 1500 * this.spawn_interval / 6600;
  this.spawn_particle_interval = 250 * this.spawn_interval / 6600;
  this.spawn_particle_travel_prop = 0.6;

  if (this.impulse_game_state.first_time && this.impulse_game_state.level.main_game) {
    this.impulse_game_state.shake_level(this.spawn_interval);
  }
}

Boss.prototype.enemy_init = Enemy.prototype.init


Boss.prototype.is_boss = true

Boss.prototype.getLife = function() {
  if(this.dying) {
    return 0
  }
  var dist = Math.min(775/constants.drawFactor - this.body.GetPosition().x, this.body.GetPosition().x - 25/constants.drawFactor)
  var dist2 = Math.min(575/constants.drawFactor - this.body.GetPosition().y, this.body.GetPosition().y - 25/constants.drawFactor)
  return Math.min(dist, dist2)/(275/constants.drawFactor)
}

Boss.prototype.should_show_aura_and_particles = function() {
  return this.impulse_game_state.first_time && this.impulse_game_state.main_game;
}

Boss.prototype.additional_processing = function (dt) {

  if(this.spawn_duration > 0) {
    this.spawn_duration = Math.max(this.spawn_duration - dt, 0)
    var ratio = 1 - this.spawn_duration / this.spawn_interval
    this.visibility = utils.bezierInterpolate(0.15, 0.3, ratio);

    // If this is the first time, show the dark aura and the particles.
    if (this.should_show_aura_and_particles()) {
      if (ratio < this.initial_dark_aura_inflection_prop) {
        this.initial_dark_aura_ratio =
          utils.bezierInterpolate(0.7, 0.85, ratio / this.initial_dark_aura_inflection_prop);
      } else {
        this.initial_dark_aura_ratio = 1 + 2 * (ratio - this.initial_dark_aura_inflection_prop) /
          (1 - this.initial_dark_aura_inflection_prop);
      }

      this.spawn_particle_timer -= dt;
      this.process_spawn_particles(dt);
      if (this.spawn_particle_timer < 0) {
        this.generate_spawn_particles(this.body.GetPosition());
        this.spawn_particle_timer = this.spawn_particle_interval;
      }
    }
    return
  }
  else if(this.spawned == false) {
    this.spawned = true
    this.visibility = 1
  }

  this.boss_specific_additional_processing(dt);
}

Boss.prototype.generate_spawn_particles = function (loc) {
  for (var i = 0; i < this.spawn_particle_num; i++) {
    var r = this.aura_radius / constants.drawFactor * this.initial_dark_aura_ratio * 0.5 + 5;
    var angle = Math.PI * 2 * i / this.spawn_particle_num + (Math.random() - 0.5) * Math.PI * 2 / this.spawn_particle_num
    this.spawn_particles.push({
      start_x: Math.cos(angle) * r + loc.x,
      start_y: Math.sin(angle) * r + loc.y,
      prop: 0
    });
  }
}

Boss.prototype.process_spawn_particles = function (dt) {
  for (var i = 0; i < this.spawn_particles.length; i++) {
    var particle = this.spawn_particles[i];
    particle.prop += dt / this.spawn_particle_duration;
  }
  for (var i = this.spawn_particles.length - 1; i >= 0; i--) {
    var particle = this.spawn_particles[i];
    if (particle.prop > 1) {
      this.spawn_particles.splice(i, 1);
    }
  }
}

Boss.prototype.draw_spawn_particles = function(ctx, draw_factor) {
  var particle_shape = enemyData[this.type].death_polygons[0];
  for(var i = 0; i < this.spawn_particles.length; i++) {
    var particle = this.spawn_particles[i];
    ctx.save()
    if (particle.prop < 0.25) {
      ctx.globalAlpha *= particle.prop * 4
    } else {
      var temp = (1 - particle.prop) / (0.75)
      ctx.globalAlpha *= temp
    }
    if (this.black_hole_timer >= 0) {
      ctx.globalAlpha *= 0.5;
    }
    ctx.globalAlpha *= this.get_dark_aura_opacity();
    var x = (particle.start_x * (1 - particle.prop * this.spawn_particle_travel_prop) +
      this.body.GetPosition().x * particle.prop * (this.spawn_particle_travel_prop));
    var y = (particle.start_y * (1 - particle.prop * this.spawn_particle_travel_prop) +
      this.body.GetPosition().y * particle.prop * (this.spawn_particle_travel_prop));
    var ratio = 1 - this.spawn_duration / this.spawn_interval
    var r = this.spawn_particle_radius * (1 - ratio) + this.spawn_particle_radius_max * ratio;
    renderUtils.drawSprite(ctx, x * draw_factor,
      y * draw_factor,
      0, r * Math.min(particle.prop * 2, 1),
      r * Math.min(particle.prop * 2, 1), "dark_aura");

    ctx.restore()
  }
}

Boss.prototype.boss_specific_additional_processing = function(dt) {

}

Boss.prototype.get_dark_aura_opacity = function () {
  if (this.spawned) return 0;
  var ratio = 1 - this.spawn_duration / this.spawn_interval
  if (ratio > this.initial_dark_aura_inflection_prop) {
    return 1 - (ratio - this.initial_dark_aura_inflection_prop) /
      (1 - this.initial_dark_aura_inflection_prop);
  }
  return 1;
}

Boss.prototype.final_draw = function(context, draw_factor) {
  if (!this.spawned && this.should_show_aura_and_particles()) {
    context.save();
    this.draw_spawn_particles(context, draw_factor);
    // Draw the spawning animation.
    var loc = this.body.GetPosition();
    context.globalAlpha *= this.get_dark_aura_opacity();

    renderUtils.drawSprite(context, loc.x * draw_factor,
      loc.y * draw_factor,
      0, this.aura_radius * this.initial_dark_aura_ratio,
      this.aura_radius * this.initial_dark_aura_ratio, "dark_aura")
    context.restore();
  }

  this.boss_specific_final_draw(context, draw_factor);
}

Boss.prototype.boss_specific_final_draw = function(context, draw_factor) {

}

Boss.prototype.additional_death_prep = function () {
  this.impulse_game_state.level.clear_obstacles();
  this.impulse_game_state.transition_to_hive0bg(5000);
  this.impulse_game_state.shake_level(3000);
  music_player.stop_bg()
  this.additional_death_prep_specific();
}

Boss.prototype.additional_death_prep_specific = function () {}

Boss.prototype.get_impulse_extra_factor = function() {
  return this.impulse_extra_factor;
}

Boss.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  if(this.spawned)  {
    this.body.ApplyImpulse(new box_2d.b2Vec2(this.get_impulse_extra_factor() * impulse_force * Math.cos(hit_angle), this.get_impulse_extra_factor() * impulse_force * Math.sin(hit_angle)),
      this.body.GetWorldCenter())
    this.process_impulse_specific(attack_loc, impulse_force, hit_angle)
  }
}

Boss.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.knockback_red_duration = this.knockback_red_interval
}


Boss.prototype.stun = function(dur) {}

Boss.prototype.silence = function(dur, color_silence)  {}

Boss.prototype.lock = function(dur)  {}

Boss.prototype.goo = function(dur)  {}

Boss.prototype.lighten = function(dur)  {}

Boss.prototype.open = function(dur)  {}

module.exports = Boss;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../render/utils.js":83,"../vendor/box2d.js":97}],20:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var sprites = require('../render/sprites.js');
var utils = require('../core/utils.js');

var Boss = require('../enemy/boss.js');
var BossFourAttacker = require('../enemy/boss_four_attacker.js');
var BossFourSpawner = require('../enemy/boss_four_spawner.js');

BossFour.prototype = new Boss()

BossFour.prototype.constructor = BossFour

function BossFour(world, x, y, id, impulse_game_state) {
  this.type = "boss_four"

  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  this.death_radius = 5

  this.do_yield = false

  this.safe = true

  this.body.SetAngle(Math.PI/2)

  this.visibility = 0

  this.red_visibility = 0

  this.spawn_interval = 1000
  if (this.impulse_game_state.first_time && this.impulse_game_state.main_game) {
    this.spawn_interval = 2300
  }
  this.spawn_duration = this.spawn_interval
  this.spawn_particle_duration = 1500 * this.spawn_interval / 6600;
  this.spawn_particle_interval = 250 * this.spawn_interval / 6600;

  // Need to reset shake_level since the spawn_interval is shorter.
  if (this.impulse_game_state.first_time && this.impulse_game_state.level.main_game) {
    this.impulse_game_state.shake_level(this.spawn_interval);
  }

  this.spawned = false

  this.anger_level = 0;
  this.anger_level_max = 5;
  this.anger_level_cooloff_period = 1000;
  this.anger_level_cooloff_timer = 0;

  this.spawn_laser_angle = Math.PI/2
  this.spawn_laser_colors = ["#000000", "#110000", "#660000", "#990000", "#cc0000", "#ff0000"];
  this.spawn_laser_flare_prop = 0;
  this.spawn_laser_flare_transition_period_base = 250;

  this.spawn_laser_revolution_base = 20000

  if (saveData.difficultyMode == "easy") {
    this.spawn_laser_revolution_base = 30000
  }

  this.spawn_laser_radius_base = 0.2

  this.spawner_spawn_count = {
   "stunner" : 8,
   "spear" : 5,
   "tank" : 6,
   "mote" : 6,
   "goo" : 1,
   "harpoon" : 4,
   "orbiter" : 5,
   "disabler" : 1,
   "fighter" : 3,
   "slingshot" : 4,
   "troll" : 6,
   "deathray" : 2
 }

 this.spawner_spawn_count_easy = {
   "stunner" : 6,
   "spear" : 4,
   "tank" : 4,
   "mote" : 4,
   "goo" : 1,
   "harpoon" : 3,
   "orbiter" : 3,
   "disabler" : 1,
   "fighter" : 2,
   "slingshot" : 2,
   "troll" : 4,
   "deathray" : 1
 }

 this.spawner_spawn_force = {
  "stunner" : 10,
   "spear" : 10,
   "tank" : 75,
   "mote" : 10,
   "goo" : 20,
   "harpoon" : 20,
   "orbiter" : 8,
   "disabler" : 20,
   "fighter" : 30,
   "slingshot" : 10,
   "troll" : 10,
   "deathray" : 50
 }


  this.spawn_order = ["stunner", "spear", "fighter", "orbiter", "troll", "goo", "harpoon", "deathray", "slingshot", "mote", "tank", "disabler", ]
  if (saveData.difficultyMode == "normal") {
    this.spawn_order = ["spear", "mote", "fighter", "orbiter", "troll", "goo", "harpoon", "deathray", "slingshot", "stunner", "tank", "disabler"]
  }

  this.spawn_counter = 0

  this.possible_spawn_sets = [

  ["fighter", "spear"],
  ["goo", "troll"],
  ["tank", "disabler"],
  ["stunner", "deathray"],
  ["mote", "slingshot"],
  ["orbiter", "spear"],
  ["harpoon", "goo"]
 ]

  this.spawner_push_force = 500
  this.spawner_interval = 22000//19000
  this.spawner_timer = 0

  this.last_object_hit = null

  this.laser_check_timer = 2
  this.laser_check_counter = this.laser_check_timer
  this.laser_check_diff = Math.PI/4

  this.laser_target_visible = true
  this.laser_target_visibility = 1

  this.num_buds = 5
  this.buds = []

  this.ready_attack_bud = null;
  this.ready_bud_queue = [];

  this.spawner_bud_frequency = 4;

  if (saveData.difficultyMode == "easy") {
    this.spawner_bud_frequency = 4;
  }

  this.attack_bud_expand_period = 10000

  if (saveData.difficultyMode == "easy") {
    this.attack_bud_expand_period = 12000
  }

  this.attack_bud_charging = false
  this.attack_bud_charge_period = 1250
  this.attack_bud_charge_timer = this.attack_bud_charge_period
  this.attack_bud_cooldown_timer = 0
  this.attack_bud_cooldown_period = 1000
  if (saveData.difficultyMode == "easy") {
    this.attack_bud_cooldown_period = 1500
  }

  this.initial_spawn = false
  this.do_initial_spawn = true
  this.body_bud_radius = enemyData[this.type].body_bud_radius
  this.createBodyBuds()

  this.turn_rate = 4000
  this.spawner_force = 2000

  this.bud_count = 0

  this.tank_force = 100

  if (saveData.difficultyMode) {
    this.tank_force = 70
  }

  this.darkness_interval = 20000
  this.darkness_timer = this.darkness_interval - 1
  // The time it takes for the darkness to spread.
  this.darkness_spreading_duration = 1000
  // How long the darkness stays.
  this.darkness_duration = 1000
  // How long the darkness takes to vanish.
  this.darkness_vanish_duration = 1000

  this.darkness_canvas = document.createElement('canvas');
  this.darkness_canvas_ctx = this.darkness_canvas.getContext('2d');
  this.darkness_canvas.width = 200;
  this.darkness_canvas.height = 200;
  // The angle at which to draw the darkness. When the darkness spreads, it should no longer rotate with the boss.
  this.darkness_angle = 0;

  this.darkness_canvas_ctx.beginPath()

  this.darkness_canvas_ctx.moveTo(100 + 100 * Math.cos(Math.PI * 2 * 4 / 5),
                  100 + 100 * Math.sin(Math.PI * 2 * 4 / 5));
  for (var i = 0; i < 5; i++) {
    this.darkness_canvas_ctx.lineTo(100 + 100 * Math.cos(Math.PI * 2 * i / 5),
                    100 + 100 * Math.sin(Math.PI * 2 * i / 5));
  }
  this.darkness_canvas_ctx.closePath();
  this.darkness_canvas_ctx.fillStyle = "black";
  this.darkness_canvas_ctx.fill()
  this.darkness_sound_played = false
}


BossFour.prototype.draw = function(context, draw_factor) {

  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return

  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
  context.save()
  if (this.dying)
      context.globalAlpha *= (1 - prog)
    else
      context.globalAlpha *= this.visibility != null ? this.visibility : 1

  var tp = this.body.GetPosition()

  //if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle()),
      this.effective_radius * 2 * draw_factor, this.effective_radius * 2 * draw_factor, "adrogantia_head", sprites.adrogantiaSprite)


  if (this.anger_level > 0) {
    context.save();
    context.beginPath();
    var angle = this.body.GetAngle();
    context.moveTo(tp.x*draw_factor + this.effective_radius * draw_factor * Math.cos(angle),
      tp.y*draw_factor + this.effective_radius * draw_factor * Math.sin(angle))
    for (var i = 1; i <= this.anger_level; i++) {
      context.lineTo(tp.x*draw_factor + this.effective_radius * draw_factor * Math.cos(angle + i * Math.PI * 2 / 5),
      tp.y*draw_factor + this.effective_radius * draw_factor * Math.sin(angle + i * Math.PI * 2 / 5))
    }
    if (this.anger_level < 5) {
      context.lineTo(tp.x*draw_factor, tp.y*draw_factor);
    }
    context.closePath();
    context.clip();
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle()),
      this.effective_radius * 2 * draw_factor, this.effective_radius * 2 * draw_factor, "adrogantia_head_red", sprites.adrogantiaSprite)
    context.restore();
  }
  //} else {
  //  renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/16), this.effective_radius * 2 * draw_factor, this.effective_radius * 2 * draw_factor, "negligentia_head", sprites.negligentiaSprite)
  //}
  this.additional_drawing(context, draw_factor)

  context.restore()
}

BossFour.prototype.boss_specific_final_draw = function(context, draw_factor) {
  context.save();
  context.globalAlpha = 1;
  this.draw_blindness_overlay(context, draw_factor);
  context.restore();
}

BossFour.prototype.draw_blindness_overlay = function(context, draw_factor) {
  var tp = this.body.GetPosition()
  if (this.darkness_timer > 0) {
    // Draw blindness indicator.
    var prog = 1 - (this.darkness_timer / this.darkness_interval);
    var r = this.effective_radius * prog * draw_factor;
    this.darkness_angle = this.body.GetAngle();
    context.save();
    context.globalAlpha *= 0.5
    context.translate(tp.x * draw_factor, tp.y * draw_factor);
    context.rotate(this.darkness_angle)
    context.drawImage(this.darkness_canvas, 0, 0, this.darkness_canvas.width, this.darkness_canvas.height, -r, -r, 2 * r, 2 * r);
    context.restore();
  } else if (this.darkness_timer > -this.darkness_spreading_duration) {
    if (!this.darkness_sound_played) {
      this.darkness_sound_played = true
      music_player.play_sound("b4darkness")
    }
    var prog = (this.darkness_timer / -this.darkness_spreading_duration);
    var r = (this.effective_radius * (1 - prog) + 60 * prog) * draw_factor;
    context.save();
    context.globalAlpha *= 0.5
    context.translate(tp.x * draw_factor, tp.y * draw_factor);
    context.rotate(this.darkness_angle)
    context.drawImage(this.darkness_canvas, 0, 0, this.darkness_canvas.width, this.darkness_canvas.height, -r, -r, 2 * r, 2 * r);
    context.restore();
  } else if (this.darkness_timer > -(this.darkness_spreading_duration + this.darkness_duration)) {
    var r = 60 * draw_factor;
    context.save();
    context.globalAlpha *= 0.5;
    context.translate(tp.x * draw_factor, tp.y * draw_factor);
    context.rotate(this.darkness_angle)
    context.drawImage(this.darkness_canvas, 0, 0, this.darkness_canvas.width, this.darkness_canvas.height, -r, -r, 2 * r, 2 * r);
    context.restore();
  } else if (this.darkness_timer > -(this.darkness_spreading_duration + this.darkness_duration + this.darkness_vanish_duration)) {
    var prog = 1 - (this.darkness_timer + this.darkness_spreading_duration + this.darkness_duration) / -this.darkness_vanish_duration;
    var r = 60 * draw_factor;
    context.save();
    context.globalAlpha *= 0.5 * prog;
    context.translate(tp.x * draw_factor, tp.y * draw_factor);
    context.rotate(this.darkness_angle)
    context.drawImage(this.darkness_canvas, 0, 0, this.darkness_canvas.width, this.darkness_canvas.height, -r, -r, 2 * r, 2 * r);
    context.restore();
  }
}


BossFour.prototype.get_next_enemy_type = function() {
  this.spawn_counter += 1
  return this.spawn_order[(this.spawn_counter - 1) % this.spawn_order.length]
}
BossFour.prototype.additional_drawing = function(context, draw_factor) {

  this.process_body_buds()
  this.draw_body_buds(context, draw_factor)
}

BossFour.prototype.boss_specific_additional_processing = function(dt) {
  if (this.attack_bud_cooldown_timer > 0) {
    this.attack_bud_cooldown_timer -= dt;
  }

  if (this.anger_level > 0) {
    this.anger_level_cooloff_timer -= dt;
    if (this.anger_level_cooloff_timer < 0) {
      this.anger_level_cooloff_timer = this.anger_level_cooloff_period
      this.anger_level -= 1;
    }
  }

  if (this.cur_object != null && this.cur_object.type === "boss_four_spawner"  && !this.cur_object.is_silenced()) {
    this.spawn_laser_flare_prop += dt/this.get_spawn_laser_flare_transition_period();
    if (this.spawn_laser_flare_prop > 1) {
      this.spawn_laser_flare_prop = 1;
    }
    this.spawn_laser_flare_transition_period = 250;
  } else if (this.spawn_laser_flare_prop > 0) {
    this.spawn_laser_flare_prop -= dt/this.spawn_laser_flare_transition_period_base;
    if (this.spawn_laser_flare_prop < 0) {
      this.spawn_laser_flare_prop = 0;
    }
  }

  if(this.do_initial_spawn) {
    this.create_initial_attack_buds()
    this.do_initial_spawn = false
  }
  this.process_attack_buds(dt)

  this.repel_enemies()

  if (this.darkness_timer < 0 && this.darkness_timer > -this.darkness_spreading_duration) {
    var prog = (this.darkness_timer / -this.darkness_spreading_duration);
    this.level.enemy_visibility = 1 - prog;
  } else if (this.darkness_timer < -(this.darkness_spreading_duration + this.darkness_duration) && this.darkness_timer > -(this.darkness_spreading_duration + this.darkness_duration + this.darkness_vanish_duration)) {
    var prog = (this.darkness_timer + this.darkness_spreading_duration + this.darkness_duration) / -this.darkness_vanish_duration;
    this.level.enemy_visibility = prog;
  } else if (this.darkness_timer >= 0) {
    this.level.enemy_visibility = 1;
  }

  if(this.ready_attack_bud) {

    if(this.attack_bud_charging) {
      this.attack_bud_charge_timer -= dt
      if(this.attack_bud_charge_timer < 0) {
        this.fire_attack_bud(this.ready_attack_bud)
      }

    } else {

      var cur_angle = this.body.GetAngle();
      if(this.ready_attack_bud.type == "attack") {

        var target_angle =  utils.angleClosestTo(cur_angle,utils.atan(this.body.GetPosition(), this.player.get_current_position()) - this.attack_bud_angle);

      } else if(this.ready_attack_bud.type == "spawn") {

        if(this.initial_spawn) {
          var target_angle = utils.angleClosestTo(cur_angle, Math.PI/2)
        } else {
          if(this.target_spawn_angle == null) {
            this.generate_target_spawn_angle()
          }
          var target_angle =  utils.angleClosestTo(cur_angle, this.target_spawn_angle - this.attack_bud_angle);
        }
      }
      var angle_between = utils.smallAngleBetween(cur_angle, target_angle)

      var turn_rate = this.turn_rate;

      if(angle_between < Math.PI * 2 * dt/turn_rate) {
        this.body.SetAngle(target_angle)
        this.attack_bud_charging = true

        if(this.initial_spawn) {
          this.attack_bud_charge_timer = 0
        } else {
          this.attack_bud_charge_timer = this.attack_bud_charge_period
          this.ready_attack_bud.enemy.firing = true
        }
      } else {
        if(target_angle > cur_angle) {
          this.body.SetAngle(this.body.GetAngle() + Math.PI * 2 * dt/turn_rate)
        } else {
          this.body.SetAngle(this.body.GetAngle() - Math.PI * 2 * dt/turn_rate)
        }
      }
    }



  }

  this.process_body_buds()

  this.spawn_laser_angle += dt / this.get_spawn_laser_revolution() * Math.PI * 2

  this.get_object_hit()
  if (saveData.difficultyMode == "normal") {
    this.darkness_timer -= dt;

    if (this.darkness_timer < 0) {


      if (this.darkness_timer < -(this.darkness_spreading_duration + this.darkness_duration + this.darkness_vanish_duration)) {
        this.darkness_timer = this.darkness_interval;
        this.darkness_sound_played = false
      }

    }
  }
}

BossFour.prototype.generate_target_spawn_angle = function() {
  // get the angle to release the spawner
  var angle_to_player = utils.atan(this.body.GetPosition(), this.player.body.GetPosition());
  var possible_angles = [
    angle_to_player + Math.PI, // pick the angle opposite the player.
    angle_to_player + Math.PI / 4,
    angle_to_player - Math.PI / 4
  ];

  for (var i = 0; i < possible_angles.length; i++) {
    var angle = possible_angles[i];
    var distance = 15
    var test_point = {x: this.body.GetPosition().x + Math.cos(angle) * distance,
        y: this.body.GetPosition().y + Math.sin(angle) * distance}
    var dist = Math.min(775/constants.drawFactor - test_point.x, test_point.x - 25/constants.drawFactor)
    var dist2 = Math.min(575/constants.drawFactor - test_point.y, test_point.y - 25/constants.drawFactor)

    // One of these three angles MUST work.
    if(utils.isVisible(this.body.GetPosition(), test_point, this.level.obstacle_edges) && Math.min(dist, dist2) > 5) {
      this.target_spawn_angle = angle;
      return;
    }
  }
}

BossFour.prototype.fire_attack_bud = function(bud, initial) {
  if(this.initial_spawn) {
    // fire all spawn buds
    this.initial_spawn = false
    for(var i = 0; i < this.buds.length; i++) {
      var cur_bud = this.buds[i];
      if(cur_bud.type == "spawn") {
        this.fire_attack_bud(cur_bud, true)
      }
    }
    return
  }

  if(bud.type == "attack") {
    bud.enemy.dir = {x: bud.body.GetPosition().x - this.body.GetPosition().x, y: bud.body.GetPosition().y - this.body.GetPosition().y}
    bud.body = null
    bud.delay = 0
    this.ready_attack_bud = null
    this.attack_bud_charging = false
    bud.enemy.body.ResetMassData()
    bud.enemy = null
    music_player.play_sound("b4attacker")
  } else if(bud.type == "spawn"){
    this.ready_attack_bud = null
    this.attack_bud_charging = false
    bud.delay = 0
    bud.body = null
    var angle = utils.atan(this.body.GetPosition(), bud.enemy.body.GetPosition())
    var force = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle))
    force.Multiply(this.spawner_force)
    bud.enemy.body.ApplyImpulse(force, bud.enemy.body.GetWorldCenter())
    bud.enemy.spawned = true
    bud.enemy.firing = false
    if(initial != true)
      bud.enemy.silence(5000, true, true)
    bud.enemy.generate_collision_polygons()
    bud.enemy.body.ResetMassData()
    bud.enemy = null
    this.target_spawn_angle = null
    music_player.play_sound("b4spawner")
  }
  this.attack_bud_cooldown_timer = this.attack_bud_cooldown_period;
}

BossFour.prototype.createBodyBuds = function() {
  for(var index = 0; index < this.num_buds; index++) {
    var angle = (index + 0.5)/this.num_buds * Math.PI * 2 + this.body.GetAngle()
    var bud_body =  utils.createBody(this.world, enemyData[this.type].bud_polygon,
      this.body.GetPosition().x + this.effective_radius *1.5 * Math.cos(Math.PI/5)  * Math.cos(angle),
       this.body.GetPosition().y + this.effective_radius * 1.5 * Math.cos(Math.PI/5) * Math.sin(angle),
      3, 10, box_2d.BOSS_FOUR_BIT, box_2d.PLAYER_BIT | box_2d.ENEMY_BIT, "static", this, null)

    bud_body.SetAngle(angle)
    this.buds.push({
      type: "body",
      loc: index, // where the bud is located
      body: bud_body,
      size: this.body_bud_radius * (0.8 + 0.2 * utils.bezierInterpolate(0.15, 0.85, Math.abs(((1000 - (new Date().getTime()) % 2000)))/1000))
    })
  }
}

BossFour.prototype.additional_death_prep_specific = function() {
  for(var index = 0; index < this.buds.length; index++) {
    var bud = this.buds[index];
    var angle = utils.atan(this.body.GetPosition(), bud.body.GetPosition());
    if (bud.type == "body") {
      var bud_body =  utils.createBody(this.world, enemyData[this.type].bud_polygon,
        this.body.GetPosition().x + this.effective_radius *1.5 * Math.cos(Math.PI/5)  * Math.cos(angle),
         this.body.GetPosition().y + this.effective_radius * 1.5 * Math.cos(Math.PI/5) * Math.sin(angle),
        3, 0.1, box_2d.BOSS_FOUR_BIT, box_2d.PLAYER_BIT | box_2d.ENEMY_BIT, "dynamic", this, null)

      bud_body.SetAngle(angle)
      this.buds[index].body = bud_body;
      var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
      dir.Normalize();
      dir.Multiply(20);
      bud_body.ApplyImpulse(dir, bud_body.GetWorldCenter())
    } else if (bud.expand_timer > 0) {
      var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
      dir.Normalize();
      dir.Multiply(30);
      this.buds[index].body.ApplyImpulse(dir, this.buds[index].body.GetWorldCenter())
    }
  }
}

BossFour.prototype.repel_enemies = function() {
  var ref_angle = utils.atan(this.body.GetPosition(), this.player.get_current_position())
  for(var index in this.level.enemies) {
    var enemy = this.level.enemies[index]
    if(enemy.dying) continue
    if(enemy != this && enemy.type != "boss_four_attacker" && enemy.type != "boss_four_spawner") {

      if(utils.pDist(enemy.body.GetPosition(), this.body.GetPosition()) < 6) { // kill the enemy
        enemy.start_death("absorbed")
        continue
      }
      if(utils.pDist(enemy.body.GetPosition(), this.body.GetPosition()) < 8) {

        var enemy_angle = utils.angleClosestTo(ref_angle, utils.atan(this.body.GetPosition(), enemy.body.GetPosition()))
        enemy.body.ApplyImpulse(new box_2d.b2Vec2(enemy.force * 5* Math.cos(enemy_angle), enemy.force * 5* Math.sin(enemy_angle)), enemy.body.GetWorldCenter())

        //help the enemy along
        if(enemy_angle < ref_angle) {
          var help_angle = enemy_angle + Math.PI/2
        } else {
          var help_angle = enemy_angle - Math.PI/2
        }
        enemy.body.ApplyImpulse(new box_2d.b2Vec2(enemy.force * Math.cos(help_angle), enemy.force * Math.sin(help_angle)), enemy.body.GetWorldCenter())
      }
    }
  }
}

BossFour.prototype.process_body_buds = function() {
  // Don't process body buds if dying, so we can explode.
  if (this.dying) return;
  var size = 0.8 + 0.2 * utils.bezierInterpolate(0.15, 0.85, Math.abs(((1000 - (new Date().getTime()) % 2000)))/1000)

  var vertices = []
  for(var i = 0; i < 5; i++) {
    vertices.push({x: Math.cos(Math.PI * 2 * i / 5) * size * this.body_bud_radius, y: Math.sin(Math.PI * 2 * i / 5) * size * this.body_bud_radius})
  }
  for(var i in this.buds) {
    var bud = this.buds[i]
    if(bud.type == "body") {
      var bud = this.buds[i]
      var index = this.buds[i].loc
      var angle = (index + 0.5)/this.num_buds * Math.PI * 2 + this.body.GetAngle()
      bud.body.GetFixtureList().m_shape.m_vertices = vertices
      bud.body.SetPosition({x: this.body.GetPosition().x + (this.effective_radius + size * this.body_bud_radius) * Math.cos(Math.PI/5)  * Math.cos(angle),
        y: this.body.GetPosition().y + (this.effective_radius + size * this.body_bud_radius) * Math.cos(Math.PI/5) * Math.sin(angle)})
      bud.body.SetAngle(angle)
      bud.size = size * this.body_bud_radius
    }
  }
}

BossFour.prototype.draw_body_buds = function(context, draw_factor) {
   for(var index in this.buds) {

    if(this.buds[index].type == "body") {

      var bud = this.buds[index]

      var tp = bud.body.GetPosition()
      var angle = bud.body.GetAngle()
      context.save()
      renderUtils.drawSprite(context, tp.x* draw_factor, tp.y* draw_factor, angle,
        bud.size * draw_factor * 2, bud.size* draw_factor * 2,
        bud.loc < this.anger_level ? "adrogantia_body_bud_red" : "adrogantia_body_bud", sprites.adrogantiaSprite)
      context.restore()

    }
  }
}

BossFour.prototype.getNumberSpawners = function() {
  var count = 0
  for(var i = 0; i < this.level.enemies.length; i++)
  {
    if(this.level.enemies[i].type == "boss_four_spawner") {
      count += 1
    }
  }
  return count

}

BossFour.prototype.generate_new_attack_bud = function(bud) {

  if(bud.type == null) {
    // determine the bud type for this bud
    this.bud_count += 1

    if(this.bud_count % this.spawner_bud_frequency == 0) {
      bud.type = "spawn"
    } else {
      bud.type = "attack"
    }
  }
  var index = bud.loc
  var angle = (index)/this.num_buds * Math.PI * 2 + this.body.GetAngle()

  var offset_radius = this.effective_radius + enemyData["boss_four_"+bud.type+"er"].initial_radius * 1.5
  var new_position = {x: this.body.GetPosition().x + (offset_radius) * Math.cos(angle),
    y: this.body.GetPosition().y + (offset_radius) * Math.sin(angle)}
  var new_enemy = null
  if(bud.type == "attack")
    new_enemy = new BossFourAttacker(this.world, new_position.x, new_position.y, this.level.enemy_counter, this.impulse_game_state, 0.1)
  else {
    var spawn_type = this.get_next_enemy_type()
    var spawn_count = saveData.difficultyMode == "easy" ? this.spawner_spawn_count_easy[spawn_type] : this.spawner_spawn_count[spawn_type];
    new_enemy = new BossFourSpawner(this.world, new_position.x, new_position.y, this.level.enemy_counter, this.impulse_game_state, spawn_type, spawn_count, this.spawner_spawn_force[spawn_type], this, 0.1)
  }
  bud.body = new_enemy.body
  bud.enemy = new_enemy
  bud.body.SetAngle(angle)
  this.level.spawned_enemies.push(new_enemy)
  this.level.enemy_counter += 1
  if(this.initial_spawn && bud.type == "spawn") {
    // spawn the initial_spawn faster
    bud.expand_period = 1000
    bud.expand_timer = bud.expand_period
  } else {
    bud.expand_period = this.attack_bud_expand_period
    bud.expand_timer = bud.expand_period
  }
  // create bud
}

BossFour.prototype.create_initial_attack_buds = function() {
  this.initial_spawn = true
  for(var index = 0; index < this.num_buds; index++) {
    var new_bud = null
    if(index == 0) {
      new_bud = {
        type: "attack",
        loc: index, // where the bud is located
        delay: 0,//index * 2000,
        body: null,
        expand_period: null,
        expand_timer: null
      }
    } else {
      new_bud = {
        type: "spawn",
        loc: index, // where the bud is located
        delay: 0,//index * 2000,
        body: null,
        expand_period: null,
        expand_timer: null
      }
    }
    this.buds.push(new_bud)
    this.generate_new_attack_bud(new_bud)
  }
}

BossFour.prototype.process_attack_buds = function(dt) {
  var possible_attack_buds = []
  for(var i in this.buds) {

    var bud = this.buds[i]
    if(bud.type == "attack" || bud.type == "spawn") {
      var bud = this.buds[i]
      var index = this.buds[i].loc
      var angle = (index)/this.num_buds * Math.PI * 2 + this.body.GetAngle()

      if(bud.delay > 0 && !this.initial_spawn) {
        bud.delay -= dt
      } else {
        if(bud.body == null) {
          bud.type = null
          this.ready_bud_queue.splice(this.ready_bud_queue.indexOf(index), 1);
          this.generate_new_attack_bud(bud)
        } else {
          var size = Math.max(0.1, utils.bezierInterpolate(0.15, 0.85, Math.min(1, 1 - bud.expand_timer/bud.expand_period)) * enemyData["boss_four_"+bud.type+"er"].effective_radius)
          var offset_radius = this.effective_radius + size
          var new_position = {x: this.body.GetPosition().x + (offset_radius) * Math.cos(angle),
            y: this.body.GetPosition().y + (offset_radius) * Math.sin(angle)}

          bud.enemy.set_size(size)
          bud.body.SetAngle(angle)
          bud.body.SetPosition(new_position)
          bud.expand_timer -= dt

          if(this.attack_bud_cooldown_timer <= 0 && bud.expand_timer < 0 && this.ready_bud_queue.indexOf(i) === -1 &&
            bud != this.ready_attack_bud) {
            this.ready_bud_queue.push(i);
            // Prioritize spawn buds.
            /*if (bud.type == "spawn") {
              this.ready_attack_bud = bud;
              this.attack_bud_angle = (index)/this.num_buds * Math.PI * 2;
            } else {
              possible_attack_buds.push(i)
            }*/
          }
        }
      }
    }
  }
  if (this.ready_bud_queue.length > 0 && !this.ready_attack_bud) {
    var ready_index = this.ready_bud_queue.splice(0, 1)[0];
    var bud = this.buds[ready_index];
    this.ready_attack_bud = bud
    this.attack_bud_angle = (ready_index)/this.num_buds * Math.PI * 2
  }
}



BossFour.prototype.get_spawner_set = function() {

  if (this.spawn_count == 1) {
    return ["stunner", "spear", "harpoon", "fighter"]
  }
  else {
    return this.possible_spawn_sets[Math.floor(Math.random() * this.possible_spawn_sets.length)]
  }

}

BossFour.prototype.get_object_hit = function() {
  var dist = null
  var object = null
  var ray_end = {x: this.body.GetPosition().x + 100 * Math.cos(this.spawn_laser_angle),
    y: this.body.GetPosition().y + 100 * Math.sin(this.spawn_laser_angle)}
  if(this.laser_check_counter <= 0) {
    this.laser_check_counter = this.laser_check_timer
    for(var i = 0; i < this.level.enemies.length; i++)
    {
      if(this.level.enemies[i].id == this.id) continue
      if(!(this.level.enemies[i].type === "boss_four_spawner")) continue
      if(!this.level.enemies[i].spawned) continue

      if(!utils.isAngleBetween(this.spawn_laser_angle - this.laser_check_diff, this.spawn_laser_angle + this.laser_check_diff,
        utils.atan(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()))) continue

      var tempDist = this.level.enemies[i].get_segment_intersection(this.body.GetPosition(), ray_end).dist
      if(dist == null || (tempDist != null && tempDist < dist))
      {
        dist = tempDist
        object = this.level.enemies[i]
      }
    }
  }
  else {
    dist = this.cur_dist
    object = this.cur_object

  }
  this.laser_check_counter -=1

  var tempDist = this.player.get_segment_intersection(this.body.GetPosition(), ray_end).dist
    if(dist == null || (tempDist != null && tempDist < dist))
    {
      dist = tempDist
      object = this.player
    }

  if(object.type === "boss_four_spawner" && object.id != this.cur_object.id && object.spawned) {
    object.spawn_enemy()
  }

  this.cur_object = object
  this.cur_dist = dist
}

BossFour.prototype.get_two_laser_locs = function() {
  var locs = []
  locs.push({x: this.body.GetPosition().x + Math.cos(this.body.GetAngle() - Math.PI/2) * this.effective_radius * 1.5,
    y: this.body.GetPosition().y +Math.sin(this.body.GetAngle() - Math.PI/2) * this.effective_radius * 1.5})
  locs.push({x: this.body.GetPosition().x +Math.cos(this.body.GetAngle() + Math.PI/2) * this.effective_radius * 1.5,
    y: this.body.GetPosition().y +Math.sin(this.body.GetAngle() + Math.PI/2) * this.effective_radius * 1.5})
  return locs

}

BossFour.prototype.pre_draw = function(context, draw_factor) {
  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return

    context.save()
    var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0

    if (this.dying)
      context.globalAlpha *= (1 - prog)
    else
      context.globalAlpha *= this.visibility != null ? this.visibility : 1

    this.draw_glows(context, draw_factor)
    //draw laser

    if(this.spawned) {
      context.beginPath()
      var laser_dist = this.cur_dist != null ? this.cur_dist : 100
      context.moveTo((this.body.GetPosition().x + this.get_spawn_laser_radius() * Math.cos(this.spawn_laser_angle + Math.PI/2)) * draw_factor,
       (this.body.GetPosition().y + this.get_spawn_laser_radius() * Math.sin(this.spawn_laser_angle + Math.PI/2)) * draw_factor)
      context.lineTo((this.body.GetPosition().x + this.get_spawn_laser_radius() * Math.cos(this.spawn_laser_angle - Math.PI/2)) * draw_factor,
       (this.body.GetPosition().y + this.get_spawn_laser_radius() * Math.sin(this.spawn_laser_angle - Math.PI/2)) * draw_factor)
      context.lineTo((this.body.GetPosition().x + laser_dist * Math.cos(this.spawn_laser_angle) +this.get_spawn_laser_radius() * Math.cos(this.spawn_laser_angle - Math.PI/2)) * draw_factor,
        (this.body.GetPosition().y + laser_dist * Math.sin(this.spawn_laser_angle) +this.get_spawn_laser_radius() * Math.sin(this.spawn_laser_angle - Math.PI/2)) * draw_factor)
      context.lineTo((this.body.GetPosition().x + laser_dist * Math.cos(this.spawn_laser_angle) +this.get_spawn_laser_radius() * Math.cos(this.spawn_laser_angle + Math.PI/2)) * draw_factor,
        (this.body.GetPosition().y + laser_dist * Math.sin(this.spawn_laser_angle) +this.get_spawn_laser_radius() * Math.sin(this.spawn_laser_angle + Math.PI/2)) * draw_factor)
      context.closePath()

      context.globalAlpha *= 0.5
      context.fillStyle = this.spawn_laser_colors[this.anger_level];
      context.fill()
      context.globalAlpha *= 2;
      if (this.spawn_laser_flare_prop > 0) {
        context.save();
        context.globalAlpha *= this.spawn_laser_flare_prop;
        context.fillStyle = "red";
        context.fill();
        context.restore();
      }

    }
    context.restore()

}


BossFour.prototype.draw_glows = function(context, draw_factor) {

  var tp = this.body.GetPosition()
  if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor,
    tp.y*draw_factor,
    (this.body.GetAngle()), 200, 200, "adrogantia_glow", sprites.adrogantiaSprite)
  } else {
    renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (this.body.GetAngle()), 200, 200, "adrogantia_glow", sprites.adrogantiaSprite)
  }
}

BossFour.prototype.move = function() {
  //this.set_heading(this.player.get_current_position())
}

BossFour.prototype.collide_with = function(other) {
  if(this.dying)//ensures the collision effect only activates once
    return

  if(other === this.player) {
    var tank_angle = utils.atan(this.body.GetPosition(), this.player.get_current_position())
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.tank_force * Math.cos(tank_angle), this.tank_force * Math.sin(tank_angle)), this.player.body.GetWorldCenter())
    this.impulse_game_state.reset_combo();
    //this.cause_of_death = "hit_player"
  }

}

BossFour.prototype.get_impulse_sensitive_pts = function() {
  var ans = []
  for(var i = 0; i < this.shape_points[0].length; i++) {
    var temp = this.body.GetPosition().Copy()
    temp.Add(this.shape_points[0][i])
    ans.push(temp)
  }
  return ans
}

BossFour.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.knockback_red_duration = this.knockback_red_interval
  if (this.anger_level < this.anger_level_max) {
    this.anger_level += 1;
  }
  this.anger_level_cooloff_timer = this.anger_level_cooloff_period;
}

BossFour.prototype.explode = function() {

}

BossFour.prototype.get_spawn_laser_revolution = function() {
  return this.spawn_laser_revolution_base * Math.pow(0.8, this.anger_level);
}

BossFour.prototype.get_spawn_laser_radius = function() {
  return this.spawn_laser_radius_base * Math.pow(1.2, this.anger_level);
}

BossFour.prototype.get_time_factor = function() {
  //spawn increases by 30% for every minute
  return 1 + (this.impulse_game_state.game_numbers.seconds/60) * .2
}

BossFour.prototype.get_spawn_bonus = function() {
  return 1 + 0.2 * this.anger_level;
}

BossFour.prototype.get_spawn_laser_flare_transition_period = function() {
  return this.spawn_laser_flare_transition_period_base * Math.pow(0.8, this.anger_level);
}

BossFour.prototype.get_impulse_extra_factor = function() {
  if(saveData.difficultyMode == "easy") {
    return this.impulse_extra_factor * 2;
  }
  return this.impulse_extra_factor;
}

module.exports = BossFour;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/boss.js":19,"../enemy/boss_four_attacker.js":21,"../enemy/boss_four_spawner.js":22,"../load/save_data.js":69,"../render/sprites.js":81,"../render/utils.js":83,"../vendor/box2d.js":97}],21:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var sprites = require('../render/sprites.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

BossFourAttacker.prototype = new Enemy()

BossFourAttacker.prototype.constructor = BossFourAttacker

function BossFourAttacker(world, x, y, id, impulse_game_state,size) {

  this.type = "boss_four_attacker"

  this.init(world, x, y, id, impulse_game_state)

  this.size = size
  this.default_heading = false
  this.tank_force = 100
  if (saveData.difficultyMode == "easy") {
    this.tank_force = 70
  }
  this.spawner_hit_force = 200

  this.dir = null
  this.firing = false

  this.adjust_position_enabled = false

}

BossFourAttacker.prototype.draw = function(context, draw_factor) {

  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
  context.save()
  context.globalAlpha *= 1-prog
  if(this.firing)
    renderUtils.drawSprite(context, this.body.GetPosition().x* draw_factor, this.body.GetPosition().y* draw_factor, this.body.GetAngle(), this.size * draw_factor * 2, this.size* draw_factor * 2, "adrogantia_attack_bud_firing", sprites.adrogantiaSprite)
  else
    renderUtils.drawSprite(context, this.body.GetPosition().x* draw_factor, this.body.GetPosition().y* draw_factor, this.body.GetAngle(), this.size * draw_factor * 2, this.size* draw_factor * 2, "adrogantia_attack_bud", sprites.adrogantiaSprite)
  context.restore()
}

BossFourAttacker.prototype.additional_processing = function(dt) {
  if(this.dir) {
    var dir = new box_2d.b2Vec2(this.dir.x, this.dir.y)
    dir.Normalize()
    dir.Multiply(this.force)
    if (saveData.difficultyMode == "easy") {
      dir.Multiply(0.5)
    }
    this.body.ApplyImpulse(dir, this.body.GetWorldCenter())
  }
}

BossFourAttacker.prototype.move = function() {
  return
}

BossFourAttacker.prototype.collide_with = function(other) {
  if(this.dying)//ensures the collision effect only activates once
    return

  if(this.is_silenced()) return


  if(other === this.player) {

      var tank_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
      this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.tank_force * Math.cos(tank_angle), this.tank_force * Math.sin(tank_angle)), this.player.body.GetWorldCenter())
      this.impulse_game_state.reset_combo();
      //this.cause_of_death = "hit_player"
      return
  } else if(this.dir && other.type == "boss_four_spawner") {
    var tank_angle = utils.atan({x:0, y:0}, this.dir)
    var ref_angle = utils.angleClosestTo(tank_angle, utils.atan(this.body.GetPosition(), other.body.GetPosition()))
    if(tank_angle < ref_angle) {
      tank_angle -= Math.PI/2
    } else {
      tank_angle += Math.PI/2
    }
    other.body.ApplyImpulse(new box_2d.b2Vec2(this.spawner_hit_force * Math.cos(tank_angle), this.spawner_hit_force * Math.sin(tank_angle)), other.body.GetWorldCenter())
  } else if(this.dir && other.type != "boss_four") {
    var tank_angle = utils.atan(this.body.GetPosition(), other.body.GetPosition())
    var dir = new box_2d.b2Vec2(this.dir.x, this.dir.y)
    dir.Normalize()
    dir.Multiply(100 * other.force)
    other.body.ApplyImpulse(dir, other.body.GetWorldCenter())
  }
}

BossFourAttacker.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {

}

BossFourAttacker.prototype.check_death = function() {
  //check if enemy has intersected polygon, if so die

  if(!this.dir) return

  for(var k = 0; k < this.level.obstacle_polygons.length; k++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[k], this.body.GetPosition()))
    {

      if (this.durations["open"] <= 0 && this.require_open) {
        this.start_death("accident")
      } else {
        this.start_death("kill")
      }

      return
    }
  }
}


BossFourAttacker.prototype.set_size = function(size) {
  var vertices = []
  for(var j = 0; j < 5; j++) {
    vertices.push({x: Math.cos(Math.PI * 2 * j / 5) * size, y: Math.sin(Math.PI * 2 * j / 5) * size})
  }
  this.body.GetFixtureList().m_shape.m_vertices = vertices
  this.size = size
  this.body.ResetMassData()
}

module.exports = BossFourAttacker;

},{"../core/utils.js":11,"../enemy/enemy.js":30,"../load/save_data.js":69,"../render/sprites.js":81,"../render/utils.js":83,"../vendor/box2d.js":97}],22:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var enemyData = require('../data/enemy_data.js');
var enemyRenderUtils = require('../render/enemy.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var sprites = require('../render/sprites.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');
var EnemyFactory = require('../enemy/enemy_factory.js');

BossFourSpawner.prototype = new Enemy()

BossFourSpawner.prototype.constructor = BossFourSpawner

function BossFourSpawner(world, x, y, id, impulse_game_state, enemy_type, enemy_spawn, push_force, boss, start_size) {

  this.type = "boss_four_spawner"

  this.init(world, x, y, id, impulse_game_state)

  this.enemy_type = enemy_type
  this.image_enemy_type = this.type+" "+enemy_type

  this.color = "black"
  this.interior_color = enemyData[this.enemy_type].color
  this.spawn = false
  this.spawn_number = enemy_spawn
  this.push_force = push_force
  this.size = start_size

  this.default_heading = false

  this.parent = boss

  this.spawned = false
  this.firing = false

  this.spawn_action_period = 1000
  this.spawn_action_timer = 0

  this.spawn_expand_factor = 3
  this.impulse_extra_factor = 2
  this.tank_force = 100

}

BossFourSpawner.prototype.additional_processing = function(dt) {
  if(this.dying) return

  if(this.spawned) {
    if(this.spawn_action_timer > 0) {
      var cur_factor = 1 + utils.bezierInterpolate(0.15, 0.85, 0.5 - Math.abs(this.spawn_action_timer/this.spawn_action_period - 0.5))
      this.set_size(enemyData[this.type].effective_radius * cur_factor)
      this.spawn_action_timer -= dt
    } else {
      if(this.size != enemyData[this.type].effective_radius) {
        this.set_size(enemyData[this.type].effective_radius)
      }
    }
  }


	if(this.spawn && this.spawn_action_timer < this.spawn_action_period/2) {
    music_player.play_sound("b4spawneract")
		var ray_angle = utils.atan(this.parent.body.GetPosition(), this.body.GetPosition())
    var j = 0
    var spawn_number = this.spawn_number * this.parent.get_spawn_bonus();
    var exit_points = Math.max(spawn_number, 4)
    for(var i = 0; i < spawn_number; i++) {

      if(this.level.enemy_numbers[this.enemy_type] + i >= this.level.enemies_data[this.enemy_type][6]) {
        //prevents over_spawn
        this.silence(500)
        this.spawn = false
        return
      }

      // find a direction that isn't close to the wall
      var angle = ray_angle + Math.PI * 2 * (j + (1/((j - (j % exit_points))/exit_points + 1)))/exit_points
      while(!utils.isVisible(this.body.GetPosition(),
        {x: this.body.GetPosition().x + 10 * Math.cos(angle),
          y: this.body.GetPosition().y + 10 * Math.sin(angle)},
          this.level.obstacle_edges
        ))
      {
          j += 1
          angle = ray_angle + Math.PI * 2 * (j + (1/((j - (j % exit_points))/exit_points + 1)))/exit_points
      }

  		var loc = [this.body.GetPosition().x + this.effective_radius * 2 * Math.cos(angle),
  		this.body.GetPosition().y + this.effective_radius * 2 * Math.sin(angle)]

      var temp_enemy = new ((EnemyFactory.getEnemyClassFromType(this.enemy_type)))(this.world, loc[0], loc[1], this.level.enemy_counter, this.impulse_game_state)

      var force = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle))
      force.Multiply(this.push_force)
      temp_enemy.body.ApplyImpulse(force, temp_enemy.body.GetWorldCenter())
      temp_enemy.set_heading(angle);
      temp_enemy.pathfinding_counter = temp_enemy.pathfinding_delay

      // disable initial silence.
      temp_enemy.entered_arena = true;
      temp_enemy.recovery_timer = 0;

  		this.level.spawned_enemies.push(temp_enemy)

      this.level.enemy_counter +=1
      j+=1
    }

    this.spawn = false
    this.silence(1000)
	}

}

BossFourSpawner.prototype.set_size = function(size) {
  var vertices = []
  for(var j = 0; j < 5; j++) {
    vertices.push({x: Math.cos(Math.PI * 2 * j / 5) * size, y: Math.sin(Math.PI * 2 * j / 5) * size})
  }
  this.body.GetFixtureList().m_shape.m_vertices = vertices
  this.size = size
  this.body.ResetMassData()
}


BossFourSpawner.prototype.additional_drawing = function(context, draw_factor) {
  if(this.is_silenced() && this.color_silenced && !this.dying) {
    context.beginPath()
    context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, (this.effective_radius*draw_factor) * 1.5, -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * 0.999 * (this.status_duration[1] / this.last_stun), true)
    context.lineWidth = 2
    context.strokeStyle = "red";
    context.stroke()
  }
}

BossFourSpawner.prototype.super_silence = Enemy.prototype.silence;
BossFourSpawner.prototype.silence = function(dur, color_silence) {
  this.super_silence(dur, color_silence);
  this.last_stun = dur;
}

BossFourSpawner.prototype.collide_with = function(other) {
  if(this.dying)//ensures the collision effect only activates once
    return

  if (other === this.player) {
    this.impulse_game_state.reset_combo();
  }
}

BossFourSpawner.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  if(this.spawned)  {
    this.body.ApplyImpulse(new box_2d.b2Vec2(this.impulse_extra_factor * impulse_force*Math.cos(hit_angle), this.impulse_extra_factor * impulse_force*Math.sin(hit_angle)),
      this.body.GetWorldCenter())
    this.process_impulse_specific(attack_loc, impulse_force, hit_angle)
  }
}

BossFourSpawner.prototype.spawn_enemy = function() {
  if(!this.is_silenced()) {
  	this.spawn = true
    this.spawn_action_timer = this.spawn_action_period
  }
}

BossFourSpawner.prototype.draw  = function(context, draw_factor) {
  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
  context.save()
  context.globalAlpha *= 1-prog
  renderUtils.drawSprite(context, this.body.GetPosition().x* draw_factor, this.body.GetPosition().y* draw_factor, this.body.GetAngle(), this.size * draw_factor * 2, this.size* draw_factor * 2, "adrogantia_spawner", sprites.adrogantiaSprite)

  enemyRenderUtils.drawEnemyColored(context, this.enemy_type, this.body.GetPosition().x* draw_factor, this.body.GetPosition().y* draw_factor, this.size * draw_factor * 0.7, this.body.GetAngle(), "black")
  context.restore()

  this.additional_drawing(context, draw_factor)
}

BossFourSpawner.prototype.move = function() {
}

module.exports = BossFourSpawner;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../enemy/enemy_factory.js":31,"../render/enemy.js":74,"../render/sprites.js":81,"../render/utils.js":83,"../vendor/box2d.js":97}],23:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var sprites = require('../render/sprites.js');
var utils = require('../core/utils.js');

var Boss = require('../enemy/boss.js');
var EnemyFactory = require('../enemy/enemy_factory.js');

BossOne.prototype = new Boss()

BossOne.prototype.constructor = BossOne

function BossOne(world, x, y, id, impulse_game_state) {
  this.type = "boss_one"

  this.world = world

  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  this.death_radius = 5

  this.shoot_interval = 562.5

  this.shoot_duration = this.shoot_interval

  this.do_yield = false

  this.bullet_alternater = 0

  this.safe = true

  this.shoot_interval = 3000

  this.shoot_speedup_factor = 2

  this.times_shot = 0

  this.lighten_interval = 9000

  this.turret_enemy_threshold = 30

  this.lighten_timer = this.lighten_interval - 1

  this.lighten_duration = 3000

  this.lightened = false

  this.spawned = false

  this.enemies_to_spawn = ["stunner", "spear", "tank"]
  this.spawn_force =
  {
    "stunner": 5, //30,
    "spear": 3, //15,
    "tank": 20//80
  }
  this.default_heading = false

  this.body.SetAngle(Math.PI/2)
  this.initial_angle = Math.PI/2

  this.visibility = 0

  this.turret_firing_interval = 500

  if(saveData.difficultyMode == "easy") {
    this.turret_firing_interval = 750
  }

  // Slightly easier to push on easy mode.
  if (saveData.difficultyMode == "easy") {
    this.impulse_extra_factor = 20
  } else {
    // Impulse is HIGHER on normal mode because touching the boss is death.
    this.impulse_extra_factor = 15
  }

  this.turn_rate = 5000

  this.red_visibility = 0

  this.body.SetLinearDamping(enemyData[this.type].lin_damp * 100)

  this.boss_force = 30

  if(saveData.difficultyMode == "easy") {
    this.boss_force = 30
  }

  this.joint_padding = 1

  this.punch_force = 8

  this.retract_force = 1

  this.action_interval = 750

  this.default_transition_interval = 400
  this.loading_punch_interval = 400

  this.retract_transition_interval = 300
  this.punch_action_interval = 400
  this.paralyze_interval = 300

  this.right_arm_punch_offset_delay = (this.default_transition_interval + this.punch_action_interval + this.retract_transition_interval + this.loading_punch_interval + this.paralyze_interval)/2

  this.action_default_interval = 1500
  this.turret_transition_interval = 1500

  this.knockback_red_interval = 150
  this.knockback_red_duration = 0

  this.punch_knockback_window = 100

  this.knockback_arm_interval = 150
  this.knockback_arm_timers = {
    left: 0,
    right: 0
  }

  this.min_turret_switch_dist = 15

  this.paralyzed_pause = {
    left: 0,
    right: 0
  }

  this.action_timer = {
    left: this.action_interval,
    right: this.action_interval
  }

  this.data = enemyData[this.type]

  this.state = "turret"
  this.state_switch_interval = 10000
  this.state_switch_timer = this.state_switch_interval

  this.arm_states = {
    left: "none",
    right: "none"
  }
  this.joints = {}
  this.body_parts = {}

  this.add_arms()

  this.joint_target_locs = {}

  this.joint_polygons = {

    "lu": this.data.upper_arm_polygon[0],
    "ru": this.data.upper_arm_polygon[0],
    "ll": this.data.lower_arm_polygon[0],
    "rl": this.data.lower_arm_polygon[0],
    "lh": this.data.hand_polygon[0],
    "rh": this.data.hand_polygon[0]
  }

  this.punch_start = {}


  this.punch_target_pts = {
    left: "none",
    right: "none"
  }

  this.last_action_interval = {
    left: 0,
    right: 0
  }
  this.punch_range = 13

  this.punch_angle= {
    left: 0,
    right: 0
  }

  this.target_angle = null
  var _this = this;


  this.punching_explode_interval = 13500 // slightly earlier than 13400
  this.punching_explode_timer = this.punching_explode_interval

  this.punching_explode_warning_interval = 2000
  this.punching_explode_shockwave_interval = 200

  this.punching_explode_warning_parts = 8
  this.punching_explode_warning_size = 100

  this.punching_explode_radius = 15

  this.punching_explode_force = 150

  this.punch_exploded = false

  this.max_turret_interval = 4000
  this.max_punching_interval = 12000
  this.max_punching_interval_with_no_enemies = 6000
  this.max_turret_timer = this.max_turret_interval
  this.max_punching_timer = this.max_punching_interval

  this.require_open = false

  this.impulse_hand_force = 0.1

  this.lockon_display_interval = 1000
  this.lockon_display_timer = 0
  this.lockon_display = null

  this.start_time = 0

  this.first_turret = true
}

BossOne.prototype.add_arms = function() {

  var upper_arm_r = enemyData[this.type].upper_arm_polygon[0].r;
  var lower_arm_r = enemyData[this.type].lower_arm_polygon[0].r
  var hand_r = enemyData[this.type].hand_polygon[0].r;
  var body_r = this.effective_radius;
  var body_x = this.body.GetPosition().x
  var body_y = this.body.GetPosition().y
  var j_gap = this.joint_padding

  this.body_parts["lu"] = this.create_upper_arm_piece(body_x + body_r + upper_arm_r - 2 * j_gap, body_y)
  this.joints["lu"] = this.create_joint(new box_2d.b2Vec2(body_x + body_r - j_gap, body_y), this.body, this.body_parts["lu"])

  this.body_parts["ll"] = this.create_lower_arm_piece(body_x + body_r + 2 * upper_arm_r + lower_arm_r - 4 * j_gap, body_y)
  this.joints["ll"] = this.create_joint(new box_2d.b2Vec2(body_x + body_r + 2 * upper_arm_r - 3* j_gap, body_y), this.body_parts["lu"], this.body_parts["ll"])

  this.body_parts["lh"] = this.create_hand(body_x + body_r + 2 * upper_arm_r + 2*lower_arm_r - 4 * j_gap + 0.25 * hand_r, body_y)
  this.body_parts["lh"].SetAngle(Math.PI/4)
  this.joints["lh"] = this.create_joint(new box_2d.b2Vec2(body_x + body_r + 2 * upper_arm_r + 2 * lower_arm_r - 4* j_gap + 0.25 * hand_r, body_y), this.body_parts["ll"], this.body_parts["lh"])

  this.body_parts["ru"] = this.create_upper_arm_piece(body_x - (body_r + upper_arm_r - 2 * j_gap), body_y)
  this.joints["ru"] = this.create_joint(new box_2d.b2Vec2(body_x - (body_r - j_gap), body_y), this.body, this.body_parts["ru"])

  this.body_parts["rl"] = this.create_lower_arm_piece(body_x - (body_r + 2 * upper_arm_r + lower_arm_r - 4 * j_gap), body_y)
  this.joints["rl"] = this.create_joint(new box_2d.b2Vec2(body_x - (body_r + 2 * upper_arm_r - 3* j_gap), body_y), this.body_parts["ru"], this.body_parts["rl"])

  this.body_parts["rh"] = this.create_hand(body_x - (body_r + 2 * upper_arm_r + 2*lower_arm_r - 4 * j_gap + 0.25 * hand_r), body_y)
  this.body_parts["rh"].SetAngle(Math.PI/4)
  this.joints["rh"] = this.create_joint(new box_2d.b2Vec2(body_x - (body_r + 2 * upper_arm_r + 2 * lower_arm_r - 4* j_gap + 0.25 * hand_r), body_y), this.body_parts["rl"], this.body_parts["rh"])

}

BossOne.prototype.additional_death_prep_specific = function() {
  var body_parts = ["lu", "ll", "lh", "ru", "rl", "rh"];
  var death_explode_force = 10;
  this.knockback_red_duration = 0;
  this.knockback_arm_timers.left = 0;
  this.knockback_arm_timers.right = 0;

  for (var i = 0; i < body_parts.length; i++) {
    this.world.DestroyJoint(this.joints[body_parts[i]]);
    var angle = utils.atan(this.body.GetPosition(), this.body_parts[body_parts[i]].GetPosition());
    var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
    dir.Normalize();
    dir.Multiply(death_explode_force);
    this.body_parts[body_parts[i]].ApplyImpulse(dir, this.body_parts[body_parts[i]].GetWorldCenter())
  }
}

BossOne.prototype.load_punch_at_player = function(side, pt) {
    this.set_timer(side, this.loading_punch_interval)
    if(side=="left") {
      var _this = this;
      this.arm_states[side] = "loading"
      this.rotate_joint_to("lu", -Math.PI * 0.3)
      this.rotate_joint_to("lh", Math.PI/4)
      this.rotate_joint_to("ll", function() {
        var this_angle = utils.angleClosestTo(_this.joints["ll"].GetJointAngle(), utils.atan(_this.joints["ll"].GetAnchorA(), _this.player.get_current_position())
         - _this.joints["lu"].GetJointAngle() - (_this.body.GetAngle() - _this.initial_angle))
        return this_angle
      })
      this.punch_angle[side] = utils.atan(this.joints["ll"].GetAnchorA(), pt)

      this.punch_target_pts[side] = {x: this.joints["ll"].GetAnchorA().x + Math.cos(this.punch_angle[side]) * this.punch_range,
                            y: this.joints["ll"].GetAnchorA().y + Math.sin(this.punch_angle[side]) * this.punch_range,
                          }
      this.lockon_display_timer = this.lockon_display_interval
      this.lockon_display = "left"
    }

    if(side=="right") {
      var _this = this;
      this.arm_states[side] = "loading"
      this.rotate_joint_to("ru", Math.PI * 0.3)
      this.rotate_joint_to("rh", -Math.PI/4)
      this.rotate_joint_to("rl", function() {
        var this_angle = utils.angleClosestTo(_this.joints["rl"].GetJointAngle(), Math.PI+utils.atan(_this.joints["rl"].GetAnchorA(), _this.player.get_current_position())
         - _this.joints["ru"].GetJointAngle() - (_this.body.GetAngle() - _this.initial_angle))
        return this_angle
      })
      this.punch_angle[side] = utils.atan(this.joints["rl"].GetAnchorA(), pt)

      this.punch_target_pts[side] = {x: this.joints["rl"].GetAnchorA().x + Math.cos(this.punch_angle[side]) * this.punch_range,
                            y: this.joints["rl"].GetAnchorA().y + Math.sin(this.punch_angle[side]) * this.punch_range,
      }
      this.lockon_display_timer = this.lockon_display_interval
      this.lockon_display = "right"
    }
}

BossOne.prototype.move_arm_to_default = function(side, right_stall) {
    this.set_timer(side, this.default_transition_interval)
    if(side=="left") {
      this.arm_states[side] = "default"
      this.rotate_joint_to("lu", -Math.PI/4)
      this.rotate_joint_to("ll", Math.PI/2)
      this.rotate_joint_to("lh", 0)
    } else if(side=="right") {
      this.arm_states[side] = "default"
      if(right_stall) {
        this.arm_states[side] = "delay_default"
      }
      this.rotate_joint_to("ru", Math.PI/4)
      this.rotate_joint_to("rl", -Math.PI/2)
      this.rotate_joint_to("rh", 0)
    }
}



BossOne.prototype.move_arm_to_turret = function(side, right_stall) {
    this.set_timer(side, this.turret_transition_interval)
    if(side=="left") {
      this.arm_states[side] = "loading_turret"
      this.rotate_joint_to("lu", Math.PI/2)
      this.rotate_joint_to("ll", 0)
      this.rotate_joint_to("lh", 0)
    } else if(side=="right") {
      this.arm_states[side] = "loading_turret"
      this.rotate_joint_to("ru", -Math.PI/2)
      this.rotate_joint_to("rl", 0)
      this.rotate_joint_to("rh", 0)
    }
}

BossOne.prototype.punch_at = function(pt, side) {
  this.set_timer(side, this.punch_action_interval )

  if(side=="left") {
    this.punch_start["ll"] = this.joints["ll"].GetJointAngle()
    this.punch_start["lu"] = this.joints["lu"].GetJointAngle()
    this.punch_start["lh"] = this.joints["lh"].GetJointAngle()
    this.arm_states[side] = "punching"
    this.joints["ll"].SetLimits(0, Math.PI)
    this.joints["lu"].SetLimits(-Math.PI, Math.PI)
    this.joints["lh"].SetLimits(0, 0)
  }

  if(side=="right") {
    this.punch_start["rl"] = this.joints["rl"].GetJointAngle()
    this.punch_start["ru"] = this.joints["ru"].GetJointAngle()
    this.punch_start["rh"] = this.joints["rh"].GetJointAngle()
    this.arm_states[side] = "punching"
    this.joints["rl"].SetLimits(-Math.PI, 0)
    this.joints["ru"].SetLimits(-Math.PI, Math.PI)
    this.joints["rh"].SetLimits(0, 0)
  }
}

BossOne.prototype.paralyze_arm = function(side) {
  this.arm_states[side] = "paralyzed"
  if(side == "right") {
    var joints = ["rl", "ru", "rh"]
  }
  if(side == "left") {
    var joints = ["ll", "lu", "lh"]
  }

  for(var index in joints) {
    var joint_name = joints[index]
    this.joints[joint_name].SetLimits(this.joints[joint_name].GetJointAngle(), this.joints[joint_name].GetJointAngle())
  }


}

BossOne.prototype.retract_punch = function(side) {

  this.set_timer(side, this.retract_transition_interval)
    if(side=="left") {
      this.punch_target_pts["left"] = null
      this.arm_states[side] = "retract"
      this.rotate_joint_to("lu", this.punch_start["lu"])
      this.rotate_joint_to("ll", this.punch_start["ll"])
      this.rotate_joint_to("lh", this.punch_start["lh"])
    } else if(side=="right") {
      this.punch_target_pts["right"] = null
      this.arm_states[side] = "retract"
      this.rotate_joint_to("ru", this.punch_start["ru"])
      this.rotate_joint_to("rl", this.punch_start["rl"])
      this.rotate_joint_to("rh", this.punch_start["rh"])
    }
}

BossOne.prototype.rotate_joint_to = function(joint_name, angle) {

  this.joint_target_locs[joint_name] = {
    start: this.joints[joint_name].GetJointAngle(),
    end: angle
  }
}

BossOne.prototype.turret_fire_enemy = function(arm) {

  var dir = new box_2d.b2Vec2(Math.cos(this.body.GetAngle()), Math.sin(this.body.GetAngle()));

  var enemy_type = this.enemies_to_spawn[Math.floor(Math.random() * this.enemies_to_spawn.length)]
  if (saveData.difficultyMode == "easy" && enemy_type == "tank") {
    // If it's a tank, reroll to reduce number of tanks.
    if (Math.random() < 0.5) {
      enemy_type = this.enemies_to_spawn[Math.floor(Math.random() * this.enemies_to_spawn.length)]
    }
  }
  dir.Normalize()
  var spawn_loc = null;
  if(arm == "left")
    spawn_loc = {x: this.body_parts['lh'].GetPosition().x + dir.x * 3,
     y: this.body_parts['lh'].GetPosition().y + dir.y * 3}
  if(arm == "right")
    spawn_loc = {x: this.body_parts['rh'].GetPosition().x + dir.x * 3,
  y: this.body_parts['rh'].GetPosition().y + dir.y * 3}
  dir.Multiply(this.spawn_force[enemy_type])
  var new_enemy = new (EnemyFactory.getEnemyClassFromType(enemy_type))(this.world, spawn_loc.x, spawn_loc.y, this.level.enemy_counter, this.impulse_game_state)
  this.level.spawned_enemies.push(new_enemy)
  new_enemy.body.ApplyImpulse(dir, new_enemy.body.GetWorldCenter())
  new_enemy.stun(this.max_turret_timer + 2000)
  new_enemy.invincible(this.max_turret_timer + 2000)
  if(enemy_type == "stunner")
    new_enemy.open(1500)
  new_enemy.pathfinding_counter = 2 * new_enemy.pathfinding_delay //immediately look for path
  new_enemy.set_heading(this.body.GetAngle());
  if(this.lighten_timer < 0) {
    new_enemy.lighten((this.lighten_timer + this.lighten_duration))
  }
  this.level.enemy_counter += 1
}

BossOne.prototype.set_timer = function(side, time) {
  this.action_timer[side] = time;
  this.last_action_interval[side] = time
}

BossOne.prototype.create_lower_arm_piece = function(x, y) {
  return utils.createBody(this.world, enemyData[this.type].lower_arm_polygon, x, y, 3, 0.01, box_2d.BOSS_ONE_BIT, box_2d.ENEMY_BIT | box_2d.PLAYER_BIT, "dynamic", this, null)
}
BossOne.prototype.create_upper_arm_piece = function(x, y) {
  return utils.createBody(this.world, enemyData[this.type].upper_arm_polygon, x, y, 3, 0.01, box_2d.BOSS_ONE_BIT, box_2d.ENEMY_BIT | box_2d.PLAYER_BIT, "dynamic", this, null)
}
BossOne.prototype.create_hand = function(x, y) {
  return utils.createBody(this.world, enemyData[this.type].hand_polygon, x, y, 3, 0.01, box_2d.BOSS_ONE_BIT, box_2d.ENEMY_BIT | box_2d.PLAYER_BIT, "dynamic", this, null)
}
BossOne.prototype.create_joint = function(joint_loc, body1, body2) {

  var joint = new box_2d.b2RevoluteJointDef;
  joint.Initialize(body1, body2, joint_loc)
  joint.enableLimit = true;
  joint.lowerAngle = -Math.PI/2
  joint.upperAngle = Math.PI/2
  joint.collideConnected = false
  return this.world.CreateJoint(joint)
}

BossOne.prototype.boss_specific_additional_processing = function(dt) {

  this.start_time += dt

  if (this.level.enemies.length == 1) {
    // if there are no enemies on the stage, don't punch for so long
    if (this.max_punching_timer > this.max_punching_interval_with_no_enemies) {
      this.max_punching_timer = this.max_punching_interval_with_no_enemies
    }
  }

  if(this.knockback_red_duration > 0) {
    this.knockback_red_duration -= dt
  }

  if(this.lockon_display_timer > 0) {
    this.lockon_display_timer -= dt
  } else {
    this.lockon_display = null
  }


  if(this.state == "turret") {
    this.max_turret_timer -= dt;
    if(this.max_turret_timer < 0) {
      this.switch_to_punching()
    }
  } else if (this.state == "punching") {
    this.max_punching_timer -= dt;
    if(this.max_punching_timer < 0) {
      this.switch_to_turret()
    }
  }

  for(arm in this.arm_states) {
    this.action_timer[arm] -= dt;
    if(this.knockback_arm_timers[arm] > 0) {
      this.knockback_arm_timers[arm] -= dt
    }

    if(this.arm_states[arm] == "none") {
      this.switch_to_turret()
    }

    if(this.state == "turret") {
      var cur_angle = utils.angleClosestTo(this.body.GetAngle(), utils.atan(this.body.GetPosition(), this.player.get_current_position())+(Math.abs((this.start_time % 2000) - 1000)-500)/500*Math.PI/8);
    } else if(this.state == "punching") {
      var cur_angle = utils.angleClosestTo(this.body.GetAngle(), utils.atan(this.body.GetPosition(), this.player.get_current_position()));
    }

    if(this.arm_states[arm] == "loading") {
      this.process_turning_to_angle(cur_angle)
      if(this.action_timer[arm] < 0) {
        this.punch_at(this.player.get_current_position().Copy(), arm)
      } else {
        this.process_move_arms_to_target(arm)
      }
    }

    if(this.arm_states[arm] == "default") {
      this.process_turning_to_angle(cur_angle)
      if(this.action_timer[arm] < 0) {
        if(this.paralyzed_pause[arm] > 0) {
          this.paralyzed_pause[arm] -= dt
        } else {
          this.load_punch_at_player(arm, this.player.get_current_position())
        }
      } else {
        this.process_move_arms_to_target(arm)
      }
    }

    if(this.arm_states[arm] == "delay_default") {
      this.process_turning_to_angle(cur_angle)
      if(this.action_timer[arm] < - this.right_arm_punch_offset_delay) {
        if(this.paralyzed_pause[arm] > 0) {
          this.paralyzed_pause[arm] -= dt
        } else {
          this.load_punch_at_player(arm, this.player.get_current_position())
        }
      } else {
        this.process_move_arms_to_target(arm)
      }
    }

    if(this.arm_states[arm] == "punching") {
      if(this.action_timer[arm] < 0) {
        this.paralyze_arm(arm)
        this.action_timer[arm] = this.paralyze_interval
      } else {
        this.process_punching(arm)
      }

    }

    if(this.arm_states[arm] == "retract") {
      if(this.action_timer[arm] < 0) {
        this.move_arm_to_default(arm)
      } else {
        this.process_move_arms_to_target(arm)
      }
    }

    if(this.arm_states[arm] == "paralyzed") {
      if(this.action_timer[arm] < 0) {
        this.retract_punch(arm)
      }
    }
    if(this.arm_states[arm] == "loading_turret") {
      this.process_turning_to_angle(cur_angle)
      if(this.action_timer[arm] < 0) {
        this.arm_states[arm] = "turret_firing"
      } else {
        this.process_move_arms_to_target(arm)
      }
    }

    if(this.arm_states[arm] == "turret_firing") {
      this.process_turning_to_angle(cur_angle)
      if(this.action_timer[arm] < 0) {
        this.turret_fire_enemy(arm)
        this.action_timer[arm] = this.turret_firing_interval
      }
    }
  }

  if (saveData.difficultyMode == "normal") {
    if(this.lighten_timer < 0 && this.lighten_timer > -this.lighten_duration * 0.9 && !this.lightened) {
      this.lightened = true
      music_player.play_sound("b1shrink")

      if(this.shoot_duration > this.shoot_interval/this.shoot_speedup_factor) {
        this.shoot_duration = this.shoot_interval/this.shoot_speedup_factor
      }
      this.global_lighten()
    }

    if (this.lighten_timer < -this.lighten_duration * 0.9) {
      if (this.lightened)  {
        // in order to play the sound at the right moment, we'll allow the boss's punches to lose the lighten bonus early.
        this.lightened = false
        music_player.play_sound("b1grow")
      }
    }

    if(this.lighten_timer < -this.lighten_duration) {
      this.lighten_timer = this.lighten_interval
    }
    this.lighten_timer -= dt

    if(this.lighten_timer > .9 * this.lighten_interval) {
      this.red_visibility = (this.lighten_timer - .9 * this.lighten_interval)/(.1 * this.lighten_interval)
    }
    else if(this.lighten_timer < .175 * this.lighten_interval && this.lighten_timer >= 0) {
      var temp = this.lighten_timer
      while(temp > .05 * this.lighten_interval) {temp -= .05 * this.lighten_interval}

      this.red_visibility = temp > 0.025 * this.lighten_interval ? (temp - 0.025 * this.lighten_interval)/(0.025 * this.lighten_interval) : (0.025*this.lighten_interval - temp)/(0.025 * this.lighten_interval)
    }
    else if(this.lighten_timer < 0) {
      this.red_visibility = 1
    }
  }
}

BossOne.prototype.process_punching = function(arm) {
  if(arm == "left") {
    var angle = utils.atan(this.body_parts["lh"].GetPosition(), this.punch_target_pts[arm])
    var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
    var dist = utils.pDist(this.body_parts["lh"].GetPosition(), this.punch_target_pts[arm])
    var body_dist = utils.pDist(this.joints["lu"].GetAnchorA(), this.punch_target_pts[arm])
    if(dist < 10) {
      dir.Multiply(dist/10)
    }
    if(this.arm_states[arm] == "punching")
      dir.Multiply(this.punch_force);
    this.body_parts["lh"].ApplyImpulse(dir, this.body_parts["lh"].GetWorldCenter())
  }

  if(arm == "right") {
    var angle = utils.atan(this.body_parts["rh"].GetPosition(), this.punch_target_pts[arm])
    var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
    var dist = utils.pDist(this.body_parts["rh"].GetPosition(), this.punch_target_pts[arm])
    var body_dist = utils.pDist(this.joints["ru"].GetAnchorA(), this.punch_target_pts[arm])
    if(dist < 10) {
      dir.Multiply(dist/10)
    }
    if(this.arm_states[arm] == "punching")
      dir.Multiply(this.punch_force);
      this.body_parts["rh"].ApplyImpulse(dir, this.body_parts["rh"].GetWorldCenter())
  }
}

BossOne.prototype.process_turning_to_angle = function(angle) {
  this.body.SetAngle(angle)
}

BossOne.prototype.process_move_arms_to_target = function(side) {
  var joints = []
  if(side == "left") {
    joints = ["lu", "ll", "lh"]
  }
  if(side == "right") {
    joints = ["ru", "rl", "rh"]
  }
    for(index in joints) {
      var joint = joints[index]
      if(typeof this.joint_target_locs[joint].start !== "undefined" && typeof this.joint_target_locs[joint].end !== "undefined") {
        var prog = Math.max((this.action_timer[side])/(this.last_action_interval[side]),0)
        var end_angle = null;
        if(typeof this.joint_target_locs[joint].end == "function") {
          end_angle = this.joint_target_locs[joint].end()
        } else {
          end_angle = this.joint_target_locs[joint].end
        }
        var cur_angle = prog * this.joint_target_locs[joint].start + (1-prog) * end_angle;
        this.joints[joint].SetLimits(cur_angle, cur_angle)
      }
    }
}

BossOne.prototype.draw_arm_piece = function(arm, context, draw_factor, side) {
    // fade out if dying

    var tp = arm.GetPosition();

    if(this.knockback_red_duration > 0 || this.knockback_arm_timers[side] > 0) {
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (arm.GetAngle() + Math.PI/4), 64, 64, "immunitas_arm_red", sprites.immunitasSprite)

    } else
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (arm.GetAngle() + Math.PI/4), 64, 64, "immunitas_arm", sprites.immunitasSprite)


}

BossOne.prototype.draw_hand = function(hand, context, draw_factor, side) {
    // fade out if dying
    var tp = hand.GetPosition();
        if(this.knockback_red_duration > 0 || this.knockback_arm_timers[side] > 0) {
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (hand.GetAngle() + Math.PI/4), 64, 64, "immunitas_hand_red", sprites.immunitasSprite)

    } else
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (hand.GetAngle() + Math.PI/4), 64, 64, "immunitas_hand", sprites.immunitasSprite)


}

BossOne.prototype.draw_aura = function(context, draw_factor) {
    // fade out if dying
    var tp = this.body.GetPosition()
    context.globalAlpha *= 0.6
    if(this.knockback_red_duration > 0) {
      renderUtils.drawSprite(context, tp.x*draw_factor,
    tp.y*draw_factor,
    (Math.PI/4), 173, 173, "immunitas_aura_red", sprites.immunitasSprite)

    } else
     renderUtils.drawSprite(context, tp.x*draw_factor,
    tp.y*draw_factor,
    (Math.PI/4), 173, 173, "immunitas_aura", sprites.immunitasSprite)
     context.globalAlpha /= 0.6
}

BossOne.prototype.draw_glows = function(context, draw_factor) {

  var tp = this.body.GetPosition()
  if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor,
    tp.y*draw_factor,
    (this.body.GetAngle()), 285, 285, "immunitas_red_glow", sprites.immunitasSprite)
  } else {
    renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (this.body.GetAngle()), 285, 285, "immunitas_glow", sprites.immunitasSprite)
  }

  var glowing_body_parts = []
  for(index in glowing_body_parts) {
    var name = glowing_body_parts[index]
    if(this.body_parts[name]) {
      var body_part = this.body_parts[name]
      tp = body_part.GetPosition()
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (body_part.GetAngle()), 190, 190, "immunitas_glow", sprites.immunitasSprite)
    }
  }
}


BossOne.prototype.draw = function(context, draw_factor) {

  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return

  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
  context.save()
  if (this.dying)
      context.globalAlpha *= (1 - prog)
    else
      context.globalAlpha *= this.visibility ? this.visibility : 1

  this.draw_arm_piece(this.body_parts["lu"], context, draw_factor, "left")
  this.draw_arm_piece(this.body_parts["ru"], context, draw_factor, "right")
  this.draw_arm_piece(this.body_parts["ll"], context, draw_factor, "left")
  this.draw_arm_piece(this.body_parts["rl"], context, draw_factor, "right")
  this.draw_hand(this.body_parts["lh"], context, draw_factor, "left")
  this.draw_hand(this.body_parts["rh"], context, draw_factor, "right")

  var tp = this.body.GetPosition()
      if(this.knockback_red_duration > 0) {
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (this.body.GetAngle() + Math.PI/4), 64, 64, "immunitas_head_red", sprites.immunitasSprite)

    } else
      renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (this.body.GetAngle() + Math.PI/4), 64, 64, "immunitas_head", sprites.immunitasSprite)

  context.restore()

  this.additional_drawing(context, draw_factor)
}

BossOne.prototype.draw_special_attack_timer = function(context, draw_factor) {
  var prog = 1-(Math.max(this.lighten_timer, 0) / this.lighten_interval);

  context.beginPath()
  var distance = 106;
  var tp = {x: draw_factor *this.body.GetPosition().x, y: draw_factor * this.body.GetPosition().y}
  if(prog> 0) {
    context.moveTo(tp.x, tp.y - distance)
    context.lineTo(tp.x + Math.min(1, (prog)/.25) * distance, tp.y - distance + Math.min(1, (prog)/.25) * distance)

  }
  if(prog > .25) {
    context.moveTo(tp.x + distance, tp.y)
    context.lineTo(tp.x + distance - Math.min(1, (prog-.25)/.25) * distance, tp.y + Math.min(1, (prog-.25)/.25) * distance)

  }
  if(prog> 0.5) {
    context.moveTo(tp.x , tp.y + distance)
    context.lineTo(tp.x - Math.min(1, (prog-.5)/.25) * distance , tp.y  + distance - Math.min(1, (prog-.5)/.25) * distance)

  }
  if(prog> 0.75) {
    context.moveTo(tp.x - distance, tp.y)
    context.lineTo(tp.x - distance + Math.min(1, (prog-.75)/.25) * distance, tp.y - Math.min(1, (prog-.75)/.25) * distance)
  }

  context.lineWidth = 15;
  context.strokeStyle = constants.colors["boss 1"];
  context.stroke()

}

BossOne.prototype.draw_punching_explode_warning = function(ctx, draw_factor) {
  for(var i = 0; i < this.punching_explode_warning_parts; i++) {


    var angle = i/this.punching_explode_warning_parts * Math.PI * 2;
    renderUtils.drawSprite(ctx, this.body.GetPosition().x*draw_factor + (this.punching_explode_radius + 0.9)* draw_factor * Math.cos(angle),
      this.body.GetPosition().y*draw_factor + (this.punching_explode_radius + 0.9)* draw_factor * Math.sin(angle), angle, 70, 70, "immunitas_arrow",sprites.immunitasSprite)
    ctx.globalAlpha *= 0.8
    ctx.beginPath()
    ctx.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor,  this.punching_explode_radius* draw_factor,
      0, 2*Math.PI, false)
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.stroke()
    ctx.globalAlpha /= 0.8
  }
}

BossOne.prototype.additional_drawing = function(context, draw_factor) {

  if (this.dying) return

  context.save()
  if(this.punching_explode_timer != null) {
    if(this.punching_explode_timer < this.punching_explode_warning_interval) {
      context.beginPath()

      context.globalAlpha = (this.punching_explode_warning_interval - this.punching_explode_timer)/this.punching_explode_warning_interval * 0.7
      this.draw_punching_explode_warning(context, draw_factor)
    } else if(this.punching_explode_timer > this.punching_explode_interval - this.punching_explode_warning_interval/2 && this.punch_exploded) {
      context.beginPath()

      context.globalAlpha = (this.punching_explode_timer - (this.punching_explode_interval - this.punching_explode_warning_interval/2))/this.punching_explode_warning_interval/2 * 0.7
      this.draw_punching_explode_warning(context, draw_factor)
    }
    if(this.punching_explode_timer < this.punching_explode_shockwave_interval) {
      context.beginPath()
      var prog = (this.punching_explode_shockwave_interval - this.punching_explode_timer)/this.punching_explode_shockwave_interval
      context.arc(this.body.GetPosition().x *draw_factor, this.body.GetPosition().y * draw_factor, prog*(this.punching_explode_radius * draw_factor), 0, Math.PI * 2, false)
      globalAlpha = 0.7
      context.lineWidth = 4;
      context.strokeStyle = this.color
      context.stroke()
    }
  }
  context.restore()
}

BossOne.prototype.pre_draw = function(context, draw_factor) {
  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return
  context.save()
  if (this.dying) {
      var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
      context.globalAlpha *= (1 - prog)
  } else
      context.globalAlpha *= this.visibility ? this.visibility : 1
  this.draw_glows(context, draw_factor);
  this.draw_aura(context, draw_factor)
  if(this.lighten_timer >= 0) {
    this.draw_special_attack_timer(context, draw_factor)
  }

  context.globalAlpha *= 0.8;
  if(this.lighten_timer < 0 && this.lighten_timer >= -this.lighten_duration) {
    var gray = Math.min(5 - Math.abs((-this.lighten_timer - this.lighten_duration/2)/(this.lighten_duration/10)), 1)
    context.globalAlpha *= gray/2
    context.fillStyle = this.color
    context.fillRect(0, 0, constants.canvasWidth, constants.canvasHeight)
  }

  context.restore()
}

BossOne.prototype.move = function() {
  /*this.set_heading(this.player.get_current_position())*/
  var cur_angle = this.body.GetAngle();
  var player_angle =  utils.atan(this.body.GetPosition(), this.player.get_current_position());
  var angle_between = utils.smallAngleBetween(cur_angle, player_angle )
  var torque = Math.min(250, angle_between/Math.PI * 1000);

  if(utils.isAngleBetween(cur_angle - Math.PI, cur_angle, player_angle)) {

    this.body.SetAngle(this.body.GetAngle() - Math.PI/2000)
  } else {
    this.body.SetAngle(this.body.GetAngle() + Math.PI/2000)
  }
}

BossOne.prototype.collide_with = function(other, body) {
  if(this.dying || !this.spawned)//ensures the collision effect only activates once
    return
  if (other == this.player) {
    music_player.play_sound("b1hit")
    this.impulse_game_state.reset_combo();
  }
  if(body == this.body) {
    var boss_angle = utils.atan(this.body.GetPosition(),other.body.GetPosition())
    other.body.ApplyImpulse(new box_2d.b2Vec2(this.boss_force * 4 * Math.cos(boss_angle), this.boss_force * 4 * Math.sin(boss_angle)), other.body.GetWorldCenter())
  } else {
    var boss_angle = utils.atan(this.body.GetPosition(), other.body.GetPosition())
    // hit while punching
    var force = this.boss_force;
    if (this.lightened) {
      force *= 2
    }
    if(this.state == "punching") {
      force *= 1.5
    // hit while turret and not hands
    } else if(body != this.body_parts["lh"] && body != this.body_parts["rh"]){
      force *= 1.5
    // hit hands while turret
    } else if (other == this.player) {
      force *= 1.25
    } else {
      force = 0;
    }
    other.body.ApplyImpulse(new box_2d.b2Vec2(force *  Math.cos(boss_angle), force * Math.sin(boss_angle)), other.body.GetWorldCenter())
  }
}
BossOne.prototype.get_impulse_sensitive_pts = function() {
  var ans = []
  for(var i = 0; i < this.shape_points[0].length; i++) {
    var temp = this.body.GetPosition().Copy()
    temp.Add({x: this.shape_points[0][i].x * 0.6, y: this.shape_points[0][i].y * 0.6})
    ans.push(temp)
  }
  return ans
}

BossOne.prototype.global_lighten = function() {
  this.player.lighten(Math.round(this.lighten_duration))
  for(var i = 0; i < this.level.enemies.length; i++) {
    if(this.level.enemies[i].id != this.id)
      this.level.enemies[i].lighten(Math.round(this.lighten_duration))
  }
}

BossOne.prototype.player_hit_proc = function() {
  var boss_angle = utils.atan(this.body.GetPosition(), this.player.get_current_position())
  this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.boss_force * Math.cos(boss_angle), this.boss_force * Math.sin(boss_angle)), this.player.body.GetWorldCenter())
}

BossOne.prototype.check_impulse_on_hands = function(attack_loc, impulse_force, side) {

  var hand = null;
  if(side == "left")
    hand = this.body_parts["lh"];
  if(side == "right")
    hand = this.body_parts["rh"];
  var hand_point = hand.GetPosition()
    if(this.player.point_in_impulse_angle(hand_point))
    {

      if (this.player.point_in_impulse_dist(hand_point))
      {
        var angle = utils.atan(attack_loc, hand_point)//not sure if it should be this point
        this.paralyzed_pause[side] += this.action_timer[side]
        if(this.arm_states[side] == "loading")
          this.paralyzed_pause[side] += this.punch_action_interval
        this.arm_states[side] = "paralyzed"
        this.knockback_arm_timers[side] = this.knockback_arm_interval
      }
    }

}

BossOne.prototype.switch_to_punching = function() {
  this.state = "punching"
  this.move_arm_to_default("left", true)
  this.paralyzed_pause["left"] = 0
  this.paralyzed_pause["right"] = 0
  this.move_arm_to_default("right", true)
  this.max_punching_timer = this.max_punching_interval
  this.state_switch_timer = this.state_switch_interval

}

BossOne.prototype.switch_to_turret = function() {
  this.state = "turret"
  this.move_arm_to_turret("left")
  this.move_arm_to_turret("right")
  this.max_turret_timer = this.max_turret_interval
  this.state_switch_timer = this.state_switch_interval
  this.punch_target_pts["left"] = null
  this.punch_target_pts["right"] = null
  if(this.first_turret) {
    this.max_turret_timer *= 0.75
    this.first_turret = false
  }
}

BossOne.prototype.explode = function() {
  if(utils.pDist(this.body.GetPosition(), this.player.get_current_position()) <= this.punching_explode_radius)
  {
    var angle = utils.atan(this.body.GetPosition(), this.player.get_current_position())
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.punching_explode_force * Math.cos(angle),
     this.punching_explode_force * Math.sin(angle)), this.player.body.GetWorldCenter())
  }

  for(var i = 0; i < this.level.enemies.length; i++)
  {
    if(this.level.enemies[i] !== this && utils.pDist(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()) <= this.punching_explode_radius)
    {
      var _angle = utils.atan(this.body.GetPosition(), this.level.enemies[i].body.GetPosition())
      this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(this.punching_explode_force * Math.cos(_angle), this.punching_explode_force * Math.sin(_angle)), this.level.enemies[i].body.GetWorldCenter())
      if(this.level.enemies[i].type !== "tank") {
        this.level.enemies[i].open(1500)
      }
    }
  }
}

BossOne.prototype.get_impulse_extra_factor = function() {
  if(saveData.difficultyMode == "easy") {
    return this.impulse_extra_factor * 1.5;
  }
  return this.impulse_extra_factor;
}

module.exports = BossOne;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/boss.js":19,"../enemy/enemy_factory.js":31,"../load/save_data.js":69,"../render/sprites.js":81,"../render/utils.js":83,"../vendor/box2d.js":97}],24:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var enemyRenderUtils = require('../render/enemy.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var sprites = require('../render/sprites.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Boss = require('../enemy/boss.js');
var EnemyFactory = require('../enemy/enemy_factory.js');

BossThree.prototype = new Boss()

BossThree.prototype.constructor = BossThree

function BossThree(world, x, y, id, impulse_game_state) {

  this.type = "boss_three"

  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  this.death_radius = 5

  this.shoot_interval = 1500

  this.shoot_duration = 5

  this.do_yield = false

  this.safe = true

  this.spawned = false

  this.body.SetAngle(7 * Math.PI/16)

  this.visibility = 0

  this.red_visibility = 0

  this.knockback_red_duration = 0
  this.knockback_red_interval = 150

  this.boss_force = 200

  if (saveData.difficultyMode == "easy") {
    this.boss_force = 120
  }
  this.num_arms = 16
  this.striking_arms = {}
  this.strike_duration = 2200 // this is how long the strike lasts, with the first part of it being the "charge"
  if(saveData.difficultyMode == "easy") {
    this.strike_duration = 2800
  }
  this.strike_interval = 1500 // every interval, we add a new strike
  if(saveData.difficultyMode == "easy") {
    this.strike_interval = 2000
  }
  this.strike_timer = this.strike_interval
  this.strike_charging_prop = 0.7

  this.default_heading = false
  this.spin_rate = 16*this.strike_duration * (1 - this.strike_charging_prop)

  this.wheel_spinning_duration = 4000
  if (saveData.difficultyMode == "easy") {
    this.wheel_spinning_duration = 6000 // spin one more round on easy-mode
  }
  this.wheel_spinning_timer = this.wheel_spinning_duration
  this.wheel_default_skips = 16

  this.wheel_cur_index = 0

  this.wheel_state = "gap" // gap, fadein, spinning, activate, fadeout
  this.wheel_fade_duration = 1000
  this.wheel_fade_timer = this.wheel_fade_duration
  this.wheel_gap_interval = 2000
  this.wheel_gap_timer = this.wheel_gap_interval
  this.wheel_sections = 4
  this.wheel_radius = 4.3
  this.last_wheel_index_with_sound = -1

  this.wheel_activate_duration = 1000
  this.wheel_activate_timer = 0
  this.gap_activation_counter = 0
  this.gap_activation_threshold = 1000
  this.gap_activated = false

  this.strike_frenzy_duration = 4500
  this.strike_frenzy_timer = this.strike_frenzy_duration
  this.strike_frenzy_speedup = 0.8

  this.extra_gap = 0

  this.striking_state = "extend" // extend, striking, retract, gap
  this.strike_transition_interval = 500
  this.strike_transition_timer = this.strike_transition_interval
  this.default_strike_position = this.effective_radius + 2
  this.default_strike_range = 18
  this.target_arm_length = this.effective_radius

  this.wheel_visibility = 0

  this.wheel_sets = [
    ["harpoon", "spear", "tank", "mote"],
    ["fighter", "spear", "stunner", "mote"],
    ["troll", "disabler", "stunner", "mote"],
  ]

  this.current_wheel_set = this.generate_wheel_set()

  this.spawn_queue = []
  this.spawn_enemy_timer = 0;
  this.wheel_effect_activated = false

  this.spawn_enemy_intervals = {
    "stunner" : 150,
    "spear" : 200,
    "tank" : 200,
    "mote" : 200,
    "goo" : 200,
    "harpoon" : 200,
    "disabler" : 200,
    "fighter" : 200,
    "troll" : 200,
  }

  this.spawn_count = {
   "stunner" : 14,
   "spear" : 12,
   "tank" : 10,
   "mote" : 6,
   "goo" : 1,
   "harpoon" : 6,
   "disabler" : 1,
   "fighter" : 4,
   "troll" : 10,
 }

  if(saveData.difficultyMode == "easy") {
      this.spawn_count = {
       "stunner" : 6,
       "spear" : 5,
       "tank" : 3,
       "mote" : 5,
       "goo" : 1,
       "harpoon" : 3,
       "disabler" : 1,
       "fighter" : 2,
       "troll" : 5,
     }
  }

 this.spawn_force = {
  "stunner" : 25,
   "spear" : 18,
   "tank" : 200,
   "mote" : 10,
   "goo" : 200,
   "harpoon" : 400,
   "disabler" : 300,
   "fighter" : 400,
   "troll" : 20,
}

 this.spawn_gap = {
  "stunner" : 500,
  "spear" : 1000,
  "tank" : 2000,
  "mote" : 500,
  "goo" : 0,
  "harpoon" : 5000,
  "disabler" : 0,
  "fighter" : 5000,
  "troll" : 2000,
  "frenzy": 1000
}

this.silence_interval = 20000
this.silence_timer = this.silence_interval - 1
this.silence_duration = 7000
this.silenced = false
this.rotation_dir = -1
this.rotating = false

 this.initialize_arms()
}

BossThree.prototype.generate_wheel_set = function() {
  var tough_enemies = ["tank", "fighter", "troll", "harpoon"]
  var easy_enemies = ["stunner", "spear", "goo", "disabler"]
  var all_enemies = ["mote", "harpoon", "stunner", "spear", "goo", "disabler", "tank", "fighter", "troll"]

  if(this.level.enemies.length > 6) {
    easy_enemies.push("frenzy")
    all_enemies.push("frenzy")
  }

  var wheel_set = []
  var tough_enemies_index = Math.floor(Math.random() * tough_enemies.length)
  wheel_set.push(tough_enemies[tough_enemies_index])
  all_enemies.splice(all_enemies.indexOf(tough_enemies[tough_enemies_index]), 1)
  tough_enemies.splice(tough_enemies_index, 1)
  var tough_enemies_index2 = Math.floor(Math.random() * tough_enemies.length)
  wheel_set.push(tough_enemies[tough_enemies_index2])
  all_enemies.splice(all_enemies.indexOf(tough_enemies[tough_enemies_index2]), 1)
  var random_index = Math.floor(Math.random() * all_enemies.length)
  wheel_set.push(all_enemies[random_index])
  if(easy_enemies.indexOf(all_enemies[random_index])!= -1) {
    easy_enemies.splice(easy_enemies.indexOf(all_enemies[random_index]), 1)
  }
  var easy_enemies_index = Math.floor(Math.random() * easy_enemies.length)
  wheel_set.push(easy_enemies[easy_enemies_index])

  return wheel_set
}

BossThree.prototype.boss_specific_additional_processing = function(dt) {

    if(this.rotating) {
      if(this.rotation_dir % 2 == 0)
        this.body.SetAngle(this.body.GetAngle() + 2*Math.PI * dt/this.spin_rate)
      else if(this.rotation_dir % 2 == 1)
        this.body.SetAngle(this.body.GetAngle() - 2*Math.PI * dt/this.spin_rate)
    }

  if(saveData.difficultyMode == "normal") {
    if(this.silence_timer < 0 && !this.silenced && (this.wheel_state != "activate" && this.wheel_state != "fadeout" && this.wheel_state != "gap")) {
      this.silence_timer = 0;
      this.silenced = true
      this.global_silence()
      this.force_frenzy()
    }


    if(this.silenced && this.silence_timer < -this.silence_duration) {
        this.silenced = false
        this.silence_timer = this.silence_interval
    }

    this.silence_timer -= dt
  }

  if(this.striking_state == "extend") {
    this.strike_transition_timer -= dt

    var prog = Math.min(1 - this.strike_transition_timer/this.strike_transition_interval, 1)
    this.target_arm_length = this.effective_radius + prog * (this.default_strike_position - this.effective_radius)
    this.set_all_arms_length(this.target_arm_length)

    if(this.strike_transition_timer < 0) {
      if(this.silenced) {
        this.striking_state = "frenzy"
        this.strike_frenzy_timer = this.silence_timer + this.silence_duration
        this.strike_timer = 0
      } else {
        this.striking_state = "striking"
        this.rotating = true
        this.rotation_dir += 1
        this.strike_timer = 0
      }
    }
  } else if(this.striking_state == "striking") {
    this.process_striking_arms()
    if(utils.pDist(this.body.GetPosition(), this.player.get_current_position()) <= 15) {
      this.strike_timer -= dt
      if(this.strike_timer <= 0 && !(this.wheel_activate_timer > 0 && this.current_wheel_set[this.wheel_cur_index] == "frenzy")) {
        this.strike_timer = this.strike_interval
        this.strike_at_player()
      }
    } else {
      this.strike_timer -= dt
    }
  } else if(this.striking_state == "retract") {
    this.strike_transition_timer -= dt
    var prog = Math.max(this.strike_transition_timer/this.strike_transition_interval, 0)
    this.target_arm_length = this.effective_radius + prog * (this.default_strike_position - this.effective_radius)
    this.set_all_arms_length(this.target_arm_length)
    this.process_striking_arms()

    if(this.strike_transition_timer < 0) {
      this.striking_state = "gap"
    }

  } else if(this.striking_state == "gap") {
    this.process_striking_arms()
    //wait
  } else if(this.striking_state == "frenzy") {
    this.process_striking_arms()
    this.strike_timer -= dt
    this.strike_frenzy_timer -= dt
    if(this.strike_timer <= 0) {
      if(this.strike_frenzy_timer > this.strike_frenzy_speedup * this.strike_duration) {
        this.strike_timer = this.strike_interval * this.strike_frenzy_speedup
        this.strike_at_player()
      }
    }
    if(this.strike_frenzy_timer < 0) {
      this.striking_state = "striking"
      this.rotating = true
      this.rotation_dir += 1
      this.strike_timer = this.strike_interval
    }
  }

  if(this.wheel_state == "fadein") {
    this.wheel_cur_index = 0
    this.wheel_fade_timer -= dt
    this.wheel_visibility = Math.min(1 - this.wheel_fade_timer/this.wheel_fade_duration, 1)
    if(this.wheel_fade_timer <= 0) {
      this.wheel_state = "spinning"
      this.wheel_visibility = 1
      this.wheel_spinning_timer = this.wheel_spinning_duration
    }
  } else if(this.wheel_state == "spinning") {
    this.wheel_spinning_timer -= dt
    var prog = Math.pow(Math.min(1 - this.wheel_spinning_timer/this.wheel_spinning_duration, 1), 1)
    this.wheel_cur_index = Math.floor(prog * this.wheel_default_skips) % this.wheel_sections
    if (this.last_wheel_index_with_sound != this.wheel_cur_index) {
      // play the sound if it's the first time on this index
      this.last_wheel_index_with_sound = this.wheel_cur_index
      music_player.play_sound("b3tick")
    }

    if(this.wheel_spinning_timer <= 0) {
      this.activate_wheel()
    }
  } else if(this.wheel_state == "fadeout") {
    this.wheel_fade_timer -= dt
    this.wheel_visibility = Math.max(this.wheel_fade_timer/this.wheel_fade_duration, 0)
    if(this.wheel_fade_timer <= 0) {
      this.wheel_state = "gap"
      this.wheel_visibility = 0
      if(!this.silenced)
        this.wheel_gap_timer = this.spawn_gap[this.current_wheel_set[this.wheel_cur_index]] + this.extra_gap
      else
        this.wheel_gap_timer = this.silence_timer + this.silence_duration
      this.extra_gap = 0
      this.gap_activation_counter = 0
      this.gap_activated = false
      this.wheel_cur_index = null
    }
  } else if(this.wheel_state == "activate") {
    if(this.striking_state == "striking" && this.current_wheel_set[this.wheel_cur_index] != "frenzy") {
      this.striking_state = "retract"
      this.rotating = false
      this.strike_transition_timer = this.strike_transition_interval
      this.cancel_strikes()
    }
    if(this.wheel_activate_timer == this.wheel_activate_duration && this.current_wheel_set[this.wheel_cur_index] == "frenzy" && !this.wheel_effect_activated)
      this.cancel_strikes()
    this.wheel_activate_timer -= dt

    if(this.wheel_activate_timer < 0) {
      if(!this.wheel_effect_activated) {
        var type = this.current_wheel_set[this.wheel_cur_index];
        if(type != "frenzy") {
          for(var i = 0; i < this.spawn_count[type]; i++) {
            this.spawn_queue.push(type)
            this.wheel_activate_timer += this.spawn_enemy_intervals[type];
          }
        } else {
          this.striking_state = "frenzy"
          this.rotating = false
          this.strike_frenzy_timer = this.strike_frenzy_duration
          this.wheel_activate_timer += this.strike_frenzy_duration
          this.strike_timer = 0
        }
        this.wheel_effect_activated = true
      } else {
        this.wheel_state = "fadeout"
        this.wheel_fade_timer = this.wheel_fade_duration
        if(this.striking_state == "gap" &&  this.current_wheel_set[this.wheel_cur_index] != "frenzy") {
          this.striking_state = "extend"
          this.strike_transition_timer = this.strike_transition_interval
        }
      }
    }

  } else if(this.wheel_state == "gap") {
    this.wheel_gap_timer -= dt
    this.gap_activation_counter += dt
    if(this.wheel_gap_timer <= 0) {
      this.wheel_state = "fadein"
      this.wheel_fade_timer = this.wheel_fade_duration
      this.current_wheel_set = this.generate_wheel_set()
    }
  }

  if(this.spawn_queue.length > 0) {
    this.spawn_enemy_timer -= dt
    if(this.spawn_enemy_timer < 0) {
      this.spawn_this_enemy(this.spawn_queue[0])
      this.spawn_queue.splice(0, 1)
      this.spawn_enemy_timer = this.spawn_enemy_intervals[this.current_wheel_set[this.wheel_cur_index]]
    }
  }
  if(this.knockback_red_duration > 0) {
    this.knockback_red_duration -= dt
  }

  // Don't re-adjust the arms if dying, so they can explode out.
  if (!this.dying) {
    this.process_arm_polygons();
  }
}

BossThree.prototype.force_frenzy = function() {
  //get to a frenzy state as soon as possible given current wheel and strike state
  //obey fadeout/fadein/extend/retract
  if(this.wheel_state == "fadein") {
    this.wheel_fade_timer = this.wheel_fade_duration - this.wheel_fade_timer
    this.wheel_state = "fadeout"
    this.wheel_cur_index = null
  } else if(this.wheel_state == "spinning" || this.wheel_state == "activate") {
    this.wheel_fade_timer = this.wheel_fade_duration
    this.wheel_state = "fadeout"
    if(this.wheel_state == "spinning")
      this.wheel_cur_index = null
  } else if(this.wheel_state == "gap") {
    this.wheel_gap_timer = this.silence_timer + this.silence_duration
  }

  if(this.striking_state == "retract") {
    this.strike_transition_timer = this.strike_transition_interval - this.strike_transition_timer
    this.striking_state = "extend"
  } else if(this.striking_state == "gap") {
    this.strike_transition_timer = this.strike_transition_interval
    this.striking_state = "extend"
  } else if(this.striking_state == "striking") {
    this.cancel_strikes()
    this.striking_state = "frenzy"
    this.rotating = false
    this.strike_frenzy_timer = this.silence_timer + this.silence_duration
  } else if(this.striking_state == "frenzy") {
    this.strike_frenzy_timer = this.silence_timer + this.silence_duration
  }
  this.spawn_queue = []

}

BossThree.prototype.global_silence = function() {
  this.player.silence(Math.round(this.silence_duration))
  for(var i = 0; i < this.level.enemies.length; i++) {
    if(this.level.enemies[i].id != this.id)
      this.level.enemies[i].silence(Math.round(this.silence_duration), true, true)
  }
}

BossThree.prototype.process_arm_polygons = function() {
  // adjusts the arms bsaed on their current angle and the location/angle of the boss
  for(var index in this.striking_arms) {
    var data = this.striking_arms[index]
    data.body.SetAngle(this.body.GetAngle() + Math.PI/(this.num_arms/2) * index)


    data.body.SetPosition(this.body.GetPosition())
    data.body.GetFixtureList().m_shape.m_vertices[1] = {x: Math.cos(0) * data.cur_dist, y: Math.sin(0) * data.cur_dist}
    data.body.GetFixtureList().m_shape.m_vertices[2] = {x: Math.cos(Math.PI/8) * data.cur_dist, y: Math.sin(Math.PI/8) * data.cur_dist}
  }
}

BossThree.prototype.process_striking_arms = function() {
  for(var index in this.striking_arms) {
    var data = this.striking_arms[index]
    if(data.duration > 0) {
      data.duration -= dt
    }

    if(data.duration <= 0) {
      data.cur_dist = data.start_dist
    } else {
      var prog = 1 - data.duration/data.interval
      var arm_size = 0
      if(data.max_dist == null) {
        data.max_dist = utils.pDist(this.body.GetPosition(), this.player.get_current_position()) + 5
        if(data.max_dist < 20) data.max_dist += 10
      }

      var start_strike_t = data.charging_prop;
      var finish_strike_t = data.charging_prop + (1-data.charging_prop) * 0.3;
      var start_retract_t = data.charging_prop + (1-data.charging_prop) * 0.7;
      var finish_retract_t = 1;

      if (prog < start_strike_t) {
        arm_size = prog / start_strike_t;
        data.cur_dist = data.start_dist * (1 - arm_size) + (data.charge_dist) * (arm_size)
      } else if (prog >= start_strike_t && prog < finish_strike_t) {
        arm_size = (prog - start_strike_t) / (finish_strike_t - start_strike_t);
        arm_size = utils.bezierInterpolate(0.15, 0.85, arm_size);
        data.cur_dist = data.max_dist * (arm_size) + (data.charge_dist) * (1 - arm_size)
        if (!data.sound_played) {
          data.sound_played = true
          music_player.play_sound("b3strike")
        }
      } else if (prog >= finish_strike_t && prog < start_retract_t) {
        data.cur_dist = data.max_dist
      } else if (prog >= start_retract_t && prog < finish_retract_t) {
        arm_size = (prog - start_retract_t) / (finish_retract_t - start_retract_t);
        arm_size = utils.bezierInterpolate(0.15, 0.85, arm_size);
        if (arm_size > 0) {
          data.cur_dist = data.max_dist * (1 - arm_size) + (data.start_dist) * (arm_size)
        } else {
          data.cur_dist = data.start_dist
        }
      }
    }
  }
}

BossThree.prototype.set_all_arms_length = function(length) {
  for(var index in this.striking_arms) {
    var data = this.striking_arms[index]
    data.start_dist = length
    if(data.duration <= 0)
      data.cur_dist = length
  }
}

BossThree.prototype.cancel_strikes = function() {
  for(var index in this.striking_arms) {
    var data = this.striking_arms[index]
    if(data.duration > 0) {
      var prog = 1 - data.duration/data.interval
      if(prog < data.charging_prop)
        data.duration = 0
      else if(prog > data.charging_prop && prog < 0.5 * data.charging_prop + 0.5) {
        var mid_value = data.interval * (0.5 - data.charging_prop * 0.5)
        data.duration = 2 * mid_value - data.duration
      }
    }
  }
}

BossThree.prototype.strike_at_player = function() {

  if(this.striking_state == "striking") {
    var boss_angle = utils.atan(this.body.GetPosition(),this.player.get_current_position())
    var arm = Math.floor((boss_angle - this.body.GetAngle())/(Math.PI/8))
    while(arm < 0) {
      arm += this.num_arms
    }
    var dist = this.default_strike_range
    if(this.rotation_dir % 2 == 0)
      var choices = [arm-1, arm-3, arm-2]
    else
      var choices = [arm+3, arm+1, arm+2]
    for(var index = choices.length - 1; index >= 0; index--) {
      if(choices[index] >= this.num_arms) choices[index] -= this.num_arms
      if(choices[index] < 0) choices[index] += this.num_arms
      if(this.striking_arms[choices[index]].duration > 0) {
        choices.splice(index, 1)
      }
    }
    var index = Math.floor(Math.random() * choices.length)
    this.strike_with_arm(choices[index], dist, this.strike_duration)
  } else if(this.striking_state == "frenzy") {
    var boss_angle = utils.atan(this.body.GetPosition(),this.player.get_current_position())
    var arm = Math.floor((boss_angle - this.body.GetAngle())/(Math.PI/8))
    while(arm < 0) {
      arm += this.num_arms
    }
    var dist = null
    var choices = [arm-3, arm-2, arm-1, arm, arm+1, arm+2, arm+3, arm+4]
    var winnable = false
    for(var index = choices.length - 1; index >= 0; index--) {
      if(this.striking_arms[this.adjust_arm_index(choices[index])].duration > 0) {
        choices.splice(index, 1)
        if(index >= 2 && index <= 4) winnable = true
      }
    }

    if(!winnable) { // need to ban either arm-1, arm, or arm+1
      var banned_index = Math.floor(Math.random() * 3 - 1)
      choices.splice(choices.indexOf(arm+banned_index), 1)
    }

    var index = Math.floor(Math.random() * choices.length)
    this.strike_with_arm(choices[index], dist, this.strike_duration * this.strike_frenzy_speedup)
    choices.splice(index, 1)
    var index2 = Math.floor(Math.random() * choices.length)
    this.strike_with_arm(choices[index2], dist, this.strike_duration * this.strike_frenzy_speedup)
    choices.splice(index2, 1)

    if (choices.indexOf(arm) !== -1 && Math.random() < 0.5) {
      this.strike_with_arm(arm, dist, this.strike_duration * this.strike_frenzy_speedup);
    } else {
      var index3 = Math.floor(Math.random() * choices.length);
      this.strike_with_arm(choices[index3], dist, this.strike_duration * this.strike_frenzy_speedup);
    }


  }
}

BossThree.prototype.adjust_arm_index = function(index) {
  if(index >= this.num_arms) index -= this.num_arms
  if(index < 0) index += this.num_arms
    return index
}

BossThree.prototype.strike_with_arm = function(index, dist, duration) {

  if(!this.striking_index)
  this.striking_index = index

  index = this.adjust_arm_index(index)
  if(this.striking_arms[index].duration <= 0) {
    this.striking_arms[index].duration = duration
    this.striking_arms[index].interval = duration
    this.striking_arms[index].max_dist = dist
    this.striking_arms[index].start_dist = this.default_strike_position
    this.striking_arms[index].charge_dist = 0.8 * this.default_strike_position
    this.striking_arms[index].charging_prop = this.strike_charging_prop
    this.striking_arms[index].sound_played = false
  }
}

BossThree.prototype.initialize_arms = function() {
  for(var index = 0; index < this.num_arms; index++) {
    var arm_body =  utils.createBody(this.world, enemyData[this.type].arm_polygon, this.body.GetPosition().x, this.body.GetPosition().y, 3, 0.01, box_2d.BOSS_THREE_BIT, box_2d.PLAYER_BIT | box_2d.ENEMY_BIT, "static", this, null)
    arm_body.SetAngle(this.body.GetAngle() + Math.PI/(this.num_arms/2) * index)
    this.striking_arms[index] = {
      interval: this.strike_duration,
      duration: 0,
      max_dist: 0,
      cur_dist: this.effective_radius,
      body: arm_body,
      charging_prop: this.strike_charging_prop
    }
  }
}

BossThree.prototype.additional_death_prep_specific = function() {
  for(var index = 0; index < this.num_arms; index++) {
    // Need to recreate arms.
    var arm_body = utils.createBody(this.world, enemyData[this.type].arm_polygon, this.body.GetPosition().x,
    this.body.GetPosition().y, 3, 1, box_2d.BOSS_THREE_BIT, box_2d.PLAYER_BIT | box_2d.ENEMY_BIT, "dynamic", this, null)
    var angle = this.body.GetAngle() + Math.PI/(this.num_arms/2) * index;
    arm_body.SetAngle(angle);
    this.striking_arms[index].body = arm_body;
    var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
    dir.Normalize();
    dir.Multiply(10);
    arm_body.ApplyImpulse(dir, arm_body.GetWorldCenter())
  }
}

BossThree.prototype.get_impulse_sensitive_pts = function() {
  var ans = []
  for(var i = 0; i < this.shape_points[0].length; i++) {
    var temp = this.body.GetPosition().Copy()
    temp.Add({x: this.shape_points[0][i].x, y: this.shape_points[0][i].y})
    ans.push(temp)
  }
  return ans
}


BossThree.prototype.draw = function(context, draw_factor) {
  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) {
    return
  }

  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
  context.save()
  if (this.dying)
    context.globalAlpha *= (1 - prog)
  else
    context.globalAlpha *= this.visibility != null ? this.visibility : 1

  var tp = this.body.GetPosition()

  var arms_active = [];
  if(this.spawned) {
    for(var index in this.striking_arms) {
      if(this.striking_arms[index].duration > 0 || this.dying) {
        var tp = this.striking_arms[index].body.GetPosition()
        var angle = this.striking_arms[index].body.GetAngle()
        context.save()
        context.translate(tp.x * draw_factor, tp.y * draw_factor)
        context.rotate(angle + Math.PI/16)
        var v_dist = this.striking_arms[index].cur_dist * Math.sin(Math.PI/16) * 2
        var h_dist = this.striking_arms[index].cur_dist * Math.cos(Math.PI/16)
        var armSpriteName = this.knockback_red_duration > 0 ? "negligentia_arm_striking_red" : "negligentia_arm_striking"
        renderUtils.drawSprite(context, h_dist/2 * draw_factor, 0, 0,
                  h_dist * draw_factor,v_dist * draw_factor, armSpriteName, sprites.negligentiaSprite)
        context.restore()
        arms_active.push(index);
      }
    }
  }

  context.save();
  context.beginPath();
  var tp = this.body.GetPosition()
  var cur_radius = this.target_arm_length * draw_factor;
  if (arms_active.indexOf("0") !== -1) {
    cur_radius = this.target_arm_length * draw_factor * 0.8;
  }
  var angle = this.body.GetAngle();
  context.moveTo(tp.x * draw_factor + cur_radius * Math.cos(angle), tp.y * draw_factor + cur_radius * Math.sin(angle));
  for (var i = 0; i < this.num_arms; i++) {
    var j = (i + 1) % this.num_arms;
    context.lineTo(tp.x * draw_factor + cur_radius * Math.cos(j * 2 * Math.PI / this.num_arms + angle),
      tp.y * draw_factor + cur_radius * Math.sin(j * 2 * Math.PI / this.num_arms + angle));
    var next_radius = this.target_arm_length * draw_factor;
    if (arms_active.indexOf("" + j) !== -1) {
      next_radius = this.target_arm_length * draw_factor * 0.8
    }
    if (next_radius != cur_radius) {
      context.lineTo(tp.x * draw_factor + next_radius * Math.cos(j * 2 * Math.PI / this.num_arms + angle),
        tp.y * draw_factor + next_radius * Math.sin(j * 2 * Math.PI / this.num_arms + angle));
      cur_radius = next_radius;
    }
  }
  context.closePath();
  context.clip();


  if(this.spawned) {
    if(this.striking_state == "extend" || this.striking_state == "retract") {
      var tp = this.body.GetPosition()
      renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/16), this.target_arm_length * draw_factor * 2, this.target_arm_length * draw_factor * 2, "negligentia_arm_ring", sprites.negligentiaSprite)
    } else if(this.striking_state == "striking" || this.striking_state == "frenzy") {
      var tp = this.body.GetPosition()
      renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/16), this.default_strike_position* draw_factor * 2, this.default_strike_position * draw_factor * 2, "negligentia_arm_ring", sprites.negligentiaSprite)
    }
  }
  context.restore();

  if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/16), this.effective_radius * 2 * draw_factor, this.effective_radius * 2 * draw_factor, "negligentia_head_red", sprites.negligentiaSprite)
  } else {
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/16), this.effective_radius * 2 * draw_factor, this.effective_radius * 2 * draw_factor, "negligentia_head", sprites.negligentiaSprite)
  }

  this.additional_drawing(context, draw_factor)

  context.restore()
}

BossThree.prototype.draw_glows = function(context, draw_factor) {

  var tp = this.body.GetPosition()
  if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor,
    tp.y*draw_factor,
    (this.body.GetAngle()), 300, 300, "negligentia_glow_red", sprites.negligentiaSprite)
  } else {
    renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (this.body.GetAngle()), 300, 300, "negligentia_glow", sprites.negligentiaSprite)
  }
}



BossThree.prototype.pre_draw = function(context, draw_factor) {
  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) {
    return
  }
  context.save()
  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0

  if (this.dying) {
      context.globalAlpha *= (1 - prog)
  } else {
    context.globalAlpha *= this.visibility != null ? this.visibility : 1
  }

  if(this.silenced && this.silence_timer < 0 && this.silence_timer >= -this.silence_duration) {
    context.save()
    var gray = Math.min(5 - Math.abs((-this.silence_timer - this.silence_duration/2)/(this.silence_duration/10)), 1)
    context.globalAlpha *= gray/2
    context.fillStyle = this.color
    context.fillRect(0, 0, constants.canvasWidth, constants.canvasHeight)
    context.restore()
  }

  this.draw_glows(context, draw_factor);

  if (!this.silenced)
    context.globalAlpha *= 0.4
  for(var i = 0; i < 16; i++) {
    var tp = this.body.GetPosition()
    var angle = 2 * Math.PI * (i/16 + 1/32 - 1/4);

    if(1 - this.silence_timer/this.silence_interval > 1-i/16 && (i != 0 || this.silenced)) {
      context.globalAlpha *= 2
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*this.effective_radius * 1.8) * draw_factor,
      (tp.y+Math.sin(angle) *this.effective_radius * 1.8) * draw_factor,
      angle + Math.PI/2, 30, 50, "negligentia_aura", sprites.negligentiaSprite)
      context.globalAlpha /= 2

    } else {
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*this.effective_radius * 1.8) * draw_factor,
      (tp.y+Math.sin(angle) *this.effective_radius * 1.8) * draw_factor,
      angle + Math.PI/2, 30, 50, "negligentia_aura_open", sprites.negligentiaSprite)
    }

  }
  context.restore()
}

BossThree.prototype.additional_drawing = function(context, draw_factor) {

  context.save()
  context.globalAlpha *= this.wheel_visibility

  if(this.wheel_state == "fadein" || this.wheel_state == "spinning" || this.wheel_state == "fadeout" || this.wheel_state == "activate") {
    var wheel_sprite = this.knockback_red_duration > 0 ? "negligentia_wheel_red" : "negligentia_wheel"
    if(this.wheel_state == "fadeout" || this.wheel_state == "activate") {
      wheel_sprite = "negligentia_wheel_complete"
    }
    // fill the current wheel

    var wheel_angle = (this.body.GetAngle() + Math.PI/16) + Math.PI/4
    var angle = Math.PI/(this.wheel_sections/2) * (this.wheel_cur_index +0.5)+ wheel_angle
    renderUtils.drawSprite(context, this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor, wheel_angle + Math.PI/2 * ((this.wheel_cur_index + 1 )% 4),
        2 * this.wheel_radius * Math.cos(Math.PI/4)*draw_factor, 2 * this.wheel_radius * Math.cos(Math.PI/4)*draw_factor, wheel_sprite, sprites.negligentiaSprite)


    if(this.wheel_state == "fadein" || this.wheel_state == "spinning") {

      for(var i = 0; i < this.wheel_sections; i++) {
        var angle = Math.PI/(this.wheel_sections/2) * (i+0.5) + wheel_angle
        if(this.current_wheel_set[i] != "frenzy") {
          enemyRenderUtils.drawEnemy(context, this.current_wheel_set[i], this.body.GetPosition().x * draw_factor + Math.cos(angle + Math.PI/(this.wheel_sections/2)/2) * this.wheel_radius * 0.4 * draw_factor,
            this.body.GetPosition().y * draw_factor + Math.sin(angle + Math.PI/(this.wheel_sections/2)/2) * this.wheel_radius * 0.4 * draw_factor, 15, angle + Math.PI*1/4)
        } else {
          uiRenderUtils.drawTessellationSign(context, 3, this.body.GetPosition().x * draw_factor + Math.cos(angle + Math.PI/(this.wheel_sections/2)/2) * this.wheel_radius * 0.4 * draw_factor,
            this.body.GetPosition().y * draw_factor + Math.sin(angle + Math.PI/(this.wheel_sections/2)/2) * this.wheel_radius * 0.4 * draw_factor, 20, true,angle)

        }
      }
    } else if(this.wheel_state == "fadeout" || this.wheel_state == "activate") {
      if(this.wheel_cur_index != null) { // will be null if forcing frenzy
        if(this.current_wheel_set[this.wheel_cur_index] != "frenzy") {
          enemyRenderUtils.drawEnemy(context, this.current_wheel_set[this.wheel_cur_index], this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor, 20, angle + Math.PI*1/4)
        } else {
          uiRenderUtils.drawTessellationSign(context, 3, this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor, 50, true, angle)
        }
      }
    }
  }
  context.restore()

}

BossThree.prototype.draw_special_attack_timer = function(context, draw_factor) {
  context.beginPath()
  var special_prop = Math.min(1 - this.silence_timer / this.silence_interval, 1)
  context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor,
    (this.effective_radius*draw_factor) * 1.5, -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * special_prop * 0.999)
  context.strokeStyle = this.color
  context.lineWidth = 2
  context.stroke()
}

BossThree.prototype.spawn_this_enemy = function(enemy_type) {
  var angle = utils.atan(this.body.GetPosition(), this.player.get_current_position());

  var spread = 0;

  if(enemy_type == "stunner" && Math.random() < 0.7)
    spread = Math.PI/4;
  if(enemy_type == "spear" && Math.random() < 0.7)
    spread = Math.PI/8;
  if((enemy_type == "tank") && Math.random() < 0.9)
    spread = Math.PI;
  if((enemy_type == "mote") && Math.random() < 0.7)
    spread = Math.PI;
  if((enemy_type == "troll") && Math.random() < 0.7)
    spread = Math.PI;
  if((enemy_type == "harpoon"))
    spread = Math.PI * 0.5;
  if((enemy_type == "fighter") && Math.random() < 0.5)
    spread = Math.PI * 0.5;

  if (spread != 0) {
    angle += Math.random() * spread - spread / 2;
  }

  var spawn_loc = {x: (this.body.GetPosition().x + Math.cos(angle) * this.effective_radius * 1.35)* constants.drawFactor,
    y: (this.body.GetPosition().y + Math.sin(angle) * this.effective_radius * 1.35)* constants.drawFactor}

  var new_enemy = new (EnemyFactory.getEnemyClassFromType(enemy_type))(this.world, spawn_loc.x/constants.drawFactor, spawn_loc.y/constants.drawFactor, this.level.enemy_counter, this.impulse_game_state)
  var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
  dir.Multiply(this.spawn_force[enemy_type])
  new_enemy.body.ApplyImpulse(dir, new_enemy.body.GetWorldCenter())
  new_enemy.set_heading(angle);
  this.level.spawned_enemies.push(new_enemy)
  this.level.enemy_counter += 1
  // disable initial silence.
  new_enemy.entered_arena = true;
  new_enemy.recovery_timer = 0;


  new_enemy.pathfinding_counter = 2 * new_enemy.pathfinding_delay //immediately look for path
  new_enemy.entered_arena_delay = 0
  new_enemy.entered_arena_timer = 0
  if(enemy_type == "harpoon") {
    new_enemy.silence(500, true)
  }
}



BossThree.prototype.collide_with = function(other, body) {
  if(this.dying || !this.spawned)//ensures the collision effect only activates once
    return
  if (other === this.player) {
    this.impulse_game_state.reset_combo();
  }
  if(body !== this.body) {
    for(var index in this.striking_arms) {
      var data = this.striking_arms[index]
      var prog = 1 - data.duration/data.interval
      if(data.body == body) {
        if((prog > data.charging_prop && prog < data.charging_prop + (1-data.charging_prop) * 0.3) || prog >= 1 || prog < data.charging_prop) {
          var boss_angle = utils.atan(this.body.GetPosition(), other.body.GetPosition())
          if(other === this.player) {
            var _this = this;
            other.body.ApplyImpulse(new box_2d.b2Vec2(_this.boss_force * Math.cos(boss_angle), _this.boss_force * Math.sin(boss_angle)), other.body.GetWorldCenter())
            this.impulse_game_state.reset_combo();
          } else if(other.type == "harpoonhead") {
            other.body.ApplyImpulse(new box_2d.b2Vec2(this.spawn_force["harpoon"] * Math.cos(boss_angle), this.spawn_force["harpoon"] * Math.sin(boss_angle)), other.body.GetWorldCenter())
          } else {
            if(this.spawn_force[other.type] != undefined)
              var enemy_data = enemyData[other.type]
              if (enemy_data) {
                var force = other.body.GetMass() * Math.sqrt(enemy_data.lin_damp) * this.boss_force
                other.body.ApplyImpulse(new box_2d.b2Vec2(force * Math.cos(boss_angle), force * Math.sin(boss_angle)), other.body.GetWorldCenter())

              }
          }
        }
      }
    }
  } else {
    var boss_angle = utils.atan(this.body.GetPosition(),other.body.GetPosition())
    var factor = 1
    if(other === this.player && saveData.difficultyMode == "easy") {
      factor = 0.5
    }
    other.body.ApplyImpulse(new box_2d.b2Vec2(this.boss_force * factor * Math.cos(boss_angle), this.boss_force * factor * Math.sin(boss_angle)), other.body.GetWorldCenter())
  }
}

BossThree.prototype.activate_wheel = function() {
  this.wheel_state = "activate"
  this.wheel_activate_timer = this.wheel_activate_duration
  this.wheel_effect_activated = false
  music_player.play_sound("b3select")
}

BossThree.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.knockback_red_duration = this.knockback_red_interval
  if(this.wheel_state == "spinning") {
    this.activate_wheel()
    this.extra_gap = this.wheel_spinning_timer
  }
}

BossThree.prototype.get_impulse_extra_factor = function() {
  if(saveData.difficultyMode == "easy") {
    return this.impulse_extra_factor * 1.5;
  }
  return this.impulse_extra_factor;
}

module.exports = BossThree;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/boss.js":19,"../enemy/enemy_factory.js":31,"../load/save_data.js":69,"../render/enemy.js":74,"../render/sprites.js":81,"../render/ui.js":82,"../render/utils.js":83,"../vendor/box2d.js":97}],25:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var sprites = require('../render/sprites.js');
var utils = require('../core/utils.js');

var Boss = require('../enemy/boss.js');
var BossTwoSpawner = require('../enemy/boss_two_spawner.js');

BossTwo.prototype = new Boss()

BossTwo.prototype.constructor = BossTwo

function BossTwo(world, x, y, id, impulse_game_state) {
  this.type = "boss_two"

  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  this.death_radius = 5

  this.do_yield = false

  this.gateway_particles = []
  this.gateway_particle_gen_interval = 1000
  this.gateway_particle_gen_timer = this.gateway_particle_gen_interval
  this.gateway_particle_duration = 2000
  this.gateway_particles_per_round = 8

  this.safe = true

  this.arm_core_angle = Math.PI * 3/4
  this.arm_width_angle_min = Math.PI * 3/16
  if (saveData.difficultyMode == "easy") {
    this.arm_width_angle_min = Math.PI * 5/32
  }
  this.arm_width_angle_max = Math.PI * 1/2
  this.arm_width_angle = this.arm_width_angle_min
  this.arm_width_angle_transition_rate = Math.PI * 1/8
  this.arm_length = 50
  this.arm_taper = .9
  this.num_arms = 4

  this.absorbed_enemy_types = [];


  this.arm_full_rotation = 15000

  this.spawned = false

  this.body.SetAngle(this.arm_core_angle)

  this.default_heading = false

  this.spin_rate = this.arm_full_rotation

  this.visibility = 0

  this.black_hole_interval = 13500
  this.black_hole_timer = this.black_hole_interval - 1
  this.black_hole_duration = 2000
  this.black_hole_radius = 0
  this.black_hole_force = 10
  this.black_hole_player_factor = 1
  this.black_hole_switch_time = 1000
  this.black_hole_expand_prop = 0.9
  this.black_hole_sound_played = false

  this.knockback_red_interval = 150
  this.knockback_red_duration = 0

  this.player_gravity_force = 0

  this.red_visibility = 0

  this.spawned_harpoons = false

  //this.high_gravity_factor = 1.25//.25
  this.high_gravity_factor = 2.5//1.5
  this.low_gravity_factor = 4//3

  this.boss_high_gravity_force = 0.9
  this.boss_low_gravity_force = .3
  this.boss_beam_gravity_force = 1.2
  // In easy mode, the player is heavier. Need to make boss stronger, else it's just too easy.
  if (saveData.difficultyMode == "easy") {
    this.boss_high_gravity_force *= 1.5
    this.boss_low_gravity_force *= 1.5
    this.boss_beam_gravity_force *= 1.5
  }

  this.spawn_spawners = false
  this.spawners = []

  this.growth_factor = 1

  this.last_growth_factor = 1

  this.transition_rate = 0.2

  this.growth_on_enemy = 0.125

  this.shrink_rate = 0.025

  this.enemy_spawn_interval = 12000
  if (saveData.difficultyMode == "easy") {
    this.enemy_spawn_interval = 12000
  }
  this.enemy_spawn_duration = 2000

  this.spawn_sets = [
    ["stunner", "tank"],
    ["harpoon", "spear"],
    ["mote", "goo"]
  ]

  if (saveData.difficultyMode == "normal") {
    this.spawn_sets = [
      ["stunner", "stunner", "tank", "goo"],
      ["harpoon", "spear", "spear", "tank"],
      ["mote", "goo", "tank", "harpoon"]
    ]
  }

  this.enemy_gravity_factor = {
    "stunner": 0.4,
    "spear": 0.4,
    "tank": 2,
    "mote": 0.2,
    "goo": 2.5,
    "harpoon": 2
  }

  this.player_struck = false
  this.enemies_struck = []

  this.spawn_pattern_counter = 0


}

BossTwo.prototype.adjust_size = function() {

  var fixtures = this.body.GetFixtureList()
  if (fixtures.length === undefined) {
    fixtures = [fixtures]
  }

  for(var i = 0; i < fixtures.length; i++) {
    var vertices = this.body.GetFixtureList().m_shape.m_vertices
    var polygon = this.shape_polygons[i]

    for(var j = 0; j < vertices.length; j++)
    {
      vertices[j] = new box_2d.b2Vec2(polygon.x + (polygon.r * polygon.vertices[j][0]) * this.last_growth_factor,
        polygon.y + polygon.r * polygon.vertices[j][1] * this.last_growth_factor)
    }

  }
  this.body.ResetMassData()
}

BossTwo.prototype.boss_specific_additional_processing = function(dt) {

  // spawn spawners if necessary
  if(!this.spawn_spawners) {
    this.spawn_spawners = true
    var spawner_buffer = 80
    var locs = [[constants.levelWidth - spawner_buffer, constants.levelHeight - spawner_buffer],
      [spawner_buffer, spawner_buffer]]
    if (saveData.difficultyMode == "normal") {
      locs = [
        [spawner_buffer, spawner_buffer],
        [constants.levelWidth - spawner_buffer, spawner_buffer],
        [constants.levelWidth - spawner_buffer, constants.levelHeight - spawner_buffer],
        [spawner_buffer, constants.levelHeight - spawner_buffer]
      ];
    }
    for(var i = 0; i < locs.length; i++) {
      var new_spawner = new BossTwoSpawner(locs[i][0], locs[i][1], this, this.impulse_game_state)
      new_spawner.spawn_duration = i/locs.length * new_spawner.spawn_interval
      this.spawners.push(new_spawner)
    }
  }

  if(this.spawn_duration > 0) {
    this.spawn_duration = Math.max(this.spawn_duration - dt, 0)
    this.visibility = 1 - this.spawn_duration / this.spawn_interval
    return
  }
  else if(this.spawned == false){
    this.spawned = true
    this.visibility = 1
    this.body.SetLinearDamping(enemyData[this.type].lin_damp)

  }
  this.body.SetAngle(this.arm_core_angle)

  if(this.knockback_red_duration > 0) {
    this.knockback_red_duration -= dt
  }
  // get spawners to spawn enemys simultaneously in a pattern
  this.enemy_spawn_duration -= dt
  if(this.enemy_spawn_duration < 0) {
    this.enemy_spawn_duration = this.enemy_spawn_interval

    for (var i = 0; i < this.spawners.length; i++) {
      this.spawners[i].spawn_enemies(this.spawn_sets[this.spawn_pattern_counter][i])
    }
    this.spawn_pattern_counter += 1
    this.spawn_pattern_counter = this.spawn_pattern_counter % this.spawn_sets.length
  }

  if(this.growth_factor > 1) {
    this.growth_factor = Math.max(1, this.growth_factor - dt/1000 * this.shrink_rate)
  }

  if(this.last_growth_factor != this.growth_factor) {
    if(this.last_growth_factor < this.growth_factor) {
      this.last_growth_factor = Math.min(this.last_growth_factor + this.transition_rate * dt/1000,this.growth_factor)
    } else {
      this.last_growth_factor = Math.max(this.last_growth_factor - this.transition_rate * dt/1000,this.growth_factor)
    }
    this.adjust_size()
  }
  this.process_gateway_particles(dt);

  var target_arm_width_angle = this.get_target_arm_width_angle()
  if(this.arm_width_angle != target_arm_width_angle) {
    if(this.arm_width_angle < target_arm_width_angle) {
      this.arm_width_angle = Math.min(this.arm_width_angle + this.arm_width_angle_transition_rate * dt/1000, target_arm_width_angle)
    } else {
      this.arm_width_angle = Math.max(this.arm_width_angle - this.arm_width_angle_transition_rate * dt/1000, target_arm_width_angle)
    }
  }

  for(var index in this.spawners) {
    this.spawners[index].process(dt)
  }

  if(this.small_exploding) {
    if(this.small_exploding_duration < 0) {

      this.small_exploding = false

    }
    else {
      this.small_exploding_duration -= dt
    }
  }

  this.arm_core_angle += Math.PI * 2 * dt / (this.arm_full_rotation / this.last_growth_factor)

  for(var i = 0; i < this.level.enemies.length; i++) {
    if (this.level.enemies[i].id == this.id) continue
    var boss_angle = utils.atan(this.level.enemies[i].body.GetPosition(), this.body.GetPosition())

    var gravity_force = this.enemy_gravity_factor[this.level.enemies[i].type] * this.get_gravity_force(this.level.enemies[i].body.GetPosition(), true)

    if(gravity_force > 0)
      this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(gravity_force * Math.cos(boss_angle), gravity_force * Math.sin(boss_angle)), this.level.enemies[i].body.GetWorldCenter())
  }

  this.player_gravity_force = 0
  var boss_angle = utils.atan(this.player.get_current_position(), this.body.GetPosition())

  var gravity_force = this.get_gravity_force(this.player.get_current_position())

  if(gravity_force > 0) {
    this.player_gravity_force += gravity_force
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(gravity_force *  Math.cos(boss_angle), gravity_force * Math.sin(boss_angle)), this.player.body.GetWorldCenter())
  }


  if (saveData.difficultyMode == "normal") {
    if(this.black_hole_timer < 0) {
      if (!this.black_hole_sound_played) {
        this.black_hole_sound_played = true
        music_player.play_sound("b2bhole")
      }
      var prop = -this.black_hole_timer/this.black_hole_duration
      if(prop < this.black_hole_expand_prop)
        this.black_hole_radius = this.effective_radius * (this.last_growth_factor * this.low_gravity_factor * (prop/this.black_hole_expand_prop))
      else
        this.black_hole_radius = this.effective_radius * (this.last_growth_factor * this.low_gravity_factor * (1 - (prop-this.black_hole_expand_prop)/(1-this.black_hole_expand_prop)))
      //this.black_hole()
    }
    if(this.black_hole_timer < -this.black_hole_duration) {
      this.black_hole_timer = this.black_hole_interval
      this.black_hole_radius = 0
      this.player_struck = false
      this.enemies_struck = []
      this.black_hole_sound_played = false
    }
    this.black_hole_timer -= dt
  }
}

// Returns the target arm_width_angle. Since we transition, the actual arm_width_angle may be off slightly.
BossTwo.prototype.get_target_arm_width_angle = function() {
  return this.arm_width_angle_min + Math.min(1, (this.growth_factor - 1) / 2) * (this.arm_width_angle_max - this.arm_width_angle_min);
}

BossTwo.prototype.get_black_hole_force = function(loc, is_enemy) {
  var black_hole_factor = 5

  if(-this.black_hole_timer/this.black_hole_duration < this.black_hole_expand_prop) {
    black_hole_factor = 0.12
  }

  if(utils.pDist(this.body.GetPosition(), loc) <= this.effective_radius * this.low_gravity_factor)
  {
    black_hole_force = this.black_hole_force * black_hole_factor
    if (!is_enemy) {
      black_hole_force *= this.black_hole_player_factor;
    }

  } else {
    black_hole_force = -1
  }

  return black_hole_force;
}

BossTwo.prototype.get_gravity_force = function(loc, is_enemy) {
  if (this.black_hole_timer < 0) {
    // Check if the black hole force applies. If so, return it.
    var black_hole_force = this.get_black_hole_force(loc, is_enemy);
    if (black_hole_force !== -1) {
      return black_hole_force
    }
  }
  var dist =  utils.pDist(loc, this.body.GetPosition())
  var polygons = this.get_arm_polygons()
  var inside = false
  var gravity_force = 0;
  for(var j = 0; j < polygons.length; j++) {
    if(utils.pointInPolygon(polygons[j], loc)) {
      gravity_force += this.boss_beam_gravity_force;
      break;
    }
  }
  if (dist <= this.effective_radius * this.last_growth_factor * this.high_gravity_factor) {
    gravity_force += this.boss_high_gravity_force
  }
  else if (dist <= this.effective_radius * this.last_growth_factor * this.low_gravity_factor) {
    gravity_force += this.boss_low_gravity_force
  }

  if (is_enemy) {
    gravity_force *= 0.3;
  }
  return gravity_force;
}
BossTwo.prototype.pre_draw = function(context, draw_factor) {
  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return
  context.save()
  if (this.dying) {
      var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
      context.globalAlpha *= (1 - prog)
  } else
      context.globalAlpha *= this.visibility ? this.visibility : 1

  if(this.black_hole_timer < 0 && this.black_hole_timer >= -this.black_hole_duration) {
    context.globalAlpha *= 0.5;
    var gray = Math.min(5 - Math.abs((-this.black_hole_timer - this.black_hole_duration/2)/(this.black_hole_duration/10)), 1)
    context.globalAlpha *= gray/2
    context.fillStyle = this.color
    context.fillRect(0, 0, constants.canvasWidth, constants.canvasHeight)
    context.globalAlpha *= 2
  }


  if(this.black_hole_timer < 0 && this.black_hole_timer >= -this.black_hole_duration) {
    var tp = this.body.GetPosition()

    if(-this.black_hole_timer/this.black_hole_duration < this.black_hole_expand_prop) {
      renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor,
      0, this.black_hole_radius * draw_factor * 2, this.black_hole_radius * draw_factor * 2, "consumendi_aura", sprites.consumendiSprite)
    } else {
      renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor,
      0, this.black_hole_radius * draw_factor * 2, this.black_hole_radius * draw_factor * 2, "consumendi_aura", sprites.consumendiSprite)
    }
  }

  var aura_factor = 1
  if(this.black_hole_timer >= this.black_hole_interval  - this.black_hole_switch_time) {
    aura_factor = 1 - (this.black_hole_timer - this.black_hole_interval  + this.black_hole_switch_time) / this.black_hole_switch_time
  } else if(this.black_hole_timer <= this.black_hole_switch_time && this.black_hole_timer > 0) {
    aura_factor = this.black_hole_timer / this.black_hole_switch_time
  }

  var tp = this.body.GetPosition()
  if(this.black_hole_timer > 0) {
    context.save();
    context.globalAlpha *= 0.7;
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor,
    0, 90 * aura_factor * this.last_growth_factor * this.high_gravity_factor, 90 * aura_factor *this.last_growth_factor * this.high_gravity_factor, "consumendi_aura", sprites.consumendiSprite)
    context.restore();
  }

  context.save()

  context.globalAlpha *= 0.7
  for(var i = 0; i < 16; i++) {
    var angle = 2 * Math.PI * (i/16 + 1/32 - 1/4);
    if(this.spawned && 1 - this.black_hole_timer/ this.black_hole_interval > 1-i/16) {
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*this.effective_radius * this.last_growth_factor * this.low_gravity_factor) * draw_factor,
      (tp.y+Math.sin(angle) * this.effective_radius * this.last_growth_factor * this.low_gravity_factor) * draw_factor,
      angle, 30, 56, "consumendi_small_diamond_filled", sprites.consumendiSprite)

    } else {
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*this.effective_radius * this.last_growth_factor * this.low_gravity_factor) * draw_factor,
      (tp.y+Math.sin(angle) * this.effective_radius * this.last_growth_factor * this.low_gravity_factor) * draw_factor,
      angle, 30, 56, "consumendi_small_diamond", sprites.consumendiSprite)
    }
  }
  context.restore()

  this.draw_glows(context, draw_factor)

  this.draw_gateway_particles(context, draw_factor);
  context.restore()
}


BossTwo.prototype.draw = function(context, draw_factor) {

  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return


  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
  context.save()
  if (this.dying)
      context.globalAlpha *= (1 - prog)
    else
      context.globalAlpha *= this.visibility != null ? this.visibility : 1

  var tp = this.body.GetPosition()

  if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/4), 90 * this.last_growth_factor, 90 * this.last_growth_factor, "consumendi_head_red", sprites.consumendiSprite)
  } else {
    renderUtils.drawSprite(context, tp.x*draw_factor, tp.y*draw_factor, (this.body.GetAngle() + Math.PI/4), 90 * this.last_growth_factor, 90 * this.last_growth_factor, "consumendi_head", sprites.consumendiSprite)
  }
  this.additional_drawing(context, draw_factor)

  context.restore()
}

BossTwo.prototype.additional_death_prep_specific = function() {
  if (this.absorbed_enemy_types.length == 0) return;
  // Spawn exactly 10 fragments, generated from the array.
  for (var i = 0; i < 10; i++) {
    var type = this.absorbed_enemy_types[Math.floor(this.absorbed_enemy_types.length / 10 * i)];
    var angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition()) + (Math.random() - 0.5) * 2 * Math.PI;
    var dir = new box_2d.b2Vec2(Math.cos(angle), Math.sin(angle));
    dir.Normalize();
    dir.Multiply(100);
    this.level.add_fragments(type, this.body.GetPosition(), dir);

  }
}

BossTwo.prototype.draw_glows = function(context, draw_factor) {

  var tp = this.body.GetPosition()
  if(this.knockback_red_duration > 0) {
    renderUtils.drawSprite(context, tp.x*draw_factor,
    tp.y*draw_factor,
    (this.body.GetAngle()), 200 * this.last_growth_factor, 200 * this.last_growth_factor, "immunitas_red_glow", sprites.immunitasSprite)
  } else {
    renderUtils.drawSprite(context, tp.x*draw_factor,
      tp.y*draw_factor,
      (this.body.GetAngle()), 200 * this.last_growth_factor, 200 * this.last_growth_factor, "consumendi_glow", sprites.consumendiSprite)
  }
}

BossTwo.prototype.additional_drawing = function(context, draw_factor) {

  for(var index in this.spawners) {
    this.spawners[index].draw(context, draw_factor, (Math.max(this.enemy_spawn_duration, 0) / this.enemy_spawn_interval), this.spawn_sets[this.spawn_pattern_counter][index])

  }

  var polygons = this.get_arm_polygons()

  context.save()
  context.beginPath()
  context.rect(0, 0, constants.levelWidth, constants.levelHeight)
  context.clip()

  for(var j = 0; j < polygons.length; j++) {
    context.beginPath()

    context.moveTo(polygons[j][0].x*draw_factor, polygons[j][0].y*draw_factor)
    for(var i = 1; i < polygons[j].length; i++)
    {
      context.lineTo(polygons[j][i].x*draw_factor, polygons[j][i].y*draw_factor)
    }
    context.closePath()
    context.save()
    context.globalAlpha *= this.visibility/4
    context.fillStyle = this.color
    context.fill()

    var tp = this.body.GetPosition()
    var arm_angle = Math.PI * 2 * j / this.num_arms + this.arm_core_angle
    renderUtils.drawSprite(context, (tp.x+Math.cos(arm_angle)*this.effective_radius * this.last_growth_factor * this.low_gravity_factor * 1.5) * draw_factor,
    (tp.y+Math.sin(arm_angle) * this.effective_radius * this.last_growth_factor * this.low_gravity_factor * 1.5) * draw_factor,
    arm_angle + Math.PI/2, 50, 80, "consumendi_small_arrow", sprites.consumendiSprite)
    context.restore()

  }
  context.restore()

  var tp = this.player.get_current_position()
  var angle = utils.atan(tp, this.body.GetPosition())


  if(!this.player.dying) {


    if(this.player_gravity_force >= 0.3)
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*2) * draw_factor,
      (tp.y+Math.sin(angle) * 2) * draw_factor,
      angle - Math.PI/2, 20, 10, "consumendi_small_arrow", sprites.consumendiSprite)
    if(this.player_gravity_force >= 0.75)
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*2.75) * draw_factor,
      (tp.y+Math.sin(angle) * 2.75) * draw_factor,
      angle - Math.PI/2, 20, 10, "consumendi_small_arrow", sprites.consumendiSprite)
    if(this.player_gravity_force >= 1.2)
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*3.5) * draw_factor,
      (tp.y+Math.sin(angle) * 3.5) * draw_factor,
      angle - Math.PI/2, 20, 10, "consumendi_small_arrow", sprites.consumendiSprite)
    if(this.player_gravity_force >= 2)
      renderUtils.drawSprite(context, (tp.x+Math.cos(angle)*4.25) * draw_factor,
      (tp.y+Math.sin(angle) * 4.25) * draw_factor,
      angle - Math.PI/2, 20, 10, "consumendi_small_arrow", sprites.consumendiSprite)
  }
}

BossTwo.prototype.get_arm_polygons = function() {
  var polygons = []
  for(var i = 0; i < this.num_arms; i++) {
    var polygon = []
    polygon.push({x: this.body.GetPosition().x, y: this.body.GetPosition().y})
    polygon.push({x: this.body.GetPosition().x + this.arm_length * this.arm_taper *
      Math.cos(Math.PI * 2 * i / this.num_arms + this.arm_core_angle - this.arm_width_angle/2),
      y: this.body.GetPosition().y + this.arm_length * this.arm_taper *
      Math.sin(Math.PI * 2 * i / this.num_arms + this.arm_core_angle - this.arm_width_angle/2)})

    polygon.push({x: this.body.GetPosition().x + this.arm_length *
      Math.cos(Math.PI * 2 * i / this.num_arms + this.arm_core_angle + this.arm_width_angle/2),
      y: this.body.GetPosition().y + this.arm_length *
      Math.sin(Math.PI * 2 * i / this.num_arms + this.arm_core_angle + this.arm_width_angle/2)})

    polygons.push(polygon)
  }
  return polygons

}

BossTwo.prototype.move = function() {
}

BossTwo.prototype.collide_with = function(other) {
  if(this.dying || !this.spawned)//ensures the collision effect only activates once
    return

  if(other.dying) return

  if(other === this.player) {
    music_player.play_sound("b2eat")
    var boss_angle = utils.atan(this.body.GetPosition(),other.body.GetPosition())
    this.player_struck = true
    other.start_death("absorbed")
    this.impulse_game_state.reset_combo();
  }
  else if(other !== this.player) {
    music_player.play_sound("b2eat")
    if(other.type != "harpoonhead") {
      other.start_death("absorbed")
      this.growth_factor += this.growth_on_enemy
      this.enemies_struck.push(other)
      this.absorbed_enemy_types.push(other.type);
    } else {
      this.absorbed_enemy_types.push("harpoon");
      other.harpoon.start_death("absorbed")
      this.growth_factor += this.growth_on_enemy
      this.enemies_struck.push(other)
      this.enemies_struck.push(other.harpoon)
    }
  }
}

BossTwo.prototype.get_impulse_sensitive_pts = function() {
  var ans = []
  for(var i = 0; i < this.shape_points[0].length; i++) {
    var temp = this.body.GetPosition().Copy()
    temp.Add(this.shape_points[0][i])
    ans.push(temp)
  }
  return ans
}

BossTwo.prototype.black_hole = function() {

  var black_hole_factor = 5

  if(-this.black_hole_timer/this.black_hole_duration < this.black_hole_expand_prop) {
    black_hole_factor = 0.12
  }
  var black_hole_force = 0

  if(!this.player_struck) {
    if(utils.pDist(this.body.GetPosition(), this.player.get_current_position()) <= this.black_hole_radius)
    {
      black_hole_force = this.black_hole_force * black_hole_factor * this.black_hole_player_factor
    } else {
      black_hole_force = this.boss_low_gravity_force
    }
    var tank_angle = utils.atan(this.body.GetPosition(), this.player.get_current_position()) + Math.PI

    this.player_gravity_force += black_hole_force

    this.player.body.ApplyImpulse(new box_2d.b2Vec2(black_hole_force * Math.cos(tank_angle),
    black_hole_force * Math.sin(tank_angle)), this.player.body.GetWorldCenter())
  }

  for(var i = 0; i < this.level.enemies.length; i++)
  {
    if(this.enemies_struck.indexOf(this.level.enemies[i]) == -1 &&!this.level.enemies[i].dying && this.level.enemies[i] !== this) {
      if(utils.pDist(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()) <= this.black_hole_radius)
      {
        var _angle = utils.atan(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()) + Math.PI
        var suction_force = this.black_hole_force * this.enemy_gravity_factor[this.level.enemies[i].type] * black_hole_factor
        this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(suction_force * Math.cos(_angle), suction_force * Math.sin(_angle)), this.level.enemies[i].body.GetWorldCenter())
      } else {
        var _angle = utils.atan(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()) + Math.PI
        var suction_force = this.boss_low_gravity_force * this.enemy_gravity_factor[this.level.enemies[i].type]
        this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(suction_force * Math.cos(_angle), suction_force * Math.sin(_angle)), this.level.enemies[i].body.GetWorldCenter())
      }
    }
  }
}

BossTwo.prototype.process_gateway_particles = function(dt) {
  for (var i = 0; i < this.gateway_particles.length; i++) {
    var particle = this.gateway_particles[i];
    particle.prop += dt / this.gateway_particle_duration;
    if (this.black_hole_timer < 0) {
      // double time!
      particle.prop += dt / this.gateway_particle_duration;
    }
  }
  for (var i = this.gateway_particles.length - 1; i >= 0; i--) {
    var particle = this.gateway_particles[i];
    if (particle.prop > 1) {
      this.gateway_particles.splice(i, 1);
    }
  }

  this.gateway_particle_gen_timer -= dt
  if (this.black_hole_timer < 0) {
    this.gateway_particle_gen_timer -= dt
  }

  if (this.gateway_particle_gen_timer < 0) {
    this.gateway_particle_gen_timer += this.gateway_particle_gen_interval
    this.generate_gateway_particles(this.body.GetPosition().x, this.body.GetPosition().y, this.gateway_particles_per_round)
  }
}

BossTwo.prototype.generate_gateway_particles = function(x, y, num_particles) {
  for (var i = 0; i < num_particles; i++) {
    var angle = Math.PI * 2 * i / num_particles + (Math.random() - 0.5) * Math.PI * 2 / num_particles
    this.gateway_particles.push({
      start_x: Math.cos(angle) * this.effective_radius * this.last_growth_factor * this.low_gravity_factor + x,
      start_y: Math.sin(angle) * this.effective_radius * this.last_growth_factor * this.low_gravity_factor + y,
      prop: 0
    });
  }
}

BossTwo.prototype.draw_gateway_particles = function(ctx, draw_factor) {
  var particle_shape = enemyData[this.type].death_polygons[0];
  for(var i = 0; i < this.gateway_particles.length; i++) {
    var particle = this.gateway_particles[i];
    ctx.save()
    if (particle.prop < 0.25) {
      ctx.globalAlpha *= particle.prop * 4
    } else {
      var temp = (1 - particle.prop) / (0.75)
      ctx.globalAlpha *= temp
    }
    if (this.black_hole_timer >= 0) {
      ctx.globalAlpha *= 0.5;
    }
    var pointer_angle = utils.atan({x: particle.start_x, y: particle.start_y},
                              {x: this.body.GetPosition().x, y: this.body.GetPosition().y});
    var x = draw_factor * (particle.start_x * (1 - particle.prop) + this.body.GetPosition().x * particle.prop);
    var y = draw_factor * (particle.start_y * (1 - particle.prop) + this.body.GetPosition().y * particle.prop);
    renderUtils.drawShape(ctx, x, y, particle_shape, 2, constants.colors["world " + this.impulse_game_state.world_num + " bright"], 1, pointer_angle)
    ctx.restore()
  }
}

BossTwo.prototype.get_impulse_extra_factor = function() {
  if(saveData.difficultyMode == "easy") {
    return this.impulse_extra_factor * 1.5;
  }
  return this.impulse_extra_factor;
}

module.exports = BossTwo;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/boss.js":19,"../enemy/boss_two_spawner.js":26,"../load/save_data.js":69,"../render/sprites.js":81,"../render/utils.js":83,"../vendor/box2d.js":97}],26:[function(require,module,exports){
// NOT an enemy. Does not have a box2d body. Cannot be killed.
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var sprites = require('../render/sprites.js');
var utils = require('../core/utils.js');

var EnemyFactory = require('../enemy/enemy_factory.js');

var BossTwoSpawner = function(x, y, boss, impulse_game_state) {
  this.x = x
  this.y = y
  this.boss = boss
  this.color = this.boss.color
  this.world = this.boss.world
  this.impulse_game_state = impulse_game_state
  this.level = this.impulse_game_state.level
  this.player = this.impulse_game_state.player
  this.size = 60
  this.visibility = 0

  this.enemies_to_spawn = {
    "stunner": 1,
    "spear": 1,
    "tank": 2,
    "mote": 1,
    "goo": 1,
    "harpoon": 1
  }

  this.enemies_to_spawn_easy = {
    "stunner": 3,
    "spear": 3,
    "tank": 2,
    "mote": 2,
    "goo": 1,
    "harpoon": 1
  }

  this.high_gravity_factor = 0.75//1.5
  this.low_gravity_factor = 1.5//3

  this.high_gravity_force = .8
  this.low_gravity_force = .2
}

BossTwoSpawner.prototype.draw = function(context, draw_factor, prop, next_enemy_type) {

  context.save()
  context.globalAlpha *= .5
  renderUtils.drawSprite(context, this.x, this.y, Math.PI/4, this.size * 2, this.size * 2, "consumendi_glow", sprites.consumendiSprite)
  renderUtils.drawSprite(context, this.x, this.y, Math.PI/4, this.size, this.size, "consumendi_mini", sprites.consumendiSprite)

  if(prop > 0) {
    context.beginPath()
    context.arc(this.x, this.y, this.size * 0.75, -.5* Math.PI, -.5 * Math.PI - 2*Math.PI * (1-prop), true)
    context.lineWidth = 4
    context.strokeStyle = enemyData[next_enemy_type].color
    context.stroke()
  }
  context.restore()
}

BossTwoSpawner.prototype.process = function(dt) {

  for(var i = 0; i < this.level.enemies.length; i++) {
      if (this.level.enemies[i].id == this.id) continue
      var boss_angle = utils.atan(this.level.enemies[i].body.GetPosition(), {x: this.x/constants.drawFactor, y: this.y/constants.drawFactor}) + Math.PI
      var gravity_force = this.get_gravity_force(this.level.enemies[i].body.GetPosition())
      if(gravity_force > 0)
        this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(gravity_force * Math.cos(boss_angle), gravity_force * Math.sin(boss_angle)), this.level.enemies[i].body.GetWorldCenter())
    }
    var boss_angle = utils.atan(this.player.body.GetPosition(), {x: this.x/constants.drawFactor, y: this.y/constants.drawFactor}) + Math.PI

    var gravity_force = this.get_gravity_force(this.player.body.GetPosition())

    if(gravity_force > 0)
      this.player.body.ApplyImpulse(new box_2d.b2Vec2(gravity_force *  Math.cos(boss_angle), gravity_force * Math.sin(boss_angle)), this.player.body.GetWorldCenter())

}

BossTwoSpawner.prototype.get_gravity_force = function(loc) {
var dist =  utils.pDist(loc, {x: this.x/constants.drawFactor, y: this.y/constants.drawFactor})
  var inside = false

  if (dist <= this.size/constants.drawFactor * this.high_gravity_factor) {
    return this.high_gravity_force
  }
  else if (dist <= this.size/constants.drawFactor * this.low_gravity_factor) {
    return this.low_gravity_force
  }

  return 0
}

BossTwoSpawner.prototype.spawn_enemies = function(enemy_type) {
  var exit_points = 6

  var enemy_num = this.enemies_to_spawn[enemy_type]

  if (saveData.difficultyMode == "easy") {
    enemy_num = this.enemies_to_spawn_easy[enemy_type]
  }
  var j = 0;

  if(this.level.enemy_numbers[enemy_type] + 1 <= this.level.enemies_data[enemy_type][6]) {

    for(var i = 0; i < enemy_num; i++) {
      // coordinates in box2d world, not canvas.
      var world_x =  this.x/constants.drawFactor;
      var world_y =  this.y/constants.drawFactor;
      var ray_angle = utils.atan({x: world_x, y: world_y}, this.boss.body.GetPosition())
       // find a direction that isn't close to the wall
      var angle = ray_angle + Math.PI * 2 * (j + (1/((j - (j % exit_points))/exit_points + 1)))/exit_points
      while(!utils.isVisible({x: world_x, y: world_y},
        {x: world_x + 10 * Math.cos(angle),
          y: world_y + 10 * Math.sin(angle)},
          this.level.obstacle_edges
        ))
      {
          j += 1
          angle = ray_angle + Math.PI * 2 * (j + (1/((j - (j % exit_points))/exit_points + 1)))/exit_points
      }


      var loc = [(this.x + this.size/2 * Math.cos(angle))/constants.drawFactor,
      (this.y + this.size/2 * Math.sin(angle))/constants.drawFactor]

      var temp_enemy = new ((EnemyFactory.getEnemyClassFromType(enemy_type)))(this.world, loc[0], loc[1],
      this.level.enemy_counter, this.impulse_game_state)
      temp_enemy.set_heading(angle);

      if(temp_enemy.type == "harpoon") {
        temp_enemy.dire_harpoon = true
      }
      this.level.spawned_enemies.push(temp_enemy)

      this.level.enemy_counter +=1

      j += 1;
    }
  }
}

module.exports = BossTwoSpawner;

},{"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy_factory.js":31,"../load/save_data.js":69,"../render/sprites.js":81,"../render/utils.js":83,"../vendor/box2d.js":97}],27:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

DeathRay.prototype = new Enemy()

DeathRay.prototype.constructor = DeathRay

function DeathRay(world, x, y, id, impulse_game_state) {
  if(world === undefined) return
  this.type = "deathray"

  this.init(world, x, y, id, impulse_game_state)
  if(world === null) return

  this.do_yield = false

  this.safe_radius = 10

  this.safe_radius_buffer = 2 //prevents the Death Ray from immediately toggling between running away and running towards

  this.interior_buffer = 5
  this.safe = true
  this.within_bounds = false

  this.shoot_interval = 1200

  if(saveData.difficultyMode == "easy") {
    this.shoot_interval = 1400
  }

  this.extra_adjust = false
  this.adjust_position_factor = 0.5;

  this.shoot_duration = this.shoot_interval

  this.aim_proportion = .56

  this.fire_interval = 200

  this.fire_duration = this.fire_interval

  this.fast_factor = 5

  this.ray_angle = null

  this.ray_radius = 0.8
  this.ray_buffer_radius = -0.5

  this.ray_force = 400

  this.turret_arm_angle = 0

  this.stun_length = 2000
  if(saveData.difficultyMode == "easy") {
    this.stun_length = 2000
  }


  this.aimed = false
  this.fired = false

  this.goalPt = null

  this.ray_size = 100
  this.ray_spread = Math.PI/48

  this.default_heading = false

  this.impulse_extra_factor = 3

  this.tank_force = 100

  this.die_on_player_collision = false
}

DeathRay.prototype.additional_processing = function(dt) {

  if(this.aimed) {
    this.set_heading(this.ray_angle)
  } else
    this.set_heading(utils.atan(this.body.GetPosition(), this.player.body.GetPosition()))

  if(this.safe != utils.pDist(this.player.body.GetPosition(), this.body.GetPosition()) > this.safe_radius)
  {
    this.safe = !this.safe
  }

  if(this.destroyable_timer > 0) {
    this.destroyable_timer -= dt
  }

  this.within_bounds = utils.checkBounds(this.interior_buffer, this.body.GetPosition(), constants.drawFactor)

  if (this.recovery_timer > 0) {
    this.recovery_timer -= dt
  }
  if(this.is_silenced()) {
    this.reset_ray()
    return
  }

  //ready to shoot
  if(this.shoot_duration <= 0) {

    if(this.fire_duration <= 0) {
      //reset everything
      this.reset_ray()
      this.stun(this.stun_length);
      this.recovery_timer = this.stun_length;
      this.recovery_interval = this.stun_length;
    }
    else {
      this.fire_duration = Math.max(this.fire_duration - dt, 0)
      //fire the ray
      music_player.play_sound("deathray")
      if(this.fire_duration <= this.fire_interval/2 && !this.fired) {
        var ray_polygon = this.get_ray_polygon()
        this.fired = true
        if(utils.pointInPolygon(ray_polygon, this.player.body.GetPosition())) {
          var factor = 1
          if(this.player.is_bulked()) {
            factor *= 10
          }
          if(this.player.is_gooed() > 0) {
            factor *= 0.25
          }
          this.player.body.ApplyImpulse(new box_2d.b2Vec2(factor * this.ray_force * Math.cos(this.ray_angle), factor * this.ray_force * Math.sin(this.ray_angle)), this.player.body.GetWorldCenter())
          this.impulse_game_state.reset_combo()
        }
        for(var i = 0; i < this.level.enemies.length; i++) {
          if(this.level.enemies[i] != this && utils.pointInPolygon(ray_polygon, this.level.enemies[i].body.GetPosition())) {
            if(this.level.enemies[i].type == "orbiter") {
              this.level.enemies[i].weaken()
            }
            this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(this.ray_force * Math.cos(this.ray_angle), this.ray_force * Math.sin(this.ray_angle)), this.level.enemies[i].body.GetWorldCenter())
            this.level.enemies[i].open(2500)
          }
        }
      }
    }

  }
  else if(this.aimed || (!this.aimed && this.within_bounds && !this.moving)) {
    this.shoot_duration = Math.max(this.shoot_duration - dt, 0)
    if(this.shoot_duration <= this.shoot_interval* this.aim_proportion && !this.aimed) {//if it hasn't been aimed, aim it now
      this.aim_ray()
    }
  }
}

DeathRay.prototype.additional_drawing = function(context, draw_factor) {
  if(this.recovery_timer > 0 && !this.dying) {
    uiRenderUtils.drawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, 1 - this.recovery_timer/this.recovery_interval, "#444444", 4)
  }
}


DeathRay.prototype.reset_ray = function() {
  this.shoot_duration = this.shoot_interval
  this.fire_duration = this.fire_interval
  this.aimed = false
  this.fired = false
  this.ray_angle = null
}

DeathRay.prototype.aim_ray = function() {
  this.ray_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
  this.shoot_duration = this.shoot_interval * this.aim_proportion

  this.aimed = true
}

DeathRay.prototype.get_ray_polygon = function() {
  var ray_polygon = []
  ray_polygon.push({x: this.body.GetPosition().x + this.ray_buffer_radius * Math.cos(this.ray_angle) + this.ray_radius * Math.cos(this.ray_angle + Math.PI/2),
   y: this.body.GetPosition().y + this.ray_buffer_radius * Math.sin(this.ray_angle) + this.ray_radius * Math.sin(this.ray_angle + Math.PI/2)})
  ray_polygon.push({x: this.body.GetPosition().x + this.ray_buffer_radius * Math.cos(this.ray_angle) + this.ray_radius * Math.cos(this.ray_angle - Math.PI/2),
    y: this.body.GetPosition().y + this.ray_buffer_radius * Math.sin(this.ray_angle) + this.ray_radius * Math.sin(this.ray_angle - Math.PI/2)})
  ray_polygon.push({x: ray_polygon[1].x + this.ray_size * Math.cos(this.ray_angle - this.ray_spread),
    y: ray_polygon[1].y + this.ray_size * Math.sin(this.ray_angle - this.ray_spread)
  })
  ray_polygon.push({x: ray_polygon[0].x + this.ray_size * Math.cos(this.ray_angle + this.ray_spread),
    y: ray_polygon[0].y + this.ray_size * Math.sin(this.ray_angle + this.ray_spread)
  })
  return ray_polygon
}

DeathRay.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {

  this.open(this.open_period)
  this.durations["impulsed"] += this.impulsed_duration
  this.body.ApplyImpulse(new box_2d.b2Vec2(this.impulse_extra_factor * impulse_force*Math.cos(hit_angle), this.impulse_extra_factor * impulse_force*Math.sin(hit_angle)),
    this.body.GetWorldCenter())
  this.process_impulse_specific(attack_loc, impulse_force, hit_angle)
}

DeathRay.prototype.get_target_point = function() {
  if(!this.safe) {
    this.goalPt = null
    var point = utils.getNearestSpawnPoint(this, this.player, this.impulse_game_state.level_name)
    return {x: point.x/constants.drawFactor, y: point.y/constants.drawFactor}
  }
  else {
    if(this.goalPt == null) {
      this.goalPt = {x: this.level.get_starting_loc().x/constants.drawFactor, y: this.level.get_starting_loc().y/constants.drawFactor}
    }
    return this.goalPt
  }
}

DeathRay.prototype.enemy_move = Enemy.prototype.move

DeathRay.prototype.move = function() {
  if(this.aimed) return // cannot move if aimed

  if(!this.safe) {// && this.turret_timer == 0) {
    if(this.path == null) {
      this.pathfinding_counter = 2 * this.pathfinding_delay
    }
    this.goalPt = null
    this.enemy_move()
    this.moving = true
  }
  else
  {
    if(this.within_bounds)
    {//within bounds
      this.path = null
      this.goalPt = null
      this.moving = false
    }
    else if(utils.pDist(this.player.body.GetPosition(), this.body.GetPosition()) > this.safe_radius + this.safe_radius_buffer)
    {
      if(this.path == null) {
        this.pathfinding_counter = 2 * this.pathfinding_delay
      }
      this.enemy_move()
      this.moving = true
    }
    else
      this.goalPt = null

  }

}

DeathRay.prototype.pre_draw = function(context, draw_factor) {


  if(!this.is_silenced()) {
    var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
    context.save()
    context.globalAlpha *= (1-prog)

    var ray_polygon = this.get_ray_polygon()

    if(this.shoot_duration <= this.shoot_interval * this.aim_proportion && this.ray_angle!= null) {
      var prog = 1 - this.shoot_duration / (this.shoot_interval * this.aim_proportion)
      context.save();
      context.beginPath()
      context.globalAlpha *= Math.max(prog, .2)
      context.moveTo(ray_polygon[1].x * draw_factor, ray_polygon[1].y * draw_factor)
      context.lineTo(ray_polygon[2].x * draw_factor, ray_polygon[2].y * draw_factor)
      context.moveTo(ray_polygon[3].x * draw_factor, ray_polygon[3].y * draw_factor)
      context.lineTo(ray_polygon[0].x * draw_factor, ray_polygon[0].y * draw_factor)
      context.lineWidth = 1
      context.strokeStyle = this.color
      context.stroke()

      if(this.fire_duration < this.fire_interval) {

        var vis = this.fire_duration > this.fire_interval/2 ? this.fire_interval - this.fire_duration : this.fire_duration
        vis /= (this.fire_interval/2)
        context.globalAlpha *= vis

        context.beginPath()

        context.moveTo(ray_polygon[0].x * draw_factor, ray_polygon[0].y * draw_factor)

        for(var i = 1; i < ray_polygon.length; i++)
        {
          context.lineTo(ray_polygon[i].x * draw_factor, ray_polygon[i].y * draw_factor)
        }
        context.closePath()
        context.fillStyle = this.color
        context.fill()
      }
      context.restore();
    }
    context.restore()

  }
}

DeathRay.prototype.get_color_for_status = function(status) {
  if(status == "normal") {
    return this.color ? this.color : null
  } else if(status == "stunned") {
    return '#444444';
  } else if(status == "silenced") {
    return 'gray'
  } else if(status == "gooed") {
    return "#e6c43c"
  } else if(status == "impulsed") {
    return this.impulsed_color
  } else if(status == "white") {
    return "white"
  } else if(status.slice(0, 5) == "world") {
    return constants.colors["world "+status.slice(5,6)+" lite"]
  }

  return this.get_additional_color_for_status(status)
}

DeathRay.prototype.modify_movement_vector = function(dir) {
  //apply impulse to move enemy

  if(!utils.checkBounds(-3, this.body.GetPosition(), constants.drawFactor)) {
    dir.Multiply(this.fast_factor)
  }

  var in_poly = false
  for(var i = 0; i < this.level.obstacle_polygons.length; i++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[i], this.body.GetPosition()))
    {
      in_poly = true
    }
  }
  if(in_poly)
  {
    dir.Multiply(this.slow_force)
  }
  else {

    if (this.is_silenced()) {
      dir.Multiply(0.5)
    }

    if(this.is_gooed()) {
      dir.Multiply(this.slow_factor)
    }
    dir.Multiply(this.force)
  }
}

DeathRay.prototype.player_hit_proc = function() {
}

module.exports = DeathRay;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../enemy/enemy.js":30,"../load/save_data.js":69,"../render/ui.js":82,"../vendor/box2d.js":97}],28:[function(require,module,exports){
var saveData = require('../load/save_data.js');
var utils = require('../core/utils.js');

var Goo = require('../enemy/goo.js');

Disabler.prototype = new Goo()

Disabler.prototype.constructor = Disabler

function Disabler(world, x, y, id, impulse_game_state) {
 this.type = "disabler"

  this.init(world, x, y, id, impulse_game_state)

  this.death_radius = 2

  this.do_yield = false

  this.goo_radius_small = 3;
  this.goo_radius_big = 8;

  if(saveData.difficultyMode == "easy")
    this.goo_radius_big = 8

  this.goo_radius = this.goo_radius_small

  this.goo_change_transition = 500

  this.goo_expand_period = 2500
  if(saveData.difficultyMode == "easy")
    this.goo_expand_period = 3500

  this.goo_state = "small"

  this.goo_state_timer = 0

  this.default_heading = false

  this.spin_rate = 6000

  this.slow_factor = 0

}

Disabler.prototype.check_area_of_effect = function() {
  if(!this.is_silenced() && utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) < this.goo_radius) {
    this.area_effect(this.player)
  }

  for(var j = 0; j < this.level.enemies.length; j++) {
    if(!this.is_silenced() && utils.pDist(this.body.GetPosition(), this.level.enemies[j].body.GetPosition()) < this.goo_radius)
    {
      if(this.level.enemies[j].type != this.type)
        this.area_effect(this.level.enemies[j])
    } else if(this.level.enemies[j].type == "harpoon" &&
      (utils.pDist(this.level.enemies[j].harpoon_head.body.GetPosition(), this.body.GetPosition()) < this.goo_radius ||
        (this.level.enemies[j].harpoon_state == "engaged" && utils.pDist(this.level.enemies[j].harpooned_target.body.GetPosition(), this.body.GetPosition()) < this.goo_radius))) {
      this.area_effect(this.level.enemies[j])
    }
  }
}

Disabler.prototype.area_effect = function(obj) {

  if(obj.type == "harpoonhead") {
    obj.harpoon.disable(100)
  }
  else if(obj === this.player) {
    obj.bulk(100)
    obj.silence(100)
  } else {
    obj.disable(100)
  }
}

module.exports = Disabler;

},{"../core/utils.js":11,"../enemy/goo.js":35,"../load/save_data.js":69}],29:[function(require,module,exports){
var Enemy = require('../enemy/enemy.js');

DumbStunner.prototype = new Enemy()

DumbStunner.prototype.constructor = DumbStunner

function DumbStunner(world, x, y, id, impulse_game_state) {

  this.type = "dumb_stunner"

  this.silence_outside_arena = false

  this.init(world, x, y, id, impulse_game_state)

  if(!impulse_game_state) return
}

module.exports = DumbStunner;

},{"../enemy/enemy.js":30}],30:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var enemyRenderUtils = require('../render/enemy.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var questData = require('../data/quest_data.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = function(world, x, y, id, impulse_game_state) {
  //empty constructor since Enemy should not be constructed
}


Enemy.prototype.isEnemy = true;

Enemy.prototype.init = function(world, x, y, id, impulse_game_state) {
//need to set this.type before calling init

//need to set effective_radius if do_yield = true

  this.original_spawn_point = new box_2d.b2Vec2(x, y);

  this.impulse_game_state = impulse_game_state
  this.image_enemy_type = this.type
  if(impulse_game_state) {
    this.level = impulse_game_state.level
    this.player = impulse_game_state.player
  }
  this.world = world
  for(i in enemyData[this.type]) {
    this[i] = enemyData[this.type][i]
  }

  this.pointer_vertices = []

  this.pointer_vertices.push(new box_2d.b2Vec2(Math.cos(Math.PI*0), Math.sin(Math.PI*0)))
  this.pointer_vertices.push(new box_2d.b2Vec2(Math.cos(Math.PI*5/6), Math.sin(Math.PI*5/6)))
  this.pointer_vertices.push(new box_2d.b2Vec2(Math.cos(Math.PI*7/6), Math.sin(Math.PI*7/6)))

  this.pointer_max_radius = .7

  this.pointer_fadein_duration = 1000

  this.gooed_lin_damp_factor = 3

  this.destroyable_timer =

  this.pointer_visibility = 0

  this.open_period = 1500

  this.require_open = true

  this.lighten_factor = 1.5

  this.impulsed_color = constants.colors["impulse_blue"]

  var bodyDef = new box_2d.b2BodyDef;
  bodyDef.type = box_2d.b2Body.b2_dynamicBody;
  bodyDef.position.x = x;
  bodyDef.position.y = y;
  bodyDef.linearDamping = this.lin_damp
  bodyDef.fixedRotation = this.torqueRotate ? false : true  //polygonShapes do not rotate
  if(!bodyDef.fixedRotation) {
    bodyDef.angularDamping = 50
  }
  if(world) {
    this.body = world.CreateBody(bodyDef)
  }

  this.shapes = []
  this.shape_points = []

  this.has_lightened_properties = false

  this.impulsed_duration = 500

  for(var i = 0; i < this.shape_polygons.length; i++) {
    var polygon = this.shape_polygons[i]
    var this_shape = null
    if(polygon.type == "circle") {
      this_shape = new box_2d.b2CircleShape(polygon.r)
      this_shape.SetLocalPosition(new box_2d.b2Vec2(polygon.x, polygon.y))
    }
    if(polygon.type == "polygon") {
      var vertices = []
      for(var j= 0; j < polygon.vertices.length; j++) {
        vertices.push(new box_2d.b2Vec2(polygon.x + polygon.r * polygon.vertices[j][0], polygon.y + polygon.r * polygon.vertices[j][1]))
      }
      this_shape = new box_2d.b2PolygonShape
      this_shape.SetAsArray(vertices, vertices.length)
    }

    var fixDef = new box_2d.b2FixtureDef;//make the shape
    fixDef.density = this.density;
    fixDef.friction = 0;
    fixDef.restitution = 0.7;
    fixDef.filter.categoryBits = this.categoryBits ? this.categoryBits : box_2d.ENEMY_BIT
    fixDef.filter.maskBits = this.maskBits ? this.maskBits : box_2d.ENEMY_BIT | box_2d.PLAYER_BIT | box_2d.BOSS_BITS
    fixDef.shape = this_shape
    if(this.body)
      this.body.CreateFixture(fixDef).SetUserData({"owner": this, "body": this.body, "self":this})
    this.shapes.push(this_shape)
    if(this_shape instanceof box_2d.b2PolygonShape)
      this.shape_points.push(this_shape.m_vertices)
    else
      this.shape_points.push(null)

  }
  this.default_heading = true

  this.generate_collision_polygons()

  this.path = null
  this.path_dist = null

  this.yield_counter = 0

  this.yield = false
  this.id = id
  this.dying = false
  this.died = false
  this.default_dying_length = 500;
  this.dying_length = 500;
  this.dying_duration = 0;

  this.status_duration = [0, 0, 0, 0] //[locked, silenced, gooed, lightened], time left for each status

  this.durations = {}
  this.durations["open"] = 0
  this.durations["impulsed"] = 0
  this.durations["invincible"] = 0
  this.durations["disabled"] = 0

  this.is_enemy = true

  this.special_mode = false
  this.special_mode_visibility_timer = 0  //helps with the flashing special_mode appearance
  this.sp_visibility = 0

  //DEFAULTS, CAN BE OVERRIDDEN
  //how often enemy path_finds

  this.die_on_player_collision = true
  this.pathfinding_delay = 40
  this.pathfinding_counter =  this.pathfinding_delay  //pathfinding_delay and yield are defined in enemy

  //how often enemy checks to see if it can move if yielding
  this.yield_delay = 10

  this.slow_factor = .3

  this.do_yield = false
  this.cautious = true

  this.slow_force = this.force / 3

  this.in_poly = false

  this.in_poly_slow_interval = 2000

  this.in_poly_slow_duration = this.in_poly_slow_interval

  this.death_radius = 2

  this.last_lighten = 0

  this.statuses = ["normal", "impulsed", "stunned", "silenced", "gooed", "lighten", "white", "world1", "world2", "world3", "world4", "black"]
  this.additional_statuses = []

  this.adjust_position_counter = 0
  this.adjust_position_freq = 4
  this.adjust_position_polygon = false
  this.adjust_position_angle = null
  this.adjust_position_factor = 0.5
  this.adjust_position_enabled = true

  this.has_bulk_draw = false
  this.bulk_draw_nums = 0
  this.extra_adjust = false

  this.hit_proc_on_silenced = false // for spears, since they cannot charge while silenced but still cause knockback

  this.no_death_on_open = false

  this.heading_gap = 4
  this.heading_timer = 0
  this.actual_heading = null

  if (this.silence_outside_arena) {
    this.entered_arena = false
    this.entered_arena_timer = this.entered_arena_delay
    this.recovery_interval = this.entered_arena_delay
    this.recovery_timer = this.entered_arena_delay
  }
}

Enemy.prototype.check_death = function() {

  // if the enemy does not die on open, return it to its original spawn point.

  //check if enemy has intersected polygon, if so die
  for(var k = 0; k < this.level.obstacle_polygons.length; k++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[k], this.body.GetPosition()))
    {

      if(this.durations["open"] <= 0 && this.no_death_on_open) {
        this.body.SetPosition(this.original_spawn_point)
        return
      }
      if (this.durations["open"] <= 0 && this.require_open) {
        this.start_death("accident")
      } else {
        if (this.impulse_game_state.show_tutorial) {
          this.impulse_game_state.add_tutorial_signal("enemy_killed")
        }
        this.start_death("kill")
      }

      return
    }
  }
}

Enemy.prototype.generate_collision_polygons = function() {
  this.shape_polar_points = []
  this.collision_polygons = []


  if (this.player) {
    var cur_fixture = this.body.GetFixtureList()

    while(cur_fixture != null) {
      var cur_shape = cur_fixture.m_shape
      var these_polar_points = []
      if(cur_shape instanceof box_2d.b2PolygonShape) {
        var these_points = cur_shape.m_vertices
        for(var i = 0; i < these_points.length; i++) {
          var temp_r = utils.pDist({x: 0, y: 0}, these_points[i])
          var temp_ang = utils.atan({x: 0, y: 0}, these_points[i])
          these_polar_points.push({r: temp_r, ang: temp_ang})
        }
        this.collision_polygons.push(utils.getBoundaryPolygon(these_points, (this.player.r + 0.1)))
      }
      this.shape_polar_points.push(these_polar_points)
      cur_fixture = cur_fixture.GetNext()
    }

  }
}

Enemy.prototype.process_death = function(enemy_index, dt) {
  if(this.died && (this.dying != "hit_player" || this.dying_duration < this.dying_length - 50)) {//the moment the enemy starts to die, give a couple steps to resolve collisions, then remove the body from play
    this.died = false

    this.level.dead_enemies.push(enemy_index)
  }

  if(this.dying && this.dying_duration < 0)
  {//if expired, dispose of it
    this.level.expired_enemies.push(enemy_index)
    return true
  }

  if(this.dying )
  {//if dying, expire
    this.dying_duration -= dt
    return true
  }

  return false
}

Enemy.prototype.process = function(enemy_index, dt) {

  if(this.process_death(enemy_index, dt)) return
  if(this.spawned == false) {
    this.additional_processing(dt)
    return
  }
  if(this.activated) {
    this.activated_processing(dt)
    return
  }//for tank, and potentially other enemies

  if(this.status_duration[0] > 0) {
    this.status_duration[0] -= dt
  }
  if(this.status_duration[1] > 0) {
    this.status_duration[1] -= dt
  } else {
    if(this.color_silenced) {
      this.color_silenced = false;
    }
  }

  for(status in this.durations) {
    if(this.durations[status] > 0) {
      this.durations[status] -= dt
    }
  }

  if(this.status_duration[2] > 0) {
    this.status_duration[2] -= dt
    this.body.SetLinearDamping(this.lin_damp * this.gooed_lin_damp_factor)
  } else {
    this.body.SetLinearDamping(this.lin_damp)
  }
  if (this.status_duration[3] > 0){
    this.status_duration[3] -= dt

    if(!this.has_lightened_properties) {
      this.has_lightened_properties = true

      var fixtures = this.body.GetFixtureList()
      if (fixtures.length === undefined) {
        fixtures = [fixtures]
      }


      for(var i = 0; i < fixtures.length; i++) {
        var vertices = this.body.GetFixtureList().m_shape.m_vertices
        for(var j = 0; j < vertices.length; j++)
        {
          vertices[j] = new box_2d.b2Vec2(vertices[j].x/this.lighten_factor, vertices[j].y/this.lighten_factor)
        }

        //fixtures[i].SetDensity(this.density/5)
      }
      this.body.ResetMassData()
      this.force = enemyData[this.type].force/this.lighten_factor/this.lighten_factor
    }
  }
  else {
    if(this.has_lightened_properties) {
      this.has_lightened_properties = false
      var fixtures = this.body.GetFixtureList()
      if (fixtures.length === undefined) {
        fixtures = [fixtures]
      }
       for(var i = 0; i < fixtures.length; i++) {
        var vertices = this.body.GetFixtureList().m_shape.m_vertices
        for(var j = 0; j < vertices.length; j++)
        {
          vertices[j] = new box_2d.b2Vec2(vertices[j].x*this.lighten_factor, vertices[j].y*this.lighten_factor)
        }
        //fixtures[i].SetDensity(this.density)
      }
      this.body.ResetMassData()
      this.force = enemyData[this.type].force
    }
  }
  if(this.pointer_visibility < 1) {
    this.pointer_visibility = Math.min(this.pointer_visibility + dt/this.pointer_fadein_duration, 1)
  }

  this.special_mode_visibility_timer +=dt
  var leftover = this.special_mode_visibility_timer % 1000
  if(leftover > 500) leftover = 1000 - leftover
  this.sp_visibility = leftover/500

  if(this.in_poly) {
    this.in_poly_slow_duration -= dt
  }
  else {
    this.in_poly_slow_duration = this.in_poly_slow_interval
  }

  this.check_death()

  this.adjust_position()

  this.process_entered_arena()

  this.move()

  this.additional_processing(dt)
}

Enemy.prototype.process_entered_arena = function() {

  if(!this.silence_outside_arena) return
  if(!this.entered_arena && utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.silence(this.entered_arena_delay)
    this.recovery_interval = this.entered_arena_delay
    this.recovery_timer = this.entered_arena_delay
    this.entered_arena = true
  }

  if(this.entered_arena_timer > 0) {
    this.entered_arena_timer -= dt
  }

  if(!utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.entered_arena = false
    this.silence(100, true)
    this.recovery_timer = 0
  }

  if (this.recovery_timer > 0) {
    this.recovery_timer -= dt;
    this.silence(100, true)
  }
}

Enemy.prototype.adjust_position = function() {
  this.adjust_position_counter += 1

  if(!this.adjust_position_enabled || (this.durations["open"] > 0 && this.type == "tank") || this.is_silenced()) return
  if(this.adjust_position_counter > this.adjust_position_freq) {
    this.adjust_position_counter = 0

    var in_polygon = false
    var polygons = this.level.boundary_polygons
    var angle = null

    for(var i = 0; i < polygons.length; i++) {
      if(utils.pointInPolygon(polygons[i], this.body.GetPosition())) {
        var closest_edge = utils.closestPolygonEdgeToPoint(polygons[i], this.body.GetPosition())
        if(closest_edge.dist != null) {
          var angle = utils.atan({x: 0, y: 0}, {x: closest_edge.p2.x - closest_edge.p1.x, y: closest_edge.p2.y - closest_edge.p1.y})  - Math.PI/2
          in_polygon = true
        } else {
          var closest_vertex = utils.closestPolygonVertexToPoint(polygons[i], this.body.GetPosition())
          if(closest_vertex.dist < levelData.levels[this.level.level_name].buffer_radius) {
            var angle = utils.atan(closest_vertex.v, this.body.GetPosition())
            in_polygon = true
          }
        }
        break
      }
    }
    this.adjust_position_polygon = in_polygon
    if(in_polygon)
      this.adjust_position_angle = angle
    else
      this.adjust_position_angle = null
  }

  if(this.adjust_position_angle != null) {
    var dir = new box_2d.b2Vec2(Math.cos(this.adjust_position_angle), Math.sin(this.adjust_position_angle))
    dir.Multiply(this.force * this.adjust_position_factor)
    if(this.durations["open"] > 0 && saveData.difficultyMode == "normal" && this.extra_adjust) {
      dir.Multiply(1.5)
    } else if((this.type == "goo" || this.type == "disabler") && this.durations["open"] > 0) {
      dir.Multiply(0)
    } else if (this.type == "harpoon" && this.durations["open"] > 0) {
      dir.Multiply(0.6)
    }
    this.body.ApplyImpulse(dir, this.body.GetWorldCenter())

  }
}

Enemy.prototype.additional_processing = function(dt) {

}

Enemy.prototype.activated_processing = function(dt) {

}

Enemy.prototype.get_target_point = function() {
  return this.player.body.GetPosition()
}

Enemy.prototype.move = function() {
  if(this.player.dying) return //stop moving once player dies

  if(this.is_locked()) return;

  this.pathfinding_counter+=1
  if (this.pathfinding_counter % 4 == 0 || this.pathfinding_counter >= this.pathfinding_delay) {
    //this first loop only checks whether the first point is still reachable (see below for loop)
    var target_point = this.get_target_point()

    if(!target_point) return
    if((this.path && this.path.length == 0) || (this.path && this.path.length == 1 && target_point == this.player.body.GetPosition()) || this.pathfinding_counter >= this.pathfinding_delay || (this.path && !utils.isVisible(this.body.GetPosition(), this.path[0], this.level.obstacle_edges)))
    //if this.path.length == 1, there is nothing in between the enemy and the player. In this case, it's not too expensive to check every frame to make sure the enemy doesn't kill itself
    {
      var new_path = this.impulse_game_state.visibility_graph.query(this.body.GetPosition(), target_point, this.impulse_game_state.level.pick_alt_path)
      if(new_path.path!=null) {
        this.path = new_path.path
        this.path_dist = new_path.dist
      } else {
        this.path = null
        this.path_dist = null
      }
      this.pathfinding_counter = Math.floor(Math.random()*.25 * this.pathfinding_delay)
    }

  }

  if(!this.path)
  {
    return
  }

  var endPt = this.path[0]
  if ( this.pathfinding_counter % 4 == 0) {
    while(this.path.length > 0 && utils.pDist(endPt, this.body.GetPosition())<1)
    //get rid of points that are too close
    {
      this.path = this.path.slice(1)
      endPt = this.path[0]
    }

    if(!endPt || !utils.isVisible(this.body.GetPosition(), endPt, this.level.obstacle_edges))
    //if it's not possible to reach the point
    {
      return
    }

    if(target_point == this.player.body.GetPosition() &&
       utils.isVisible(this.body.GetPosition(), this.player.body.GetPosition(), this.level.obstacle_edges)) {//if we can see the player directly, immediately make that the path
      this.path = [this.player.body.GetPosition()]
      endPt = this.path[0]
    }
  }

  //check if yielding
  if(this.do_yield) {
    if(this.yield_counter == this.yield_delay)
    {
      var nearby_enemies = utils.getObjectsWithinRadius(this.body.GetPosition(), this.effective_radius*4, this.level.enemies, function(enemy) {return enemy.body.GetPosition()})
      this.yield = false
      for(var i = 0; i < nearby_enemies.length; i++)
      {//move if the highest id enemy
        if(nearby_enemies[i].id > this.id && nearby_enemies[i].type!="fighter_bullet")
        {
          this.yield = true
          break
        }
      }
      this.yield_counter = 0
    }
    this.yield_counter++
  }

  if((!this.do_yield || !this.yield) && endPt)
  {//move if not yielding
    this.move_to(endPt)
  }
}

Enemy.prototype.move_to = function(endPt) {

  var dir = new box_2d.b2Vec2(endPt.x - this.body.GetPosition().x, endPt.y - this.body.GetPosition().y)
  dir.Normalize()

  this.modify_movement_vector(dir)  //primarily for Spear

  this.body.ApplyImpulse(dir, this.body.GetWorldCenter())

  if (this.default_heading) {
    this.set_heading_to(endPt)
  }
}

Enemy.prototype.modify_movement_vector = function(dir) {
  dir.Multiply(this.force)
}

Enemy.prototype.set_heading_to = function(point) {
  this.set_heading(utils.atan(this.body.GetPosition(), point))
}

Enemy.prototype.set_heading = function(heading) {
  this.heading_timer -= 1
  if(this.heading_timer <= 0) {
    this.body.SetAngle(heading)
    this.heading_timer = this.heading_gap
  }
  this.actual_heading = heading
}

Enemy.prototype.start_death = function(death) {
  if (this.durations["invincible"] > 0 && death == "hit_player") {
    return;
  }
  this.dying = death
  this.dying_length = (death == "fade") ? 500 : this.default_dying_length;
  this.dying_duration = this.dying_length;
  this.died = true
  if(this.dying == "kill" && !this.player.dying) {
    //if the player hasn't died and this was a kill, increase score
    this.impulse_game_state.game_numbers.kills +=1
    if(!this.level.is_boss_level) {
      var score_value = this.impulse_game_state.game_numbers.combo * this.score_value
      if(saveData.optionsData.score_labels)
        this.impulse_game_state.addScoreLabel(score_value, this.color, this.body.GetPosition().x, this.body.GetPosition().y, 20)
      this.impulse_game_state.game_numbers.score += score_value
      this.impulse_game_state.increment_combo()
      this.impulse_game_state.check_cutoffs()
      if (score_value > questData["high_roller"].score_cutoff) {
        saveData.setQuestCompleted("high_roller");
      }
    }
  }

  if(this.dying != "accident" && this.dying != "fade" && this.dying != "absorbed") {
    if (this.type == "tank") {
      music_player.play_sound("tdeath")
    } else if (this.is_boss) {
      music_player.play_sound("tdeath")
      setTimeout(function() {
        music_player.play_sound("tdeath")
      }, 150);
      setTimeout(function() {
        music_player.play_sound("tdeath")
      }, 300);
    } else if (this.type == "troll" && this.dying == "hit_player" && !this.is_silenced()) {
      // do nothing if it's a troll hitting a player. there's a different sound.
    } else {
      music_player.play_sound("sdeath")
    }
  }
  if (this.dying != "fade") {
    this.level.add_fragments(this.type, this.body.GetPosition(), this.body.GetLinearVelocity())
    this.additional_death_prep(death)
  }
}

Enemy.prototype.additional_death_prep = function(death) {

}

Enemy.prototype.collide_with = function(other) {
//function for colliding with the player

  if(this.dying)//ensures the collision effect only activates once
    return

    var transfer_factor = 0.2
    if(this.durations["open"] > 0) {
      if(other.type=="mote" || other.type == "troll") {
        var magnitude = this.body.m_linearVelocity
        var ratio = this.body.GetMass()/other.body.GetMass()
        other.body.ApplyImpulse(new box_2d.b2Vec2(magnitude.x*transfer_factor*ratio, magnitude.y* transfer_factor*ratio), other.body.GetPosition())
        this.body.SetLinearVelocity(new box_2d.b2Vec2(magnitude.x * (ratio)/(1+ratio), magnitude.y * (ratio)/(1+ratio)))
      }
    }

    if(other === this.player) {
      if(this.impulse_game_state.is_boss_level && !this.is_lightened()) {
        if(this.body.GetLinearVelocity().Length() > 50) {
          var player_transfer_factor = 0.5
          var magnitude = this.body.GetLinearVelocity()
          var ratio = this.body.GetMass()/other.body.GetMass()
          other.body.ApplyImpulse(new box_2d.b2Vec2(magnitude.x*ratio * player_transfer_factor, magnitude.y*ratio* player_transfer_factor), other.body.GetPosition())
          this.body.SetLinearVelocity(new box_2d.b2Vec2(magnitude.x * (ratio)/(1+ratio), magnitude.y * (ratio)/(1+ratio)))
        }
      }
      if (this.die_on_player_collision) {
        this.start_death("hit_player");
      }
      if(!this.is_silenced() || this.hit_proc_on_silenced) {//do not proc if silenced
        this.player_hit_proc()
      }
      // Always reset combo on contact, even when silenced. However, do not reset when inside disabler.
      if (!this.is_disabled()) {
        this.impulse_game_state.reset_combo()
      }
      if (this.impulse_game_state.show_tutorial) {
        this.impulse_game_state.add_tutorial_signal("enemy_touched")
      }
    } else if(other.isEnemy) {
        if(other.durations["open"] > 0) {
          this.open(other.durations["open"])
        }
      this.enemy_hit_proc(other);
    }
}

Enemy.prototype.enemy_hit_proc = function(other) {

}

Enemy.prototype.player_hit_proc = function() {
  //what happens when hits player
  if(saveData.difficultyMode == "easy") {
    this.player.stun(500)
  }
  if(saveData.difficultyMode == "normal") {
    this.player.stun(500)
  }
}

Enemy.prototype.draw = function(context, draw_factor) {
  if(this.spawned == false && this.spawn_duration > .9 * this.spawn_interval) return

  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0

  //rotate enemy

  //if(this.shape instanceof box_2d.b2PolygonShape) {
    //if polygon shape, need to rotate
    var tp = this.body.GetPosition()
    context.save();
    context.translate(tp.x * draw_factor, tp.y * draw_factor);
    context.rotate(this.actual_heading);
    /*context.translate(-(tp.x) * draw_factor, -(tp.y) * draw_factor);*/
  //}
  //var latest_color = this.get_current_color_with_status()

  var size = enemyData[this.type].images["normal"].height;
  if (this.dying)
    context.globalAlpha *= (1 - prog)
  else
    context.globalAlpha *= this.visibility ? this.visibility : 1

   var radius_factor = this.dying && this.dying != "fade"? (1 + this.death_radius * prog) : 1; // if dying, will expand

   var my_size = size
   if(this.is_lightened()) {

      var prog = this.status_duration[3]/this.last_lighten
      var lighten_factor = 1
      if(prog < .1)
      {
        var transition = 1 - prog/.1
        lighten_factor = (this.lighten_start) * transition + (this.lighten_finish) * (1-transition)
      } else if(prog > .9) {
        var transition = (prog - .9)/.1
        lighten_factor = (this.lighten_start) * transition + (this.lighten_finish) * (1-transition)
      } else {
        lighten_factor = this.lighten_finish
      }
      my_size *= lighten_factor
    }
  my_size *= radius_factor

  context.drawImage(enemyData[this.type].images[this.get_current_status()], 0, 0, size, size, -my_size/2, -my_size/2, my_size, my_size);

  context.restore()

  this.additional_drawing(context, draw_factor)
}


Enemy.prototype.additional_drawing = function(context, draw_factor) {
}

Enemy.prototype.pre_draw = function(context, draw_factor) {
//things that should be drawn before anything else in the world

}

Enemy.prototype.final_draw = function(context, draw_factor) {
//things that should be drawn after anything else in the world

}

Enemy.prototype.bulk_draw_start = function(context, draw_factor, num) {

}

Enemy.prototype.bulk_draw = function(context, draw_factor, num) {

}

Enemy.prototype.bulk_draw_end = function(context, draw_factor, num) {

}

Enemy.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  this.open(this.open_period)
  this.durations["impulsed"] += this.impulsed_duration
  this.body.ApplyImpulse(new box_2d.b2Vec2(impulse_force*Math.cos(hit_angle), impulse_force*Math.sin(hit_angle)),
    this.body.GetWorldCenter())
  this.process_impulse_specific(attack_loc, impulse_force, hit_angle)
}

Enemy.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {

}

Enemy.prototype.stun = function(dur) {
  this.status_duration[0] = Math.max(dur, this.status_duration[0]) //so that a short stun does not shorten a long stun
  this.status_duration[1] = Math.max(dur, this.status_duration[1])
}

Enemy.prototype.invincible = function(dur) {
  this.durations["invincible"] = Math.max(dur, this.durations["invincible"])
}

Enemy.prototype.silence = function(dur, color_silence) {
  if(color_silence)
    this.color_silenced = color_silence
  this.status_duration[1] = Math.max(dur, this.status_duration[1])
}

Enemy.prototype.lock = function(dur) {
  this.status_duration[0] = Math.max(dur, this.status_duration[0])
}

Enemy.prototype.goo = function(dur) {
  this.status_duration[2] = Math.max(dur, this.status_duration[2])
}

Enemy.prototype.lighten = function(dur) {
  this.status_duration[3] = Math.max(dur, this.status_duration[3])
  this.last_lighten = this.status_duration[3]
  this.lighten_start = 1
  this.lighten_finish = 1/this.lighten_factor
}

Enemy.prototype.open = function(dur) {
  this.durations["open"] = Math.max(dur, this.durations["open"])
}

Enemy.prototype.disable = function(dur) {
  this.durations["disabled"] = Math.max(dur, this.durations["disabled"])
}

Enemy.prototype.is_locked = function() {
  return this.status_duration[0] > 0;
};

Enemy.prototype.is_silenced = function() {
  return this.status_duration[1] > 0 || this.durations["disabled"] > 0;
}

Enemy.prototype.is_disabled = function() {
  return this.durations["disabled"] > 0;
}

Enemy.prototype.is_gooed = function() {
  return this.status_duration[2] > 0;
}

Enemy.prototype.is_lightened = function() {
  return this.status_duration[3] > 0;
}

Enemy.prototype.is_opened = function() {
  return this.durations["open"] > 0;
}

Enemy.prototype.is_invincible = function() {
  return this.durations["invincible"] > 0;
}

Enemy.prototype.get_segment_intersection = function(seg_s, seg_f) {
  //checks if the segment intersects this enemy
  //returns the closest intersection to seg_s
  var ans = null
  var ans_d = null

  var cur_ang = this.shape_type == "polygon" ? this.current_heading : 0

  for(var k = 0; k < this.shape_polar_points.length; k++) {
    var these_polar_points = this.shape_polar_points[k]

    var j = these_polar_points.length - 1
    for(var i = 0; i < these_polar_points.length; i++)
    {
      var loc_i = {x: this.body.GetPosition().x + these_polar_points[i].r * Math.cos(these_polar_points[i].ang + cur_ang),
       y: this.body.GetPosition().y + these_polar_points[i].r * Math.sin(these_polar_points[i].ang + cur_ang)}
      var loc_j = {x: this.body.GetPosition().x + these_polar_points[j].r * Math.cos(these_polar_points[j].ang + cur_ang),
       y: this.body.GetPosition().y + these_polar_points[j].r * Math.sin(these_polar_points[j].ang + cur_ang)}
      var temp_point = utils.getSegIntersection(loc_i, loc_j, seg_s, seg_f)
      if(temp_point == null) continue
      var temp_d = utils.pDist(temp_point, seg_s)
      if(ans_d == null || temp_d < ans_d)
      {
        ans = temp_point
        ans_d = temp_d
      }
      j = i
    }
  }
  return {point: ans, dist: ans_d}

}

Enemy.prototype.get_impulse_sensitive_pts = function() {
  return [this.body.GetPosition()]
}

Enemy.prototype.set_up_images = function() {
  var normal_canvas = document.createElement('canvas');
  normal_canvas.width = enemyData[this.type].effective_radius * 2 * constants.drawFactor
  normal_canvas.height = enemyData[this.type].effective_radius * 2 * constants.drawFactor

  var normal_canvas_ctx = normal_canvas.getContext('2d');

  this.enemyRenderUtils.drawEnemyImage(normal_canvas_ctx);
  this.enemy_images = {}
  this.enemy_images["normal"] = normal_canvas
}

Enemy.prototype.draw_additional_image = function(context, color) {

}

Enemy.prototype.get_current_status = function() {

  if(!this.dying) {
      if(this.durations["impulsed"] > 0) {
        return "impulsed"
      }
      if(this.is_locked()) {
        return 'stunned';
      } else if(this.color_silenced) {
        return 'silenced'
      } else if(this.is_gooed()) {
        return "gooed"
      } else if (this.is_disabled()) {
        return 'silenced';
      }
    }

    return this.get_additional_current_status()
}

Enemy.prototype.get_additional_current_status = function() {
  return "normal"
}

Enemy.prototype.get_current_color_with_status = function(orig_color) {

  var cur_color = this.get_color_for_status(this.get_current_status())

  if(cur_color == this.color && orig_color) return orig_color

  return cur_color
}


Enemy.prototype.get_color_for_status = function(status) {
  if(status == "normal") {
    return this.color ? this.color : null
  } else if(status == "stunned") {
    return 'gray';
  } else if(status == "silenced") {
    return 'gray'
  } else if(status == "gooed") {
    return "#e6c43c"
  } else if(status == "impulsed") {
    return this.impulsed_color
  } else if(status == "white") {
    return "white"
  } else if(status == "black") {
    return "black"
  } else if(status.slice(0, 5) == "world") {
    return constants.colors["world "+status.slice(5,6)+" lite"]
  }

  return this.get_additional_color_for_status(status)
}

Enemy.prototype.get_additional_color_for_status = function(status) {

}

Enemy.prototype.generate_images = function() {

  var images = {};
  var draw_polygons = this.shape_polygons
  var all_status = this.statuses.concat(this.additional_statuses)
  for(index in all_status) {
    var status = all_status[index]
    var normal_canvas = document.createElement('canvas');
    normal_canvas.width = enemyData[this.type].effective_radius * 2 * constants.enemyCanvasFactor * constants.drawFactor
    normal_canvas.height = enemyData[this.type].effective_radius * 2 * constants.enemyCanvasFactor * constants.drawFactor

    var normal_canvas_ctx = normal_canvas.getContext('2d');

    var cur_color = this.get_color_for_status(status)
    if (!cur_color) cur_color = this.color

    var tp = {x: enemyData[this.type].effective_radius * constants.enemyCanvasFactor, y: enemyData[this.type].effective_radius * constants.enemyCanvasFactor}
    normal_canvas_ctx.translate(tp.x * constants.drawFactor, tp.y * constants.drawFactor)

    enemyRenderUtils.drawEnemyImage(normal_canvas_ctx, status, draw_polygons, this.type, cur_color);
    normal_canvas_ctx.translate(-tp.x * constants.drawFactor, -tp.y * constants.drawFactor)
    images[status] = normal_canvas

  }

  return images

}

Enemy.prototype.dispose = function () {

};

module.exports = Enemy;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../data/level_data.js":16,"../data/quest_data.js":17,"../load/save_data.js":69,"../render/enemy.js":74,"../render/ui.js":82,"../vendor/box2d.js":97}],31:[function(require,module,exports){
var EnemyFactory = function () {
  this.enemyMap = {};
};

EnemyFactory.prototype.setEnemyMap = function (map) {
  this.enemyMap = map;
};

EnemyFactory.prototype.getEnemyClassFromType = function (type) {
  return this.enemyMap[type];
};

module.exports = new EnemyFactory();

},{}],32:[function(require,module,exports){
var BossFour = require('../enemy/boss_four.js');
var BossFourAttacker = require('../enemy/boss_four_attacker.js');
var BossFourSpawner = require('../enemy/boss_four_spawner.js');
var BossOne = require('../enemy/boss_one.js');
var BossThree = require('../enemy/boss_three.js');
var BossTwo = require('../enemy/boss_two.js');
var DeathRay = require('../enemy/death_ray.js');
var Disabler = require('../enemy/disabler.js');
var DumbStunner = require('../enemy/dumb_stunner.js');
var Fighter = require('../enemy/fighter.js');
var FighterBullet = require('../enemy/fighter_bullet.js');
var Goo = require('../enemy/goo.js');
var Harpoon = require('../enemy/harpoon.js');
var HarpoonHead = require('../enemy/harpoon_head.js');
var Mote = require('../enemy/mote.js');
var Orbiter = require('../enemy/orbiter.js');
var PiercingFighterBullet = require('../enemy/piercing_fighter_bullet.js');
var Slingshot = require('../enemy/slingshot.js');
var Spear = require('../enemy/spear.js');
var Stunner = require('../enemy/stunner.js');
var Tank = require('../enemy/tank.js');
var Troll = require('../enemy/troll.js');

var enemyMap = {
  'dumb_stunner': DumbStunner,
  'stunner': Stunner,
  'spear': Spear,
  'tank': Tank,
  'mote': Mote,
  'goo': Goo,
  'disabler': Disabler,
  'troll': Troll,
  'fighter': Fighter,
  'fighter_bullet': FighterBullet,
  'piercing_fighter_bullet': PiercingFighterBullet,
  'harpoon': Harpoon,
  'harpoonhead': HarpoonHead,
  'orbiter': Orbiter,
  'slingshot': Slingshot,
  'deathray': DeathRay,
  'boss_one': BossOne,
  'boss_two': BossTwo,
  'boss_three': BossThree,
  'boss_four': BossFour,
  'boss_four_attacker': BossFourAttacker,
  'boss_four_spawner': BossFourSpawner
};

module.exports = enemyMap;

},{"../enemy/boss_four.js":20,"../enemy/boss_four_attacker.js":21,"../enemy/boss_four_spawner.js":22,"../enemy/boss_one.js":23,"../enemy/boss_three.js":24,"../enemy/boss_two.js":25,"../enemy/death_ray.js":27,"../enemy/disabler.js":28,"../enemy/dumb_stunner.js":29,"../enemy/fighter.js":33,"../enemy/fighter_bullet.js":34,"../enemy/goo.js":35,"../enemy/harpoon.js":36,"../enemy/harpoon_head.js":37,"../enemy/mote.js":38,"../enemy/orbiter.js":39,"../enemy/piercing_fighter_bullet.js":40,"../enemy/slingshot.js":41,"../enemy/spear.js":42,"../enemy/stunner.js":43,"../enemy/tank.js":44,"../enemy/troll.js":45}],33:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var enemyRenderUtils = require('../render/enemy.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');
var FighterBullet = require('../enemy/fighter_bullet.js');
var PiercingFighterBullet = require('../enemy/piercing_fighter_bullet.js');

Fighter.prototype = new Enemy()

Fighter.prototype.constructor = Fighter

function Fighter(world, x, y, id, impulse_game_state) {

  if(world === undefined) return

  this.type = "fighter"

  this.init(world, x, y, id, impulse_game_state)
  this.additional_statuses = ["frenzy"]
  if(world === null) return
  this.death_radius = 5

  this.shoot_interval = 2000
  this.frenzy_shoot_interval = 750

  this.shoot_durations = [this.shoot_interval, 2 * this.shoot_interval]
  this.shoot_fade_out_prop = 0.15 //percentage of shoot_interval
  this.shoot_fade_out = [false, false]

  this.shield_animate_interval = 400
  this.shield_animate_duration = 0
  this.shield_radius = this.effective_radius * 2.5

  this.impulsed_color = this.color

  this.do_yield = false

  this.safe_radius = 10

  this.safe_radius_buffer = 2

  this.fast_factor = 5

  this.has_sight_of_player = false

  this.safe = true

  this.shoot_loc_forward_length = this.effective_radius

  this.shoot_loc_side_length = this.effective_radius * 2

  this.frenzy_charge = 0

  this.frenzy_charge_interval = 2500

  if(saveData.difficultyMode == "easy") // since the player is heavier in easy mode
    this.frenzy_charge_interval = 3500

  this.frenzy_charge_bars = 5;

  this.fighter_status = "normal"

  this.death_delay = 200
  this.bomb_factor = 3

  this.activated = false

  this.tank_force = 100 //force that the fighter impulses the player
  if(saveData.difficultyMode == "easy")
    this.tank_force = 80
  this.cautious = false

  this.player_collision_buffer_interval = 200 // minimum period between player collisions, so we don't accidentally apply tank_force twice
  this.player_collision_buffer_timer = 0

  this.die_on_player_collision = false
}

Fighter.prototype.get_bullet_locations = function(side) {
  var other_angle = this.actual_heading + Math.PI/2 * ((side % 2) * 2 - 1)
  var bullet_start_loc_x = this.body.GetPosition().x + this.shoot_loc_side_length *  Math.cos(other_angle) + this.shoot_loc_forward_length * Math.cos(this.actual_heading)
  var bullet_start_loc_y = this.body.GetPosition().y + this.shoot_loc_side_length *  Math.sin(other_angle) + this.shoot_loc_forward_length * Math.sin(this.actual_heading)
  return {x: bullet_start_loc_x, y: bullet_start_loc_y};

}

Fighter.prototype.get_additional_color_for_status = function(status) {
  if (status == "frenzy") {
    return "red"
  }
}

Fighter.prototype.get_current_status = function() {

  if(!this.dying) {
      if(this.is_locked()) {
        return 'stunned';
      } else if(this.fighter_status == "frenzy") {
        return "frenzy"
      } else if(this.color_silenced) {
        return 'silenced'
      } else if(this.is_gooed()) {
        return "gooed"
      } else if (this.is_disabled()) {
        return 'silenced';
      }
      if(this.durations["impulsed"] > 0) {
        return "impulsed"
      }
    }

    return this.get_additional_current_status()
}

Fighter.prototype.additional_processing = function(dt) {
  if(this.fighter_status == "normal" && this.frenzy_charge >= this.frenzy_charge_bars) {
    music_player.play_sound("ffrenzy")
    window.console.log("PLAYIN FRENZY");
    this.fighter_status = "frenzy"


    this.shoot_durations = [this.frenzy_shoot_interval, this.frenzy_shoot_interval]
    this.color = "red"
    this.body.SetLinearDamping(enemyData[this.type].lin_damp * 5)
  }

  if(!this.is_silenced() && this.player_collision_buffer_timer <= 0 &&
      utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) < this.shield_radius) {
    var tank_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.tank_force * Math.cos(tank_angle), this.tank_force * Math.sin(tank_angle)), this.player.body.GetWorldCenter())
    //this.cause_of_death = "hit_player"
    this.impulse_game_state.reset_combo()
    this.shield_animate_duration = this.shield_animate_interval;
    this.player_collision_buffer_timer = this.player_collision_buffer_interval
  }

  if (this.player_collision_buffer_timer > 0) {
    this.player_collision_buffer_timer -= dt
  }

  if(this.fighter_status == "frenzy" && this.frenzy_charge <= 0) {
    this.fighter_status = "normal"
    this.shoot_durations = [this.shoot_interval, this.shoot_interval * 2];
    this.color = enemyData[this.type].color;
    this.body.SetLinearDamping(enemyData[this.type].lin_damp)
  }
  for(var i = 0; i < this.shoot_durations.length; i++) {
    if(this.shoot_durations[i] <= 0 && !this.shoot_fade_out[i] && !this.is_silenced()) {

      if(utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
        var cur_bullet_loc = this.get_bullet_locations(i);
        this.has_sight_of_player = utils.isVisible(cur_bullet_loc, this.player.body.GetPosition(), this.level.obstacle_edges)

        var target_angle = utils.atan(cur_bullet_loc, this.player.body.GetPosition())
        if (this.has_sight_of_player) {
          this.shoot_durations[i] = this.fighter_status == "normal" ? (2 * this.shoot_interval) : this.frenzy_shoot_interval
          music_player.play_sound("fbullet")
          if(this.fighter_status == "frenzy") {
            this.frenzy_charge -= 0.5
            var new_piercing_bullet = new PiercingFighterBullet(this.world, cur_bullet_loc.x, cur_bullet_loc.y, this.level.enemy_counter, this.impulse_game_state, target_angle, this.id )
            var dir = new box_2d.b2Vec2(Math.cos(target_angle), Math.sin(target_angle));
            dir.Multiply(2)
            new_piercing_bullet.body.ApplyImpulse(dir, new_piercing_bullet.body.GetWorldCenter())
            this.level.spawned_enemies.push(new_piercing_bullet)
          }
          else {
            var new_bullet = new FighterBullet(this.world, cur_bullet_loc.x, cur_bullet_loc.y, this.level.enemy_counter, this.impulse_game_state, target_angle, this.id )
            var dir = new box_2d.b2Vec2(Math.cos(target_angle), Math.sin(target_angle));
            dir.Multiply(0.5)
            new_bullet.body.ApplyImpulse(dir, new_bullet.body.GetWorldCenter())
            this.level.spawned_enemies.push(new_bullet)
          }
          this.level.enemy_counter += 1
        } else {
          this.shoot_fade_out[i] = true
        }
      }
    }
    if(this.shoot_fade_out[i] && this.shoot_durations[i] < -this.shoot_fade_out_prop *
      (this.fighter_status == "normal" ? this.shoot_interval : this.frenzy_shoot_interval)) {
      this.shoot_durations[i] = this.fighter_status == "normal" ? (2 * this.shoot_interval + this.shoot_durations[i]) : this.frenzy_shoot_interval
      this.shoot_fade_out[i] = false
    }
    if(utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
      this.shoot_durations[i] -= dt
    }
  }


  if (this.fighter_status == "normal" && !this.is_silenced() && this.frenzy_charge < this.frenzy_charge_bars && utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.frenzy_charge += dt / this.frenzy_charge_interval;
  }

  if (this.shield_animate_duration > 0) {
    this.shield_animate_duration -= dt
  }
}

Fighter.prototype.player_hit_proc = function() {
}

Fighter.prototype.additional_drawing = function(context, draw_factor) {
  if(!this.dying) {
    context.save();
    context.globalAlpha *= 0.7
    if(this.frenzy_charge > 0) {
      for(var i = 0; i < Math.floor(this.frenzy_charge); i++) {
        context.beginPath()
        context.arc(this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor,
         this.effective_radius * 2 * draw_factor,
          -Math.PI/2 + Math.PI * 2 * (i+1) / this.frenzy_charge_bars - Math.PI/24, -Math.PI/2 + Math.PI * 2 * i / this.frenzy_charge_bars + Math.PI/24, true)
        /*context.arc((this.body.GetPosition().x + this.effective_radius * 2 * Math.cos(Math.PI * 2 * i / this.frenzy_charge_bars)) * draw_factor,
         (this.body.GetPosition().y + this.effective_radius * 2 * Math.sin(Math.PI * 2 * i / this.frenzy_charge_bars))*draw_factor,
       4, 0, 2 * Math.PI, true)*/
        context.strokeStyle = "red"
        context.lineWidth = 5;
        context.stroke()
      }
      if(!this.is_silenced() && this.frenzy_charge < this.frenzy_charge_bars) {
        i = Math.floor(this.frenzy_charge)
        var prop = this.frenzy_charge - i;
        context.beginPath()
        context.arc(this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor,
          this.effective_radius * 2 * draw_factor,
          -Math.PI/2 + Math.PI * 2 * i / this.frenzy_charge_bars + Math.PI/24 + (2 * Math.PI/this.frenzy_charge_bars - Math.PI/12) * prop,
          -Math.PI/2 + Math.PI * 2 * i / this.frenzy_charge_bars + Math.PI/24, true)
        context.lineWidth = 5
        context.strokeStyle = "red"
        context.stroke()
      }
    }



    context.restore();

    for(var i = 0; i < this.shoot_durations.length; i++) {
      var cur_bullet_loc = this.get_bullet_locations(i);
      var cur_interval = (this.fighter_status == "normal" ? this.shoot_interval : this.frenzy_shoot_interval)
      var loaded_prop = Math.max((cur_interval - this.shoot_durations[i])/(cur_interval), 0)
      // draw charging bullet.
      if (loaded_prop > 0 && loaded_prop < 1) {
        context.save()
        context.globalAlpha *= loaded_prop
        var bullet_type = this.fighter_status == "frenzy" ? "piercing_fighter_bullet" : "fighter_bullet"
        if (this.actual_heading)
          enemyRenderUtils.drawEnemy(context, bullet_type, cur_bullet_loc.x * draw_factor, cur_bullet_loc.y * draw_factor, null, this.actual_heading)
        else
          enemyRenderUtils.drawEnemy(context, bullet_type, cur_bullet_loc.x * draw_factor, cur_bullet_loc.y * draw_factor, null, this.body.GetAngle())

        if(this.shoot_durations[i] > 0 && loaded_prop > 0) {
          context.beginPath()
          context.arc(cur_bullet_loc.x*draw_factor, cur_bullet_loc.y*draw_factor,
            (this.effective_radius*draw_factor) * 1, -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * loaded_prop * 0.999)
          context.lineWidth = 2
          context.strokeStyle = this.color
          context.stroke()
        }
        context.restore()
      // draw fading bullet
      } else if (this.shoot_durations[i] < 0) {
        var faded_prop = 1 - Math.min((loaded_prop - 1) / (this.shoot_fade_out_prop), 1);
        context.save()
        context.globalAlpha *= faded_prop
        var bullet_type = this.fighter_status == "frenzy" ? "piercing_fighter_bullet" : "fighter_bullet"
        if (this.actual_heading)
          enemyRenderUtils.drawEnemy(context, bullet_type, cur_bullet_loc.x * draw_factor, cur_bullet_loc.y * draw_factor, null, this.actual_heading)
        else
          enemyRenderUtils.drawEnemy(context, bullet_type, cur_bullet_loc.x * draw_factor, cur_bullet_loc.y * draw_factor, null, this.body.GetAngle())
        context.beginPath()
        context.arc(cur_bullet_loc.x*draw_factor, cur_bullet_loc.y*draw_factor,
          (this.effective_radius*draw_factor) * 1, -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * 0.999)
        context.lineWidth = 2
        context.strokeStyle = this.color
        context.stroke()
        context.restore()
      }
    }
    if (this.shield_animate_duration > 0) {
      var shield_prog = 1 - Math.abs(1 - 2 * this.shield_animate_duration / this.shield_animate_interval);
      context.save()
      context.globalAlpha *= utils.bezierInterpolate(0.15, 0.85, shield_prog);
      context.beginPath()
      context.strokeStyle = this.color;
      context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, (this.shield_radius) *draw_factor
        , -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * 0.999)
      context.lineWidth = 3
      context.stroke()
      context.fillStyle = this.color
      context.globalAlpha /= 4
      context.fill()
      context.restore()
    }
  }
}


Fighter.prototype.activated_processing = function(dt) {

}

Fighter.prototype.super_silence = Enemy.prototype.silence;

Fighter.prototype.silence = function(dur, color_silence) {
  this.super_silence(dur, color_silence);
  this.shoot_durations[0] = this.fighter_status == "normal" ? this.shoot_interval : this.frenzy_shoot_interval // reset shoot duration
  this.shoot_durations[1] = this.fighter_status == "normal" ? 2 * this.shoot_interval : this.frenzy_shoot_interval // reset shoot duration
}

Fighter.prototype.modify_movement_vector = function(dir) {
  //apply impulse to move enemy
  if(!utils.checkBounds(-3, this.body.GetPosition(), constants.drawFactor)) {
    dir.Multiply(this.fast_factor)
  }

  var in_poly = false
  for(var i = 0; i < this.level.obstacle_polygons.length; i++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[i], this.body.GetPosition()))
    {
      in_poly = true
    }
  }
  if(in_poly)
  {
    dir.Multiply(this.slow_force)
  }
  else {
    if(this.fighter_status == "frenzy" && !this.is_silenced()) {
      dir.Multiply(this.fast_factor)
    }

    if (this.is_silenced()) {
      dir.Multiply(0.5)
    }

    if(this.is_gooed()) {
      dir.Multiply(this.slow_factor)
    }
    dir.Multiply(this.force)
  }
}

Fighter.prototype.explode = function() {
  if(utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) <= this.effective_radius * this.bomb_factor)
  {
    var tank_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.tank_force * Math.cos(tank_angle), this.tank_force * Math.sin(tank_angle)), this.player.body.GetWorldCenter())
  }

  for(var i = 0; i < this.level.enemies.length; i++)
  {

    if(this.level.enemies[i] !== this && utils.pDist(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()) <= this.effective_radius * this.bomb_factor)
    {
      var _angle = utils.atan(this.body.GetPosition(), this.level.enemies[i].body.GetPosition())
      this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(this.tank_force * Math.cos(_angle), this.tank_force * Math.sin(_angle)), this.level.enemies[i].body.GetWorldCenter())
      this.level.enemies[i].open(1500)

    }
  }
}

Fighter.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  this.open(this.open_period)
  var factor = 1.5
  if (!this.is_silenced()) {
    factor = 0.6
  }
  this.body.ApplyImpulse(new box_2d.b2Vec2(factor*impulse_force*Math.cos(hit_angle), factor*impulse_force*Math.sin(hit_angle)),
    this.body.GetWorldCenter())
  this.durations["impulsed"] += this.impulsed_duration
  this.process_impulse_specific(attack_loc, impulse_force, hit_angle)
}

Fighter.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.process_hit();
  if (!this.is_silenced())
    this.shield_animate_duration = this.shield_animate_interval;
}

Fighter.prototype.process_hit = function() {
  if(this.frenzy_charge > 0) {
    this.frenzy_charge -= 1;
    if(this.frenzy_charge < 0) this.frenzy_charge = 0
  }
}

module.exports = Fighter;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../enemy/fighter_bullet.js":34,"../enemy/piercing_fighter_bullet.js":40,"../load/save_data.js":69,"../render/enemy.js":74,"../vendor/box2d.js":97}],34:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

FighterBullet.prototype = new Enemy()

FighterBullet.prototype.constructor = FighterBullet

function FighterBullet(world, x, y, id, impulse_game_state, dir, parent_id) {
  if(world === undefined) return
  this.type = "fighter_bullet"

  this.init(world, x, y, id, impulse_game_state)

  if(world === null) return
  this.special_mode = false

  this.death_radius = 5

  this.v = new box_2d.b2Vec2(Math.cos(dir), Math.sin(dir))
  this.v.Normalize()
  this.v.Multiply(this.force)

  if(saveData.difficultyMode == "easy") {
    this.v.Multiply(0.5)
  }
  this.do_yield = false
  this.bullet_force = 100
  if(saveData.difficultyMode == "easy") {
    this.bullet_force = 50
  }

  this.adjust_position_enabled = false

  this.bullet_enemy_factor = 150;

  this.parent_id = parent_id

  this.reflected = false
  this.body.SetBullet(true)

  this.do_yield = false

  this.bullet_goo_factor = 0.33

}

FighterBullet.prototype.start_death = function(death) {
  this.dying = death
  this.dying_duration = this.dying_length
  this.died = true
}

FighterBullet.prototype.collide_with = function(other) {
  if(this.dying)//ensures the collision effect only activates once
    return
  if(other === this.player) {
    this.start_death("hit_player")
    if(!this.is_silenced()) {
      music_player.play_sound("fbullethit")
      var vel = this.body.GetLinearVelocity().Copy()
      vel.Normalize()
      //utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
      if(this.player.is_gooed() > 0) {
        vel.Multiply(this.bullet_force * this.bullet_goo_factor)
        this.player.body.ApplyImpulse(vel, this.player.body.GetWorldCenter())
      } else {
        vel.Multiply(this.bullet_force)
        this.player.body.ApplyImpulse(vel, this.player.body.GetWorldCenter())
      }
      this.impulse_game_state.reset_combo()
    }
  }
  else if(other.is_enemy)
  {
    if(other.type === "fighter_bullet") return

    this.start_death("hit_enemy")

    if(other.id != this.parent_id || this.reflected) {
      if(!this.is_silenced()) {
        music_player.play_sound("fbullethit")
        if(other.type === 'fighter' ) {
          other.frenzy_charge = 0
        }
        var vel = this.body.GetLinearVelocity().Copy()
        vel.Normalize()
        //var bullet_angle = utils.atan(this.body.GetPosition(), other.body.GetPosition())

        var factor = 1;

        if(other.id == this.parent_id) {
          factor *= 1.5
          if (other.is_gooed()) {
            factor *= 2;
          }
        } else if (other.type === "fighter") {
          factor *= 1.5
        } else if (other.type === "orbiter") {
          other.weaken()
        }

        vel.Multiply(this.bullet_enemy_factor * other.force * factor)
        other.open(1500)
        //var force = new box_2d.b2Vec2(this.bullet_force * factor * Math.cos(bullet_angle), this.bullet_force * factor * Math.sin(bullet_angle));

        other.body.ApplyImpulse(vel, other.body.GetWorldCenter())
      }
    }
  }

}

FighterBullet.prototype.move = function() {

  if (this.is_gooed()) {
    this.body.ApplyImpulse(new box_2d.b2Vec2(0.7 * this.v.x, 0.7 * this.v.y), this.body.GetWorldCenter())
  } else {
    this.body.ApplyImpulse(this.v, this.body.GetWorldCenter())
  }

  this.set_heading(utils.atan({x: 0, y: 0}, this.v))
}

FighterBullet.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  var temp_dir = new box_2d.b2Vec2(this.body.GetPosition().x - attack_loc.x, this.body.GetPosition().y - attack_loc.y)
  temp_dir.Normalize()
  temp_dir.Multiply(impulse_force)
  this.v.Add(temp_dir)
  this.reflected = true
  this.open(this.open_period)

}

FighterBullet.prototype.check_death = function()
{
  //check if enemy has intersected polygon, if so die
  for(var k = 0; k < this.level.obstacle_polygons.length; k++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[k], this.body.GetPosition()))
    {
      this.start_death("kill")

      return
    }
  }
  if(this.body.GetPosition().x <= -5 || this.body.GetPosition().x >= constants.canvasWidth/constants.drawFactor + 5 || this.body.GetPosition().y <= -5 || this.body.GetPosition().y >= constants.canvasWidth/constants.drawFactor + 5)
  {
    this.start_death("kill")
  }
}

FighterBullet.prototype.player_hit_proc = function() {
}

module.exports = FighterBullet;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../enemy/enemy.js":30,"../load/save_data.js":69,"../vendor/box2d.js":97}],35:[function(require,module,exports){
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

Goo.prototype = new Enemy()

Goo.prototype.constructor = Goo

Goo.prototype.goo_color = [238, 232, 170]//[255, 255, 120]

Goo.prototype.goo_color_rgb = "rgb(238, 232, 170)"

function Goo(world, x, y, id, impulse_game_state) {
  if(world === undefined) return  //allows others to use Goo as super-class
  this.type = "goo"
  this.silence_outside_arena = false
  this.init(world, x, y, id, impulse_game_state)

  this.death_radius = 2

  this.life_time = 7500 //goo automatically dies after this

  this.do_yield = false

  this.goo_radius_small = 3;

  this.goo_radius_big = 11;

  if(saveData.difficultyMode == "easy") {
    this.goo_radius_big = 10;
  }

  this.goo_radius = this.goo_radius_small

  this.goo_change_transition = 500

  this.goo_expand_period = 2500

  if(saveData.difficultyMode == "easy")
    this.goo_expand_period = 3500

  this.goo_state = "small"

  this.goo_state_timer = 0

  this.slow_factor = 0.2

  this.default_heading = false

  this.spin_rate = 6000
}

Goo.prototype.additional_processing = function(dt) {

  this.body.SetAngle(this.body.GetAngle() + 2*Math.PI * dt/this.spin_rate)
  if(this.goo_state_timer > 0) {
    this.goo_state_timer -= dt;
  }

  if(this.goo_state == "expanding") {

    if(this.goo_state_timer <= 0) {
      this.goo_state = "big"
      this.goo_radius = this.goo_radius_big;
      this.goo_state_timer = this.goo_expand_period;
    } else {
      var t = (this.goo_change_transition - this.goo_state_timer)/this.goo_change_transition;

      var bezier_p = utils.bezierInterpolate(0.15, 0.85, t);

      this.goo_radius = this.goo_radius_small * (1-bezier_p) +  (bezier_p) * this.goo_radius_big

    }

  } else if(this.goo_state == "big" && this.goo_state_timer <= 0) {
    this.goo_state = "shrinking";
    music_player.play_sound("goo")
    this.goo_state_timer = this.goo_change_transition;

  } else if (this.goo_state == "shrinking") {
    if(this.goo_state_timer <= 0) {
      this.goo_state = "small"
      this.goo_radius = this.goo_radius_small;
      this.goo_state_timer = this.goo_expand_period;
    } else {
      var t = (this.goo_change_transition - this.goo_state_timer)/this.goo_change_transition;
      var bezier_p = utils.bezierInterpolate(0.15, 0.85, t)
      this.goo_radius = this.goo_radius_small * (bezier_p) +  (1-bezier_p) * this.goo_radius_big
    }
  }

  if(!this.is_silenced()) {
    this.body.SetLinearDamping(enemyData[this.type].lin_damp)
    this.force = enemyData[this.type].force
  } else {
    this.body.SetLinearDamping(enemyData[this.type].lin_damp * 0.3)
    this.force = enemyData[this.type].force * 0.3
  }

  this.check_area_of_effect()
}

Goo.prototype.check_area_of_effect = function() {
  if(!this.is_silenced() && utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) < this.goo_radius) {
    this.area_effect(this.player)
  }

  for(var j = 0; j < this.level.enemies.length; j++) {
    if(!this.is_silenced() && utils.pDist(this.body.GetPosition(), this.level.enemies[j].body.GetPosition()) < this.goo_radius)
    {
      if(this.level.enemies[j].type != this.type)
        this.area_effect(this.level.enemies[j])
    }
  }
}

Goo.prototype.player_hit_proc = function() {

}

Goo.prototype.area_effect = function(obj) {
  obj.goo(100)
}

Goo.prototype.final_draw = function(context, draw_factor) {
  if(this.is_silenced()) {
    return
  }

  if(!this.dying) {

    context.beginPath()
    context.strokeStyle = this.color
    context.fillStyle = this.color
    context.lineWidth = 2
    context.save();
    context.globalAlpha *= .3
    context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, this.goo_radius * draw_factor, 0, 2*Math.PI * 0.999)
    context.stroke()
    context.fill()
    context.restore();
  }
  if(this.goo_state == "big") {
    uiRenderUtils.drawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, 1 - this.goo_state_timer / this.goo_expand_period)
  }
}

Goo.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {

  if(!this.is_silenced()) {
      if(this.goo_state == "shrinking") {
        this.goo_state_timer = this.goo_change_transition - this.goo_state_timer;
        this.goo_state = "expanding"
      } else if(this.goo_state == "big") {
        this.goo_state_timer = this.goo_expand_period
      } else if(this.goo_state == "small") {
        this.goo_state_timer = this.goo_change_transition
        this.goo_state = "expanding"
        music_player.play_sound("goo")
      }

    }
}

Goo.prototype.modify_movement_vector = function(dir) {
  //apply impulse to move enemy

  if(this.goo_state != "small" && !this.is_silenced())
  {
    dir.Multiply(this.slow_factor)
  }

  dir.Multiply(this.force)


}

module.exports = Goo;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../load/save_data.js":69,"../render/ui.js":82}],36:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');
var HarpoonHead = require('../enemy/harpoon_head.js');
var Orbiter = require('../enemy/orbiter.js');

Harpoon.prototype = new Enemy()

Harpoon.prototype.constructor = Harpoon

function Harpoon(world, x, y, id, impulse_game_state) {
  if(world === undefined) return
  this.type = "harpoon"

  var h_vertices = []

  var s_radius = .3

  h_vertices.push(new box_2d.b2Vec2(s_radius*Math.cos(Math.PI*0), s_radius*Math.sin(Math.PI*0)))
  h_vertices.push(new box_2d.b2Vec2(s_radius*Math.cos(Math.PI*5/6), s_radius*Math.sin(Math.PI*5/6)))
  h_vertices.push(new box_2d.b2Vec2(s_radius*Math.cos(Math.PI*7/6), s_radius*Math.sin(Math.PI*7/6)))
  this.harpoon_shape = h_vertices

  this.silence_outside_arena = true
  this.entered_arena_delay = 1000

  this.init(world, x, y, id, impulse_game_state)

  if(world == null) return

  this.death_radius = 2

  this.fast_factor = 3

  // Estimated harpoon length.
  this.harpoon_length = 17
  if(saveData.difficultyMode == "easy") {
    this.harpoon_length = 13
  }

  this.goalPt = null

  this.harpoon_color = "orange"

  this.harpoon_state = "inactive"

  this.harpooned_force = 6
  if(saveData.difficultyMode == "easy") {
    this.harpooned_force = 4.5
  }
  this.harpooned_goo_factor = 0.33

  this.harpoonhead_force = 400
  if(saveData.difficultyMode == "easy") {
    this.harpoonhead_force = 50
  }
  this.harpoonhead_retract_force = 1.2
  if(saveData.difficultyMode == "easy") {
    this.harpoonhead_retract_force = 0.6
  }

  this.harpoon_explode_force = 70

  this.safe_radius = this.player.impulse_radius
  this.safe_radius_buffer = 2

  this.safe_distance = this.harpoon_length * 0.8

  this.pathfinding_delay_far = 40;
  this.pathfinding_delay_near = 20;

  this.pathfinding_delay = 40;

  this.offset_multiplier = Math.random() < 0.5 ? 1 : -1;
  this.silence_length = 500 //after being hit by player, becomes silenced

  this.harpoon_joint = null

  this.do_yield = false

  this.twitch = false

  this.check_harpoon_interval = 5//so that we don't check for harpooning every frame
  this.check_harpoon_timer = this.check_harpoon_interval

  this.state = "seek" //seek or flee

  this.check_for_good_target_point_interval = 15

  this.check_for_good_target_point_timer = this.check_for_good_target_point_interval

  this.check_safety_interval = 8

  this.check_safety_timer = this.check_safety_interval

  this.silence_on_impulse_length = 1000

  this.default_heading = false

  this.max_guesses = 4

  this.harpoon_head_defaut_dist = Math.sqrt(2)/2+Math.sqrt(6)/6 - 0.4

  this.add_harpoon_head()

  this.harpoon_disengage_dist = 3
  this.harpoon_disengage_id = null

  this.delay_between_shots = 1000
  this.harpooned_target = null
  this.cautious = false
  this.harpoonable = false


  this.dire_harpoon = false
  this.attack_mode = true
  this.extra_adjust = false
  this.adjust_position_factor = 1;

  if(saveData.difficultyMode == "normal") {
    this.adjust_position_factor = 0.8;
  }
  this.orbiter_checks = [0, -1, 1, -2, 2, -4, 4, -8, 8, -12, 12, -16, 16, -20, 20]

  this.has_bulk_draw = true
  this.bulk_draw_nums = 3
  this.die_on_player_collision = false
}

Harpoon.prototype.add_harpoon_head = function() {
  var vloc = this.get_virtual_harpoon_loc();
  this.harpoon_head = new HarpoonHead(this.world, vloc.x, vloc.y, this.id + 10000, this.impulse_game_state, this)
}

Harpoon.prototype.draw_harpoon_head = function(context, draw_factor, latest_color) {
  this.harpoon_head.color = latest_color

  this.harpoon_head.color_silenced = this.color_silenced
  this.harpoon_head.durations = this.durations

  this.harpoon_head.draw(context, draw_factor)

}


Harpoon.prototype.get_target_path = Orbiter.prototype.get_target_path

Harpoon.prototype.enemy_move = Orbiter.prototype.move

Harpoon.prototype.player_hit_proc = function() {}

Harpoon.prototype.move = function() {
  if(this.harpoon_state != "inactive" && this.harpoon_state != "engaged") {return}//do not move if harpooning

  if(this.harpoon_state == "engaged") {
    var dir = new box_2d.b2Vec2(this.body.GetPosition().x - this.harpooned_target.body.GetPosition().x, this.body.GetPosition().y - this.harpooned_target.body.GetPosition().y)
    dir.Normalize()
    dir.Multiply(this.harpooned_force)
    if(this.harpooned_target==this.player && this.is_gooed()) {
      dir.Multiply(this.harpooned_goo_factor)
    }
    this.harpooned_target.body.ApplyImpulse(dir, this.body.GetWorldCenter())
    if(this.harpooned_target != this.player) {
      this.harpooned_target.open(1500)
      if (this.harpooned_target.type == "tank") {
        this.harpooned_target.durations["volatile"] = 1500
      }
    }
    return
  }

  if(this.path == null) {
    this.pathfinding_counter = this.pathfinding_delay
  }
  this.enemy_move()

}

Harpoon.prototype.get_harpoon_target_pt = function() {
  return this.player.body.GetPosition().Copy()
}

Harpoon.prototype.no_sight = function() {
  return !utils.isVisible(this.body.GetPosition(), this.player.body.GetPosition(), this.level.obstacle_edges)
}

Harpoon.prototype.can_harpoon = function() {
  return (!this.is_silenced() && this.entered_arena && !this.dying && this.harpoon_state == "inactive" && utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)
   && utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) <= this.harpoon_length)
}

Harpoon.prototype.get_virtual_harpoon_loc = function() {
  return new box_2d.b2Vec2(this.body.GetPosition().x+(this.harpoon_head_defaut_dist)*(enemyData[this.type].effective_radius) * Math.cos(this.actual_heading),
    this.body.GetPosition().y+(this.harpoon_head_defaut_dist)*(enemyData[this.type].effective_radius) * Math.sin(this.actual_heading))
}

Harpoon.prototype.set_heading = function(heading) {

  this.heading_timer -= 1
  if(this.heading_timer <= 0) {
    this.body.SetAngle(heading)
    this.heading_timer = this.heading_gap
    this.harpoon_head.body.SetAngle(this.harpoon_head.actual_heading)
  }
  this.actual_heading = heading
}


Harpoon.prototype.additional_processing = function(dt) {

  if(this.harpoon_state == "inactive") {
    this.set_heading_to(this.player.body.GetPosition())
  } else if(this.harpoon_state == "engaged") {
    this.set_heading_to(this.harpooned_target.body.GetPosition())
  } else {
    this.set_heading_to(this.harpoon_head.body.GetPosition())
  }

  this.adjust_position_enabled = (this.harpoon_state == "inactive")

  if(utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) < this.safe_distance * 1.5) {
    this.pathfinding_delay = this.pathfinding_delay_near;

  } else {
    this.pathfinding_delay = this.pathfinding_delay_far;
  }

  if(this.harpoon_state == "inactive") {
    this.harpoon_head.body.SetPosition(this.get_virtual_harpoon_loc())
    this.harpoon_head.set_heading(this.actual_heading)
  } else if(this.harpoon_state == "fire") {
    var dir = utils.atan(this.body.GetPosition(), this.harpoon_head.body.GetPosition())
    this.harpoon_head.set_heading(dir)
    if(this.harpoon_head.body.m_linearVelocity.Length() < 1) {
      this.harpoon_state = "retract"
    }
  } else if(this.harpoon_state == "retract") {
    if (!this.is_silenced() || !utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
      var dir = utils.atan(this.harpoon_head.body.GetPosition(), this.body.GetPosition())
      this.harpoon_head.body.ApplyImpulse(new box_2d.b2Vec2(this.harpoonhead_retract_force * Math.cos(dir), this.harpoonhead_retract_force * Math.sin(dir)), this.harpoon_head.body.GetWorldCenter())
      this.harpoon_head.set_heading(Math.PI + dir)
      if(utils.pDist(this.harpoon_head.body.GetPosition(), this.body.GetPosition()) < this.harpoon_head_defaut_dist * 1.1) {
        this.harpoon_state = "inactive"
        this.silence(this.delay_between_shots, true)
        if (this.delay_between_shots > this.recovery_timer) {
          this.recovery_interval = this.delay_between_shots
          this.recovery_timer = this.delay_between_shots
        }
        this.harpoon_disengage_id = null
      }
    }
  } else if(this.harpoon_state == "engaged") {

    this.harpoon_head.body.SetPosition(new box_2d.b2Vec2(-100, -100));
  } else if(this.harpoon_state == "retract_ready") {
    var dir = new box_2d.b2Vec2(this.player.body.GetPosition().x - this.body.GetPosition().x, this.player.body.GetPosition().y - this.body.GetPosition().y)
    dir.Normalize()
    dir.Multiply(this.player.radius * 2)
    var pos = this.harpooned_target.body.GetPosition().Copy()//this.player.body.GetPosition().Copy()
    pos.Subtract(dir)
    this.harpoon_head.body.SetPosition(pos)
    var dir = utils.atan(this.body.GetPosition(), this.harpoon_head.body.GetPosition())
    this.harpoon_head.set_heading(dir)
    this.harpoon_state = "retract"
    this.harpooned_target = null
  }

  if(this.check_safety_timer <= 0) {
    var cur_dist = utils.pDist(this.player.body.GetPosition(), this.body.GetPosition())
    var cur_vis = utils.isVisible(this.body.GetPosition(), this.player.body.GetPosition(), this.level.obstacle_edges)

    this.attack_mode = false

    this.check_safety_timer = this.check_safety_interval
  }
  this.check_safety_timer -= 1

  if(this.check_harpoon_timer > 0)
    this.check_harpoon_timer -= 1

  if(this.check_harpoon_timer <= 0) {
    if(this.no_sight() || this.impulse_game_state.is_boss_level) {
      this.harpoonable = true
      if(this.can_harpoon() ) {
        music_player.play_sound("hfire")
        this.harpoon_state = "fire"
        this.harpoon_dir = utils.atan(this.harpoon_head.body.GetPosition(), this.get_harpoon_target_pt())
        this.harpoon_head.body.ApplyImpulse(new box_2d.b2Vec2(this.harpoonhead_force * Math.cos(this.harpoon_dir), this.harpoonhead_force * Math.sin(this.harpoon_dir)), this.harpoon_head.body.GetWorldCenter())
        this.harpoon_head.set_heading(this.harpoon_dir)
      }
    }
    else {
      this.harpoonable = false
    }

    this.check_cancel_harpoon()
    this.check_harpoon_timer = this.check_harpoon_interval
  }

  //harpoonhead stuff
  if(this.harpoon_head.durations["open"] > 0) {
    this.harpoon_head.durations["open"] -= dt;
  }
}

Harpoon.prototype.process_death = function(enemy_index, dt) {
  if(this.died && (this.dying != "hit_player" || this.dying_duration < this.dying_length - 50)) {//the moment the enemy starts to die, give a couple steps to resolve collisions, then remove the body from play
    this.died = false

    this.level.dead_enemies.push(enemy_index)
  }

  if(this.dying && this.dying_duration < 0)
  {//if expired, dispose of it
    this.level.expired_enemies.push(enemy_index)
    return true
  }

  if(this.dying )
  {//if dying, expire
    /*if(this.harpoon_joint != null) {
      this.world.DestroyJoint(this.harpoon_joint)
      this.harpoin_joint = null;
    }*/

    this.dying_duration -= dt
    this.harpoon_head.dying_duration -= dt
    return true
  }

  return false
}

Harpoon.prototype.modify_movement_vector = function(dir) {
  if(!utils.checkBounds(-3, this.body.GetPosition(), constants.drawFactor)) {
    dir.Multiply(this.fast_factor)
  }

  dir.Multiply(this.force);
}

Harpoon.prototype.start_death = function(death) {

  this.disengage_harpoon();

  this.dying = death
  this.dying_duration = this.dying_length
  this.died = true
  if(this.dying == "kill" && !this.player.dying) {
    //if the player hasn't died and this was a kill, increase score
    this.impulse_game_state.game_numbers.kills +=1
    if(enemyData[this.type].proxy)
      enemyData[enemyData[this.type].proxy].kills += 1
    else
      enemyData[this.type].kills += 1
    if(!this.level.is_boss_level) {
      var score_value = this.impulse_game_state.game_numbers.combo * this.score_value
      if(saveData.optionsData.score_labels)
        this.impulse_game_state.addScoreLabel(score_value, this.color, this.body.GetPosition().x, this.body.GetPosition().y, 20)
      this.impulse_game_state.game_numbers.score += score_value
      this.impulse_game_state.increment_combo()
      this.impulse_game_state.check_cutoffs()
    }
  }
  if (this.dying != "fade") {
    this.level.add_fragments(this.type, this.body.GetPosition(), this.body.GetLinearVelocity())
    this.additional_death_prep(death)
    music_player.play_sound("sdeath")
  }

  this.harpoon_head.start_death(this.dying == "fade" ? "fade" : "accident")

}


Harpoon.prototype.check_cancel_harpoon = function() {
  if(this.is_silenced() && (this.harpoon_state != "inactive")) {
    this.disengage_harpoon()
  }
  if(this.harpoon_state == "engaged" && (!utils.checkBounds(1, this.harpooned_target.body.GetPosition(), constants.drawFactor) || this.harpooned_target.dying || utils.pDist(this.harpooned_target.body.GetPosition(), this.body.GetPosition()) < this.harpoon_disengage_dist)) {
    this.disengage_harpoon()
  }
  /*else if(this.harpoon_state == "engaged" && !utils.checkBounds(0, this.body.GetPosition(), draw_factor)) {
    this.disengage_harpoon()
  }*/
  else if(this.harpoon_state == "engaged" && this.player.dying) {
    this.disengage_harpoon()
  }
}

Harpoon.prototype.pre_draw = function(context, draw_factor) {
  var latest_color = this.get_current_color_with_status()
  if(latest_color != this.color || this.dying) {
      context.save()
      context.strokeStyle = latest_color
      context.lineWidth = 3
      context.globalAlpha *= .5

      var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0
      if (this.dying)
        context.globalAlpha *= (1 - prog)
      context.beginPath()
      if(this.harpoon_state != "engaged" && this.harpoon_state != "retract_ready") {
        context.moveTo(this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor)
        context.lineTo(this.harpoon_head.body.GetPosition().x * draw_factor, this.harpoon_head.body.GetPosition().y * draw_factor)

      } else {
        context.moveTo(this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor)
        context.lineTo(this.harpooned_target.body.GetPosition().x * draw_factor, this.harpooned_target.body.GetPosition().y * draw_factor)
      }
      context.stroke()
      context.restore()
    }
}

Harpoon.prototype.additional_drawing = function(context, draw_factor) {

  if(this.harpoon_state != "engaged" && this.harpoon_state != "retract_ready") {
    this.draw_harpoon_head(context, draw_factor, this.get_current_color_with_status())
  }
}

Harpoon.prototype.bulk_draw_start = function(context, draw_factor, num) {

  context.save()
  context.beginPath()
  context.strokeStyle = this.color
  if(num == 1) {
    context.lineWidth = 2
    context.globalAlpha *= .2
  }
  if(num == 2) {
    context.lineWidth = 3
    context.globalAlpha *= .5
  }
  if(num == 3) {
    context.lineWidth = 2
    context.strokeStyle = "gray";
  }
}

Harpoon.prototype.bulk_draw = function(context, draw_factor, num) {
  // Do not draw if dying. We cannot change the opacity for a given enemy for bulk-draw, so we just don't draw at all.
  if (this.dying) {
    return
  }
  if(num == 1) {
    if(!this.is_silenced() && this.entered_arena && this.harpoon_state == "inactive") {
      context.moveTo(this.body.GetPosition().x*draw_factor + this.harpoon_length * draw_factor, this.body.GetPosition().y*draw_factor)
      context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, this.harpoon_length * draw_factor, 0, 2*Math.PI * 0.999)
    }

  }
  if(num == 2) {
    if(this.get_current_color_with_status() != this.color || this.dying) return
    if(this.harpoon_state != "engaged" && this.harpoon_state != "retract_ready") {
      context.moveTo(this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor)
      context.lineTo(this.harpoon_head.body.GetPosition().x * draw_factor, this.harpoon_head.body.GetPosition().y * draw_factor)
    } else {
      context.moveTo(this.body.GetPosition().x * draw_factor, this.body.GetPosition().y * draw_factor)
      context.lineTo(this.harpooned_target.body.GetPosition().x * draw_factor, this.harpooned_target.body.GetPosition().y * draw_factor)
    }
  }
  if(num == 3) {
    if(this.recovery_timer > 0 && !this.dying && !this.is_locked()) {
      uiRenderUtils.bulkDrawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, 1 - this.recovery_timer/this.recovery_interval)
    }
  }
}

Harpoon.prototype.bulk_draw_end = function(context, draw_factor, num) {
  context.stroke()
  context.restore()
}

Harpoon.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.silence(this.silence_length, true)
  if (this.silence_length > this.recovery_timer) {
    this.recovery_interval = this.silence_length
    this.recovery_timer = this.silence_length
  }
}

Harpoon.prototype.disengage_harpoon = function() {
  if(this.harpoon_state == "engaged") {

    //this.world.DestroyJoint(this.harpoon_joint)
    this.harpoon_joint = null
    this.harpoon_state = "retract_ready"
    this.harpoon_disengage_id = this.harpooned_target.id
  }
}

Harpoon.prototype.engage_harpoon = function(target) {
  if(this.harpoon_state != "engaged" && !this.dying && !this.is_silenced() && target.id !== this.harpoon_disengage_id) {
    music_player.play_sound("hhit")
    this.harpoon_state = "engaged"
    this.harpooned_target = target
    if(this.harpooned_target == this.player) {
      this.impulse_game_state.reset_combo()
    }
  }
}

module.exports = Harpoon;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../enemy/harpoon_head.js":37,"../enemy/orbiter.js":39,"../load/save_data.js":69,"../render/ui.js":82,"../vendor/box2d.js":97}],37:[function(require,module,exports){
var Enemy = require('../enemy/enemy.js');

HarpoonHead.prototype = new Enemy()

HarpoonHead.prototype.constructor = HarpoonHead

function HarpoonHead(world, x, y, id, impulse_game_state, harpoon) {

  if(world === undefined) return

  this.harpoon = harpoon
  if (harpoon) {
    this.status_duration = this.harpoon.status_duration
  }

  this.type="harpoonhead"

  this.init(world, x, y, id, impulse_game_state)

  this.require_open = false

  this.die_on_player_collision = false
}

HarpoonHead.prototype.additional_processing = function(other) {
}

HarpoonHead.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.harpoon.silence(this.harpoon.silence_length)
}

HarpoonHead.prototype.set_heading = function(heading) {
  this.actual_heading = heading
}

HarpoonHead.prototype.player_hit_proc = function() {}

// HarpoonHead's durations is set to Harpoon's durations so that the two will be the same color. This means we must disable things like "open"
HarpoonHead.prototype.open = function() {}

module.exports = HarpoonHead;

},{"../enemy/enemy.js":30}],38:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var saveData = require('../load/save_data.js');

var Enemy = require('../enemy/enemy.js');

Mote.prototype = new Enemy()

Mote.prototype.constructor = Mote

function Mote(world, x, y, id, impulse_game_state) {
  this.type = "mote"

  this.silence_outside_arena = false
  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  this.death_radius = 5
  this.default_heading = false

  this.spin_rate = 2000

  this.cautious = true
  this.extra_adjust = false

  this.adjust_position_factor = 1

  this.silence_duration = 3000
  if(saveData.difficultyMode == "easy")
    this.silence_duration = 2000

}

Mote.prototype.player_hit_proc = function() {
  if(!this.is_silenced())
    this.player.silence(this.silence_duration, true)
}

Mote.prototype.additional_processing = function(dt) {
  this.body.SetAngle(this.body.GetAngle() + 2*Math.PI * dt/this.spin_rate)
}

Mote.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
	if(this.is_silenced()) {
		this.body.ApplyImpulse(new box_2d.b2Vec2(impulse_force*Math.cos(hit_angle), impulse_force*Math.sin(hit_angle)),
    this.body.GetWorldCenter())
    this.open(this.open_period)
  }
}

module.exports = Mote;

},{"../enemy/enemy.js":30,"../load/save_data.js":69,"../vendor/box2d.js":97}],39:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

Orbiter.prototype = new Enemy()

Orbiter.prototype.constructor = Orbiter

function Orbiter(world, x, y, id, impulse_game_state) {
  this.type = "orbiter"

  this.silence_outside_arena = true
  this.entered_arena_delay = 500
  this.init(world, x, y, id, impulse_game_state)
  if(!impulse_game_state) return

  this.special_mode = false

  this.death_radius = 5

  this.safe_distance = this.player.impulse_radius * 1.25

  this.offset_multiplier = 1;

  this.pathfinding_delay = 18;
  this.has_bulk_draw = true
  this.bulk_draw_nums = 1

  this.pathfinding_delay_far = 18;
  this.pathfinding_delay_near = 9;

  this.cautious = true;
  this.fast_factor = 2;

  this.attack_mode = false;

  this.orbiter_force = 50;
  this.twitch = true
  this.goo_extra_force_factor = 3;

  this.orbiter_checks = [-1, 1, -4, 4, -8, 8, -12, 12, -16, 16]

  this.max_guesses = 4

  this.weakened_duration = 0
  this.weakened_interval = 250
  this.orig_lin_damp = enemyData[this.type].lin_damp
  this.extra_adjust = false
  this.adjust_position_factor = 0.5

  this.check_in_poly_interval = 200
  this.check_in_poly_timer = 100

  this.orbit_radius = 1.2 * this.player.impulse_radius

  this.no_death_on_open = false

  this.gooed_lin_damp_factor = 2;
}

Orbiter.prototype.additional_drawing = function(context, draw_factor) {

  return
  context.beginPath()
  var orig_angle = utils.atan(this.player.body.GetPosition(), this.body.GetPosition());
  var divisions = 64;
  var offsets = this.orbiter_checks
  var offset = 0;
  while(offset< offsets.length) {

    var guess_angle = orig_angle + (Math.PI * 2) / divisions * offsets[offset] * this.offset_multiplier;


    var tempPt = new box_2d.b2Vec2(this.player.body.GetPosition().x + Math.cos(guess_angle) * this.safe_distance,
                              this.player.body.GetPosition().y + Math.sin(guess_angle) * this.safe_distance)

    context.moveTo(tempPt.x * draw_factor + 5, tempPt.y *draw_factor)
    context.arc(tempPt.x * draw_factor, tempPt.y * draw_factor, 5, 0, 2* Math.PI)
    offset += 1;
  }
  context.fillStyle = "white"
  context.fill()
}

Orbiter.prototype.additional_processing = function(dt) {
  if(utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) < this.safe_distance * 1.5) {
    this.pathfinding_delay = this.pathfinding_delay_near;

  } else {
    this.pathfinding_delay = this.pathfinding_delay_far;
  }

  this.check_in_poly_timer -= dt
  if(this.check_in_poly_timer < 0) {
    var in_poly = false
    for(var i = 0; i < this.level.boundary_polygons.length; i++)
    {
      if(utils.pointInPolygon(this.level.boundary_polygons[i], this.body.GetPosition()))
      {
        in_poly = true
      }
    }

    this.in_poly = in_poly
    this.check_in_poly_timer = this.check_in_poly_interval
  }


  if(this.weakened_duration > 0) {
    this.weakened_duration -= dt
    this.lin_damp = 3
  } else {
    this.lin_damp = this.orig_lin_damp
  }

  this.set_heading_to(this.player.body.GetPosition())

  if(!this.entered_arena && utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.silence(this.entered_arena_delay, true)
    this.entered_arena = true
  }

  if(this.entered_arena_timer > 0) {
    this.entered_arena_timer -= dt
  }

  if(!utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.entered_arena = false
    this.silence(100, true)
  }

  this.attack_mode = (this.player.attacking && !this.player.point_in_impulse_angle(this.body.GetPosition())) || this.player.is_locked() || this.player.is_silenced() || this.player.is_confused()
  this.charging = this.attack_mode && !this.dying && this.path && this.path.length == 1 && this.path[0] == this.player.body.GetPosition() && !this.is_silenced() && this.entered_arena
  this.cautious = !this.charging
}

Orbiter.prototype.get_target_path = function() {

  //console.log("GET PATH AT "+(new Date()).getTime()+" "+this.id)
  //console.log(this.pathfinding_delay)

  if(!this.attack_mode) {
    var orig_angle = utils.atan(this.player.body.GetPosition(), this.body.GetPosition());
    var divisions = 64;
    var offsets = this.orbiter_checks
    var offset = 0;

    if(this.twitch)
      this.offset_multiplier *= -1;

    var is_valid = false;
    var this_path = null;

    var guesses = 0
    while(!is_valid && offset< offsets.length) {

      //console.log("checking "+offsets[offset])
      var guess_angle = orig_angle + (Math.PI * 2) / divisions * offsets[offset] * this.offset_multiplier;

      is_valid = true;


      var tempPt = new box_2d.b2Vec2(this.player.body.GetPosition().x + Math.cos(guess_angle) * this.safe_distance,
                              this.player.body.GetPosition().y + Math.sin(guess_angle) * this.safe_distance)
      for(var k = 0; k < this.level.boundary_polygons.length; k++)
      {
        if(utils.pointInPolygon(this.level.boundary_polygons[k], tempPt))
        {
          //console.log("inside boundary polygon")
          is_valid = false
          break;
        }
      }

      if(is_valid) {
        this_path = this.impulse_game_state.visibility_graph.query(this.body.GetPosition(), tempPt, this.impulse_game_state.level.pick_alt_path)

        if(!this_path.path) {
          //console.log("no path to loc")
          is_valid = false;
          guesses += 1
          if(guesses >= this.max_guesses)
            break
        } else if(!utils.pathSafeFromPt(this_path.path, this.player.body.GetPosition(), this.orbit_radius)) {
          //console.log("not safe from player")
          is_valid = false
          guesses += 1
          if(guesses >= this.max_guesses)
            break
        }
      }

      if(is_valid) {
        //console.log("RETURNING default path")
        return this_path;
      }
      offset += 1;
    }


    if(!this.impulse_game_state.is_boss_level) {
      if(utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) < this.orbit_radius)
        return this.impulse_game_state.visibility_graph.query(this.body.GetPosition(), utils.getSafestSpawnPoint(this, this.player, this.impulse_game_state.level_name, this.impulse_game_state.level.pick_alt_path))
      else
        return this.impulse_game_state.visibility_graph.query(this.body.GetPosition(), this.player.body.GetPosition(), this.impulse_game_state.level.pick_alt_path)
    } else {
      return {path: null, dist: null}
    }
  } else {
    return this.impulse_game_state.visibility_graph.query(this.body.GetPosition(), this.player.body.GetPosition(), this.impulse_game_state.level.pick_alt_path)
  }
}

Orbiter.prototype.move = function() {

  if(this.player.dying) return //stop moving once player dies

  if(this.is_locked()) return


  this.pathfinding_counter += 1
  if ((this.path == null) || /*this.pathfinding_counter % 8 == 0 ||*/ this.pathfinding_counter >= this.pathfinding_delay) {

    //only update path every four frames. Pretty expensive operation
    var target_path = this.get_target_path()
    if(!target_path.path) return

    if((this.path && this.path.length == 0) || (this.path && this.path.length == 1 && target_path.path[target_path.length - 1] == this.player.body.GetPosition()) || this.pathfinding_counter >= this.pathfinding_delay || (this.path && !utils.isVisible(this.body.GetPosition(), this.path[0], this.level.obstacle_edges)))
    //if this.path.length == 1, there is nothing in between the enemy and the player. In this case, it's not too expensive to check every frame to make sure the enemy doesn't kill itself
    {
        var new_path = target_path;

      if(new_path.path!=null) {
        this.path = new_path.path
        this.path_dist = new_path.dist
        this.target_point = this.path[this.path.length - 1]
      }
      this.pathfinding_counter = Math.floor(Math.random()*.1 * this.pathfinding_delay)
    }

  }

  if(!this.path)
  {
    return
  }

  var endPt = this.path[0]
  if ( this.pathfinding_counter % 4 == 0) {
    while(this.path.length > 0 && utils.pDist(endPt, this.body.GetPosition())<1)
    //get rid of points that are too close
    {
      this.path = this.path.slice(1)
      endPt = this.path[0]
    }

    if(!endPt || !utils.isVisible(this.body.GetPosition(), endPt, this.level.obstacle_edges))
    //if it's not possible to reach the point
    {
      return
    }

    if(utils.isVisible(this.body.GetPosition(), this.player.body.GetPosition(), this.level.obstacle_edges) && this.target_point == this.player.body.GetPosition()) {//if we can see the player directly, immediately make that the path
      this.path = [this.player.body.GetPosition()]
      endPt = this.path[0]
    }
  }
  if(endPt)
    this.move_to(endPt)
}

Orbiter.prototype.modify_movement_vector = function(dir) {

  if(this.charging) {
    dir.Multiply(this.fast_factor)
    dir.Multiply(this.force)
  } else {
    if((this.in_poly && this.cautious && this.in_poly_slow_duration > 0) || this.is_gooed())//move cautiously...isn't very effective in preventing accidental deaths
    {
      dir.Multiply(this.slow_force)
    }
    else
    {
      if (this.is_gooed()) {
        dir.Multiply(this.goo_extra_force_factor)

      }
      dir.Multiply(this.force)
    }
  }
}

Orbiter.prototype.move_to = function(endPt) {

  var dir = new box_2d.b2Vec2(endPt.x - this.body.GetPosition().x, endPt.y - this.body.GetPosition().y)
  dir.Normalize()

  this.modify_movement_vector(dir)

  this.body.ApplyImpulse(dir, this.body.GetWorldCenter())

}

Orbiter.prototype.player_hit_proc = function() {
  var orbiter_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
  var a = new box_2d.b2Vec2(this.orbiter_force * Math.cos(orbiter_angle), this.orbiter_force * Math.sin(orbiter_angle))
  this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.orbiter_force * Math.cos(orbiter_angle), this.orbiter_force * Math.sin(orbiter_angle)), this.player.body.GetWorldCenter())
}

Orbiter.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.weaken()
}

Orbiter.prototype.weaken = function() {
  // makes lin_damp smaller
  this.weakened_duration = this.weakened_interval
}

Orbiter.prototype.bulk_draw_start = function(context, draw_factor, num) {

  context.save()
  context.beginPath()
  context.strokeStyle = this.color
  if(num == 1) {
    context.lineWidth = 2
    context.strokeStyle = "gray";
  }
}

Orbiter.prototype.bulk_draw = function(context, draw_factor, num) {
  // Do not draw if dying. We cannot change the opacity for a given enemy for bulk-draw, so we just don't draw at all.
  if (this.dying) {
    return
  }
  if(num == 1) {
    if(this.recovery_timer > 0 && !this.dying && !this.is_locked()) {
      uiRenderUtils.bulkDrawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, 1 - this.recovery_timer/this.recovery_interval)
    }
  }
}

Orbiter.prototype.bulk_draw_end = function(context, draw_factor, num) {
  context.stroke()
  context.restore()
}

module.exports = Orbiter;

},{"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../render/ui.js":82,"../vendor/box2d.js":97}],40:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var saveData = require('../load/save_data.js');

var FighterBullet = require('../enemy/fighter_bullet.js');

PiercingFighterBullet.prototype = new FighterBullet()

PiercingFighterBullet.prototype.constructor = PiercingFighterBullet

function PiercingFighterBullet(world, x, y, id, impulse_game_state, dir, parent_id) {
  this.type = "piercing_fighter_bullet"

  this.init(world, x, y, id, impulse_game_state)

  if(world === null) return

  this.special_mode = false

  this.death_radius = 5

  this.parent_id = parent_id

  this.v = new box_2d.b2Vec2(Math.cos(dir), Math.sin(dir))
  this.v.Normalize()
  this.v.Multiply(this.force)

  if(saveData.difficultyMode == "easy") {
    this.v.Multiply(0.5)
  }
  this.do_yield = false
  this.bullet_force = 100
  if(saveData.difficultyMode == "easy") {
    this.bullet_force = 50
  }

  this.reflected = false
  this.body.SetBullet(true)

  this.adjust_position_enabled = false

  this.bullet_goo_factor = 0.33

  this.bullet_enemy_factor = 150;

  this.bullet_goo_factor = 0.33

}

PiercingFighterBullet.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
}

PiercingFighterBullet.prototype.collide_with = FighterBullet.prototype.collide_with

module.exports = PiercingFighterBullet;

},{"../enemy/fighter_bullet.js":34,"../load/save_data.js":69,"../vendor/box2d.js":97}],41:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

Slingshot.prototype = new Enemy()

Slingshot.prototype.constructor = Slingshot

function Slingshot(world, x, y, id, impulse_game_state) {
  this.type = "slingshot"

  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  if (saveData.difficultyMode == "easy") {
    this.force *= 0.8
  }

  this.slingshot_force = 50 //force that the spear impulses the player

  this.first_time_in_arena = false

  this.death_radius = 5

  this.slow_factor = 0.5

  this.do_yield = false

  this.real_color = this.color

  this.slingshot_mode = false
  this.slingshot_point = null
  this.slingshot_duration = 0
  this.slingshot_interval = 100
  this.slingshot_multiplier = 1
  this.empowered_duration = 0
  this.empowered_interval = 750

  this.empowered_force = 100

  this.cautious = false

  this.additional_statuses = ["empowered"]

  this.orig_lin_damp = enemyData[this.type].lin_damp
  this.slingshot_lin_damp = 6

}

Slingshot.prototype.enemy_move = Enemy.prototype.move

Slingshot.prototype.move = function() {
  if(this.slingshot_mode) {
    if(!this.is_locked()) {
      var dir = new box_2d.b2Vec2(this.slingshot_point.x - this.body.GetPosition().x, this.slingshot_point.y - this.body.GetPosition().y)
      dir.Multiply(this.slingshot_multiplier)
      if(this.is_gooed())
        dir.Multiply(this.slow_factor)
      this.body.ApplyImpulse(dir, this.body.GetWorldCenter())

      var heading = utils.atan(this.body.GetPosition(), this.slingshot_point)
      this.body.SetAngle(heading)
    }
  }
  else {
    this.enemy_move()
  }
}

Slingshot.prototype.modify_movement_vector = function(dir) {
  if(this.is_gooed()) {
    dir.Multiply(this.slow_factor)
  }
  if (!this.first_time_in_arena) {
    dir.Multiply(this.slow_factor)
  }
  dir.Multiply(this.force)
}

Slingshot.prototype.additional_processing = function(dt) {

  if(this.slingshot_mode && (this.slingshot_duration <= 0 && utils.pDist(this.slingshot_point, this.body.GetPosition()) < 1) || this.is_silenced()) {
    this.slingshot_mode = false
    this.lin_damp = this.orig_lin_damp
  }

  // Slow the slingshot until it enters the arena, with a small buffer.
  if (!this.first_time_in_arena && utils.checkBounds(1, this.body.GetPosition(), constants.drawFactor)) {
    this.first_time_in_arena = true
  }

  this.special_mode = this.empowered_duration > 0

  this.color = this.empowered_duration > 0 ? "red" : this.real_color
  this.empowered = this.empowered_duration > 0 && !this.is_silenced()

  if(this.slingshot_duration > 0)
  {
    this.slingshot_duration -= dt
  }

  if(this.empowered_duration > 0)
  {
    this.empowered_duration -= dt
  }
}



Slingshot.prototype.player_hit_proc = function() {

  var spear_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
  var a = new box_2d.b2Vec2(Math.cos(spear_angle), Math.sin(spear_angle))
  if(this.empowered_duration > 0)
  {
    a.Multiply(this.empowered_force)
  }
  else
  {
    a.Multiply(this.slingshot_force)
  }
  this.player.body.ApplyImpulse(a, this.player.body.GetWorldCenter())

}

Slingshot.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {

  if(!this.is_silenced()) {
    this.slingshot_point = this.body.GetPosition().Copy()
    this.slingshot_mode = true
    this.slingshot_duration = this.slingshot_interval
    this.empowered_duration = this.empowered_interval
    this.lin_damp = this.slingshot_lin_damp
    music_player.play_sound("sshot")
  }
}

Slingshot.prototype.get_current_status = function() {

  if(!this.dying) {
      if(this.is_locked()) {
        return 'stunned';
      } else if(this.color_silenced) {
        return 'silenced'
      } else if(this.is_gooed()) {
        return "gooed"
      } else if (this.is_disabled()) {
        return 'silenced';
      }
    }

    return this.get_additional_current_status()
}


Slingshot.prototype.get_additional_color_for_status = function(status) {
  if(status == "empowered") {
    return "red"
  }
}

Slingshot.prototype.get_additional_current_status = function() {

  if(!this.dying) {
      if(this.empowered_duration > 0) {
        return "empowered";
      }
  }
  return "normal"
}


Slingshot.prototype.get_slingshot_hooks = function(hook) {

  var angle = this.body.GetAngle() + Math.PI * 2/3 * hook;
  return {x: this.body.GetPosition().x + Math.cos(angle) * this.effective_radius * 3/4,  y: this.body.GetPosition().y + Math.sin(angle) * this.effective_radius * 3/4}
}

Slingshot.prototype.additional_drawing = function(context, draw_factor) {
  if(this.slingshot_mode && !this.dying) {
    context.beginPath()
    context.strokeStyle = this.color
    context.lineWidth = 2
    context.moveTo(this.slingshot_point.x * draw_factor, this.slingshot_point.y * draw_factor)
    var point_one = this.get_slingshot_hooks(1)
    context.lineTo(point_one.x * draw_factor, point_one.y * draw_factor)
    var point_two = this.get_slingshot_hooks(2)
    context.moveTo(this.slingshot_point.x * draw_factor, this.slingshot_point.y * draw_factor)
    context.lineTo(point_two.x * draw_factor, point_two.y * draw_factor)
    context.stroke()
  }
}

module.exports = Slingshot;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../load/save_data.js":69,"../vendor/box2d.js":97}],42:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

Spear.prototype = new Enemy()

Spear.prototype.constructor = Spear

function Spear(world, x, y, id, impulse_game_state) {
  this.type = "spear"
  this.silence_outside_arena = true
  this.entered_arena_delay = 500
  this.init(world, x, y, id, impulse_game_state)

  this.fast_factor = 5

  this.spear_force = 30 //force that the spear impulses the player

  if(saveData.difficultyMode == "easy") // since the player is heavier in easy mode
    this.spear_force = 45

  this.death_radius = 5

  this.stun_length = 3000 //after being hit by player, becomes stunned
  this.has_bulk_draw = true
  this.bulk_draw_nums = 1

  this.do_yield = false

  this.require_open = true

  this.hit_proc_on_silenced = true
}

Spear.prototype.enemy_move = Enemy.prototype.move

Spear.prototype.move = function() {

  if(this.player.dying) return //stop moving once player dies

  if(this.is_locked()) return //locked

  if (utils.isVisible(this.body.GetPosition(), this.player.body.GetPosition(), this.level.obstacle_edges)) {
    this.path = [this.player.body.GetPosition()]
    this.move_to(this.player.body.GetPosition())
  } else {
    this.enemy_move()
  }

}

Spear.prototype.modify_movement_vector = function(dir) {
  if(this.special_mode)
  {
    dir.Multiply(this.fast_factor)
  }
  if(this.is_gooed()) {
    dir.Multiply(this.slow_factor)
  }
  dir.Multiply(this.force)
}

Spear.prototype.additional_processing = function(dt) {
  this.special_mode = !this.dying && this.path && this.path.length == 1 && !this.is_silenced() && this.entered_arena
}

Spear.prototype.player_hit_proc = function() {
  if(!this.is_silenced()) {
    var spear_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
    var a = new box_2d.b2Vec2(this.spear_force * Math.cos(spear_angle), this.spear_force * Math.sin(spear_angle))
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(this.spear_force * Math.cos(spear_angle), this.spear_force * Math.sin(spear_angle)), this.player.body.GetWorldCenter())
  }
}

Spear.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.silence(this.stun_length)
  if (this.stun_length > this.recovery_timer) {
    this.recovery_interval = this.stun_length
    this.recovery_timer = this.stun_length
  }
}

Spear.prototype.additional_drawing = function(context, draw_factor) {

}

Spear.prototype.bulk_draw_start = function(context, draw_factor, num) {

  context.save()
  context.beginPath()
  context.strokeStyle = this.color
  if(num == 1) {
    context.lineWidth = 2
    context.strokeStyle = "gray";
  }
}

Spear.prototype.bulk_draw = function(context, draw_factor, num) {
  // Do not draw if dying. We cannot change the opacity for a given enemy for bulk-draw, so we just don't draw at all.
  if (this.dying) {
    return
  }
  if(num == 1) {
    if(this.recovery_timer > 0 && !this.dying && !this.is_locked()) {
      uiRenderUtils.bulkDrawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, 1 - this.recovery_timer/this.recovery_interval)
    }
  }
}

Spear.prototype.bulk_draw_end = function(context, draw_factor, num) {
  context.stroke()
  context.restore()
}

module.exports = Spear;

},{"../core/utils.js":11,"../enemy/enemy.js":30,"../load/save_data.js":69,"../render/ui.js":82,"../vendor/box2d.js":97}],43:[function(require,module,exports){
var saveData = require('../load/save_data.js');

var Enemy = require('../enemy/enemy.js');

Stunner.prototype = new Enemy()

Stunner.prototype.constructor = Stunner

function Stunner(world, x, y, id, impulse_game_state) {
  this.type = 'stunner';
  this.silence_outside_arena = false

  this.init(world, x, y, id, impulse_game_state)

  if(!impulse_game_state) return

  this.do_yield = false

  if (saveData.difficultyMode == "normal") {
  	this.force *= 1.3;
  }
}

module.exports = Stunner;

},{"../enemy/enemy.js":30,"../load/save_data.js":69}],44:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var enemyData = require('../data/enemy_data.js');
var saveData = require('../load/save_data.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

Tank.prototype = new Enemy()

Tank.prototype.constructor = Tank

function Tank(world, x, y, id, impulse_game_state) {
  this.type = "tank"

  this.silence_outside_arena = false

  this.init(world, x, y, id, impulse_game_state)

  this.special_mode = false

  this.tank_force = 100 //force that the spear impulses the player

  if(saveData.difficultyMode == "easy")
    this.tank_force = 80

  if (saveData.difficultyMode == "normal") {}

  this.death_radius = 5

  this.detonate_timer = 200
  this.detonate_duration = 200
  this.death_delay = 200
  this.bomb_factor = 6

  if(saveData.difficultyMode == "easy") {
    this.bomb_factor = 5
  }

  this.tank_collision_fudge_period = 75;

  this.activated = false

  this.cause_of_death = null
  this.do_yield = false

  this.default_heading = false

  this.spin_rate = 4000

  this.require_open = true;
  this.open_period = 500;
  this.additional_statuses = ["volatile"]
  this.durations["volatile"] = 0

  this.has_bulk_draw = true
  this.bulk_draw_nums = 1

  this.volatile_interval = 1500
}

Tank.prototype.additional_processing = function(dt) {

  this.special_mode = !this.is_silenced();

  if (this.tank_collision_fudge_timer > 0) {
    this.tank_collision_fudge_timer -= dt;
  }

  if(this.durations["volatile"] > 0) {
    this.durations["volatile"] -= dt
  }
}

Tank.prototype.additional_death_prep = function(death) {
  this.color = "red"
}

Tank.prototype.activated_processing = function(dt) {
  if(this.activated)
  {
    this.color = "red"
    if(this.detonate_timer <= 0 && !this.dying)
    {
      this.start_death(this.cause_of_death)
      this.explode()
    }
    if(this.detonate_timer > 0)
    {
      this.detonate_timer -= dt
    }
  }

}

Tank.prototype.check_death = function()
{

  //check if enemy has intersected polygon, if so die
  for(var k = 0; k < this.level.obstacle_polygons.length; k++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[k], this.body.GetPosition()))
    {
      if(!this.is_silenced() && this.durations["volatile"] > 0) {
        this.activated = true
        this.cause_of_death = "kill"
      }
      else if(this.durations["open"] > 0) {
        this.start_death("kill")
      } else {
        this.start_death("accident")
      }
      return
    }
  }
}


Tank.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  this.durations["impulsed"] += this.impulsed_duration
  this.process_impulse_specific(attack_loc, impulse_force, hit_angle)
  this.open(this.open_period)
  if (this.is_gooed()) {
    this.body.ApplyImpulse(new box_2d.b2Vec2(1.3 * impulse_force*Math.cos(hit_angle), 1.3 * impulse_force*Math.sin(hit_angle)), this.body.GetWorldCenter())
  } else {
    if (saveData.difficultyMode == "easy") {
      this.body.ApplyImpulse(new box_2d.b2Vec2(1.25 * impulse_force*Math.cos(hit_angle), 1.25 * impulse_force*Math.sin(hit_angle)), this.body.GetWorldCenter())
    } else {
      this.body.ApplyImpulse(new box_2d.b2Vec2(impulse_force*Math.cos(hit_angle), impulse_force*Math.sin(hit_angle)), this.body.GetWorldCenter())
    }

  }

  if (this.tank_collision_fudge_timer > 0 && !this.dying && !this.activated && !this.is_silenced()) {
    this.activated = true
    this.cause_of_death = "kill"
  }
}

Tank.prototype.process_impulse_specific = function(attack_loc, impulse_force, hit_angle) {
  this.durations["volatile"] = this.volatile_interval
}

Tank.prototype.collide_with = function(other, this_body, other_body) {
  if(other.type === "tank") {
    if (this.durations["volatile"] > 0 && !this.dying && !this.activated && !this.is_silenced())
    {
      this.activated = true
      this.cause_of_death = "kill"
    } else {
      // If we've collided with a tank, but we haven't received the impulse,
      // it's possible that the impulse is about to hit. Give a short grace period.
      this.tank_collision_fudge_timer = this.tank_collision_fudge_period;
    }
  }

  if(this.dying || this.activated)//ensures the collision effect only activates once
    return

  if(other === this.player) {
    if(!this.is_silenced()) {
      this.activated = true
      this.cause_of_death = "hit_player"
      this.impulse_game_state.reset_combo()
    }
    else {
      this.start_death("hit_player")
    }
  } else if(other.isEnemy) {
    if(other.durations["open"] > 0) {
      this.open(other.durations["open"])
    }
}
}

Tank.prototype.explode = function() {
  if(utils.pDist(this.body.GetPosition(), this.player.body.GetPosition()) <= this.effective_radius * this.bomb_factor)
  {
    var tank_angle = utils.atan(this.body.GetPosition(), this.player.body.GetPosition())
    var force = this.tank_force;
    this.player.body.ApplyImpulse(new box_2d.b2Vec2(force * Math.cos(tank_angle), force * Math.sin(tank_angle)), this.player.body.GetWorldCenter())
    // If you get caught in explosion, your combo resets.
    if (this.cause_of_death != "hit_player") {
      this.impulse_game_state.reset_combo()
    }
  }

  for(var i = 0; i < this.level.enemies.length; i++)
  {

    if(this.level.enemies[i] !== this && utils.pDist(this.body.GetPosition(), this.level.enemies[i].body.GetPosition()) <= this.effective_radius * this.bomb_factor)
    {
      var _angle = utils.atan(this.body.GetPosition(), this.level.enemies[i].body.GetPosition())
      this.level.enemies[i].body.ApplyImpulse(new box_2d.b2Vec2(this.tank_force * Math.cos(_angle), this.tank_force * Math.sin(_angle)), this.level.enemies[i].body.GetWorldCenter())
      this.level.enemies[i].open(1500)

    }
  }
}

Tank.prototype.additional_drawing = function(context, draw_factor, latest_color) {

  var prog = this.dying ? Math.min((this.dying_length - this.dying_duration) / this.dying_length, 1) : 0;
  context.save();
  context.globalAlpha *= 1 - prog
  var this_angle = this.body.GetAngle() + Math.PI/4;

  var lighten_multiplier = 1;
  if(this.is_lightened()) {
    lighten_multiplier /= this.lighten_factor
  }

  if(this.activated && this.detonate_timer > 0)
  {
    context.beginPath()
    context.strokeStyle = "red";
    context.lineWidth = 5
    context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, this.effective_radius * (this.bomb_factor * (1 - this.detonate_timer/this.detonate_duration)) * draw_factor, 0, 2*Math.PI*0.999)
    context.stroke()
  } else if(!this.is_silenced() && this.durations["volatile"] > 0) {
    context.beginPath()
    context.strokeStyle = "red"
    context.lineWidth = 2
    context.globalAlpha *= .5
    context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, this.effective_radius * this.bomb_factor * draw_factor, 0, 2*Math.PI * 0.999)
    context.stroke()

  }
  context.restore();

}

Tank.prototype.bulk_draw_start = function(context, draw_factor, num) {
  context.save()
  context.beginPath()
  context.lineWidth = 2
  context.globalAlpha *= .5
  context.strokeStyle = enemyData[this.type].color
}

Tank.prototype.bulk_draw = function(context, draw_factor, num) {
  // Do not draw if dying. We cannot change the opacity for a given enemy for bulk-draw, so we just don't draw at all.
  if (this.dying) {
    return
  }
  if(this.durations["volatile"] <= 0 && !this.is_silenced()) {
    context.moveTo(this.body.GetPosition().x*draw_factor +  this.effective_radius * this.bomb_factor * draw_factor, this.body.GetPosition().y*draw_factor)
    context.arc(this.body.GetPosition().x*draw_factor, this.body.GetPosition().y*draw_factor, this.effective_radius * this.bomb_factor * draw_factor, 0, 2*Math.PI*0.999)
  }
}

Tank.prototype.bulk_draw_end = function(context, draw_factor, num) {
  context.stroke()
  context.restore()
}

Tank.prototype.get_additional_color_for_status = function(status) {
  if(status == "volatile") {
    return "red"
  }
}

Tank.prototype.get_current_status = function() {
  if(this.dying) {
    return "volatile"
  }

  if(!this.dying) {
    if(this.is_locked()) {
      return 'stunned';
    } else if(this.color_silenced) {
      return 'silenced'
    } if(this.durations["volatile"] > 0) {
      return "volatile"
    } else if(this.is_gooed()) {
      return "gooed"
    } else if (this.is_disabled()) {
      return 'silenced';
    }
    if(this.durations["impulsed"] > 0) {
      return "impulsed"
    }
  }

  return this.get_additional_current_status()
}

module.exports = Tank;

},{"../core/utils.js":11,"../data/enemy_data.js":15,"../enemy/enemy.js":30,"../load/save_data.js":69,"../vendor/box2d.js":97}],45:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Enemy = require('../enemy/enemy.js');

Troll.prototype = new Enemy()

Troll.prototype.constructor = Troll

function Troll(world, x, y, id, impulse_game_state) {

  this.type = "troll"
  this.silence_outside_arena = true
  this.entered_arena_delay = 1000

  this.init(world, x, y, id, impulse_game_state)

  this.do_yield = false

  this.trolling = false

  this.fast_factor = 3;

  this.troll_switch_interval = 400
  this.trolling_time_factor = 4

  if (saveData.difficultyMode == "easy") {
    this.troll_switch_interval = 600
    this.trolling_time_factor = 3
  }
  this.troll_switch_timer = this.troll_switch_interval


  this.cautious = false

  this.default_heading = false

  this.spin_rate = 1000

  this.confused_targets = []
  this.confused_duration = 250

  this.has_bulk_draw = true
  this.bulk_draw_nums = 2

  this.short_troll_period = 1000
  if(saveData.difficultyMode == "easy") {
    this.short_troll_period = 750
  }

  this.extra_adjust = true

  this.long_troll_period = 5000
  if(saveData.difficultyMode == "easy") {
    this.long_troll_period = 2500
  }
}

Troll.prototype.additional_processing = function(dt) {

  var time = (new Date()).getTime()
  if(!this.is_silenced()) {
    this.set_heading(this.actual_heading + 2*Math.PI * dt/this.spin_rate)
  }

  if(time % (this.trolling_time_factor * this.troll_switch_interval) < this.troll_switch_interval) {
    this.silence(this.troll_switch_interval - time % (this.trolling_time_factor * this.troll_switch_interval), true)
  }

  for(var index = this.confused_targets.length-1; index >= 0; index--) {
    this.confused_targets[index].timer -= dt
    if(this.confused_targets[index].timer <= 0) {
      this.confused_targets.splice(index, 1)
    }
  }

   if(!this.entered_arena && utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.silence(this.entered_arena_delay, true)
    this.entered_arena = true
  }

  if(this.entered_arena_timer > 0) {
    this.entered_arena_timer -= dt
  }

  if(!utils.checkBounds(0, this.body.GetPosition(), constants.drawFactor)) {
    this.entered_arena = false
  }
}

Troll.prototype.additional_drawing = function(context, draw_factor, latest_color) {

  if(this.dying || this.is_silenced()) return
  context.save()
  for(var index in this.confused_targets) {
    context.beginPath()
    var prop = this.confused_targets[index].timer/this.confused_duration
    context.globalAlpha *= Math.max(0, (1 - 2*Math.abs(prop-0.5))/.5)
    context.moveTo(this.confused_targets[index].object.body.GetPosition().x * draw_factor, this.confused_targets[index].object.body.GetPosition().y* draw_factor)
    context.lineTo(this.body.GetPosition().x* draw_factor, this.body.GetPosition().y* draw_factor)
    context.lineWidth = 3
    context.strokeStyle = this.color
    context.stroke()
    context.globalAlpha /= Math.max(0, (1 - 2*Math.abs(prop-0.5))/.5)
  }
  context.restore()
}

Troll.prototype.process_impulse = function(attack_loc, impulse_force, hit_angle) {
  if(!this.is_silenced() && this.entered_arena) {
    this.body.ApplyImpulse(new box_2d.b2Vec2(.3 * impulse_force*Math.cos(hit_angle), .3 * impulse_force*Math.sin(hit_angle)),
    this.body.GetWorldCenter())
    this.player.confuse(this.short_troll_period)
    music_player.play_sound("pwheel")
    this.confused_targets.push({object: this.player, timer: this.confused_duration})
    this.impulse_game_state.reset_combo();
  }
  else {
    this.body.ApplyImpulse(new box_2d.b2Vec2(impulse_force*Math.cos(hit_angle), impulse_force*Math.sin(hit_angle)),
    this.body.GetWorldCenter())
  }
  this.open(this.open_period)
  this.durations["impulsed"] += this.impulsed_duration
}

Troll.prototype.player_hit_proc = function() {
  if(!this.is_silenced()) {
    this.player.confuse(this.long_troll_period)
    music_player.play_sound("pwheel")
  }
}

Troll.prototype.bulk_draw_start = function(context, draw_factor, num) {

  context.save()
  context.beginPath()
  context.strokeStyle = this.color
  if(num == 1) {
    context.lineWidth = 2
    context.strokeStyle = "gray";
  }
  if(num == 2) {
    context.lineWidth = 2
    context.strokeStyle = this.color
  }
}

Troll.prototype.bulk_draw = function(context, draw_factor, num) {
  // Do not draw if dying. We cannot change the opacity for a given enemy for bulk-draw, so we just don't draw at all.
  if (this.dying) {
    return
  }
  if(num == 1) {
    if(this.recovery_timer > 0 && !this.dying && !this.is_locked()) {
      uiRenderUtils.bulkDrawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, 1 - this.recovery_timer/this.recovery_interval)
    }
  }
  if(num == 2) {
    var time = (new Date()).getTime()
    if(!this.is_silenced() && time % (this.trolling_time_factor * this.troll_switch_interval) > this.troll_switch_interval) {
      var troll_prop = (time % (this.trolling_time_factor * this.troll_switch_interval) - this.troll_switch_interval)/ ((this.trolling_time_factor-1)*this.troll_switch_interval)
      uiRenderUtils.bulkDrawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.effective_radius, troll_prop)
    }
  }
}

Troll.prototype.bulk_draw_end = function(context, draw_factor, num) {
  context.stroke()
  context.restore()
}

Troll.prototype.modify_movement_vector = function(dir) {
  if(!utils.checkBounds(-3, this.body.GetPosition(), constants.drawFactor)) {
    dir.Multiply(this.fast_factor)
  }

  dir.Multiply(this.force);
}

module.exports = Troll;

},{"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../enemy/enemy.js":30,"../load/save_data.js":69,"../render/ui.js":82,"../vendor/box2d.js":97}],46:[function(require,module,exports){
var constants = require('../data/constants.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');

var Background = require('../render/background.js');
var Fader = require('../game_states/fader_util.js');
var GameState = require('../game_states/game_state.js');
var IconButton = require('../ui/icon_button.js');

CreditsState.prototype = new GameState

CreditsState.prototype.constructor = CreditsState

function CreditsState(opts) {
  // after_main_game
  // main_game_hive_numbers
  // main_game_args

  this.after_main_game = opts.after_main_game;
  this.main_game_hive_numbers = opts.main_game_hive_numbers;
  this.main_game_args = opts.main_game_args;
  this.bg_drawn = false
  this.start_clicked = false
  this.buttons = []
  var _this = this


  this.buttons.push(new IconButton("KEVIN MACLEOD", 16, constants.levelWidth/2 - 250, constants.levelHeight/2 + 50, 150, 70, "white", constants.colors["impulse_blue"], function(){window.open("http://incompetech.com")}, "note"))
  this.buttons.push(new IconButton("MATT MCFARLAND", 16, constants.levelWidth/2, constants.levelHeight/2 + 50, 150, 70, "white", constants.colors["impulse_blue"], function(){window.open("http://www.mattmcfarland.com")}, "note"))
  this.buttons.push(new IconButton("SUBTLE PATTERNS", 16, constants.levelWidth/2 + 250, constants.levelHeight/2 + 50, 150, 70, "white", constants.colors["impulse_blue"], function(){window.open("http://www.subtlepatterns.com")}, "texture"))
  this.buttons.push(new IconButton("JAY SALVAT", 16, constants.levelWidth/2 - 150, constants.levelHeight/2+180, 150, 70, "white", constants.colors["impulse_blue"], function(){window.open("http://buzz.jaysalvat.com/")}, "audio"))
  this.buttons.push(new IconButton("ERIN CATTO", 16, constants.levelWidth/2 + 150, constants.levelHeight/2+180, 150, 70, "white", constants.colors["impulse_blue"], function(){window.open("http://box2d.org/")}, "physics_engine"))
  this.buttons[0].extra_text = "MAIN MENU MUSIC"
  this.buttons[1].extra_text = "ALL OTHER MUSIC"
  this.buttons[2].extra_text = "TEXTURES"
  this.buttons[3].extra_text = "AUDIO API"
  this.buttons[4].extra_text = "PHYSICS ENGINE"

  if (!this.after_main_game) {
    this.buttons.push(new IconButton("BACK", 16, constants.levelWidth/2, constants.levelHeight/2 + 260, 60, 65, "white", constants.colors["impulse_blue"], function(){
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
      });
    }, "back"))
  }

  this.fader = new Fader({
    "fade_in": 250,
    "fade_out": 250
  });
  this.fader.set_animation("fade_in");
}

CreditsState.prototype.process = function(dt) {
  this.fader.process(dt);
}

CreditsState.prototype.draw = function(ctx, bg_ctx) {
  if(!this.bg_drawn) {
    bg_canvas.setAttribute("style", "")
    game_engine.setBg(graphics.menuBackground);
    this.bg_drawn = true
  }

  ctx.save()

  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }

  uiRenderUtils.drawPorcelainLogo(ctx, 400, 180);
  ctx.font = '16px Open Sans'
  ctx.fillStyle = constants.colors["impulse_blue"]
  ctx.textAlign = "center"
  ctx.shadowColor = ctx.fillStyle
  ctx.fillText("CREATED BY", constants.levelWidth/2, 60)
  ctx.fillText("WITH CREDIT TO", constants.levelWidth/2, 260)
  if (this.after_main_game) {
    ctx.save();
    ctx.globalAlpha *= 0.5;
    ctx.font = '16px Open Sans'
    ctx.fillStyle = constants.colors["impulse_blue"];
    ctx.fillText("PRESS ANY KEY TO CONTINUE", constants.levelWidth/2, constants.levelHeight - 30);
    ctx.restore();
  }

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(ctx)
  }
  ctx.restore();
}

CreditsState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
}

CreditsState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

CreditsState.prototype.on_key_down = function (keyCode) {
  if (this.after_main_game) {
    var _this = this;
    this.fader.set_animation("fade_out", function() {
      game_engine.switch_game_state(gsKeys.REWARD_GAME_STATE, {
        hive_numbers: _this.main_game_hive_numbers,
        main_game: true,
        game_args: _this.main_game_args
      });
    });
  }
}

module.exports = CreditsState;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../data/constants.js":13,"../data/sprite_data.js":18,"../game_states/fader_util.js":47,"../game_states/game_state.js":49,"../render/background.js":73,"../render/ui.js":82,"../ui/icon_button.js":87}],47:[function(require,module,exports){
// A class that helps keep track of the visibility for game states that want to fade in and out.
// Also keeps track of the animation so that game states can have multiple different fade in/ out animations.
// Only allows a single animation at a timer.

/*
 * param {Object} animation_durations Map of fade animations to the length of that animation in milliseconds.
 */
var Fader = function(animation_durations) {
  this.animation_durations = animation_durations;
  this.animation = null;
  this.timer = 0;
};

Fader.prototype.set_animation = function(animation, opt_callback) {
  if (this.animation == null) {
    this.animation = animation;
    this.timer = this.animation_durations[animation];
    this.callback = opt_callback;
  }
}

Fader.prototype.process = function(dt) {
  if (this.animation != null && this.timer > 0) {
    this.timer -= dt;
  }
  if (this.animation != null && this.timer <= 0) {
    if (this.callback) {
      this.callback();
    }
    this.animation = null;
  }
}

Fader.prototype.get_animation_progress = function() {
  if (this.animation) {
    return Math.min(1 - this.timer / this.animation_durations[this.animation], 1);
  }
  return 0;
}

Fader.prototype.get_current_animation = function() {
  return this.animation;
}

module.exports = Fader;

},{}],48:[function(require,module,exports){
var constants = require('../data/constants.js');
var controls = require('../core/controls.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Background = require('../render/background.js');
var Fader = require('../game_states/fader_util.js');
var GameState = require('../game_states/game_state.js');
var HiveNumbers = require('../load/hive_numbers.js');
var IconButton = require('../ui/icon_button.js');

GameOverState.prototype = new GameState

GameOverState.prototype.constructor = GameOverState

function GameOverState(opts) {
  // final_game_numbers
  // level
  // world_num
  // visibility_graph
  // args

  this.game_numbers = opts.final_game_numbers
  this.level = opts.level
  this.level_name = this.level.level_name
  this.buttons = []
  this.world_num = opts.world_num
  this.visibility_graph = opts.visibility_graph
  this.bg_drawn = false
  this.victory = opts.args.victory
  this.color = constants.colors['world '+ this.world_num + ' bright']
  this.restart_button = new IconButton("RETRY", 16, constants.levelWidth - 70, constants.levelHeight - 40, 60, 65, this.color, "white", function(_this){
    return function(){
      var hive_numbers = new HiveNumbers(_this.world_num, false)
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.IMPULSE_GAME_STATE, {
          world: _this.world_num,
          level: _this.level,
          visibility_graph: _this.visibility_graph,
          hive_numbers: hive_numbers,
          main_game: false
        });
      });
    }
  }(this), "start")
  this.buttons.push(this.restart_button);

  this.restart_button.keyCode = controls.keys.RESTART_KEY;
  if(saveData.optionsData.control_hand == "right") {
    this.restart_button.extra_text = "R KEY"
  } else {
    this.restart_button.extra_text = "SHIFT KEY"
  }

 this.buttons.push(new IconButton("MENU", 16, 70, constants.levelHeight/2+260, 60, 65, this.color, "white", function(_this){return function(){
    if(_this.world_num) {
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.WORLD_MAP_STATE, {
          world: _this.world_num,
          is_practice_mode: true
        });
        game_engine.setBg(graphics.menuBackground);
      });
    }
    else {
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
        game_engine.setBg(graphics.menuBackground);
      });
    }
  }}(this), "back"))


  if(!this.level.is_boss_level) {
    this.high_score = opts.args.high_score
    this.best_time = opts.args.best_time ? opts.args.best_time : 0
  } else {
    this.best_time = opts.args.best_time ? opts.args.best_time : 0
  }

  music_player.stop_bg()

  this.fader = new Fader({
    "fade_in": 500,
    "fade_out": 250
  });
  this.fader.set_animation("fade_in");
}

GameOverState.prototype.process = function(dt) {
  this.fader.process(dt);
}

GameOverState.prototype.draw = function(ctx, bg_ctx) {

  if(!this.bg_drawn) {
    this.level.impulse_game_state= null
    bg_canvas.setAttribute("style", "display:none" )

    bg_ctx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
    this.level.draw_bg(bg_ctx)
    var world_bg_ctx = layers.worldMenuBgCanvas.getContext('2d')
    uiRenderUtils.tessellateBg(world_bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+this.world_num)
    this.bg_drawn = true
    bg_ctx.translate(-constants.sideBarWidth, 0)
    this.bg_drawn = true
  }
  ctx.save()
  ctx.fillStyle = constants.colors["world "+this.world_num+" dark"]
  ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)
  ctx.globalAlpha *= uiRenderUtils.getBgOpacity(this.world_num);
  ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
  ctx.restore()

  ctx.save();
  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }

  if(!this.level.is_boss_level) {
    ctx.globalAlpha /= 3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 230, 80, true)
    ctx.globalAlpha *= 3

    ctx.save();
    ctx.globalAlpha *= 0.5;
    ctx.fillStyle = "white"
    ctx.font = '20px Open Sans'
    if (saveData.difficultyMode == "normal") {
      ctx.textAlign = 'center'
      ctx.fillText("HARD MODE", constants.levelWidth/2, 180)
    }
    ctx.restore();

    ctx.beginPath()
    ctx.fillStyle = this.color
    ctx.font = '42px Open Sans'
    ctx.textAlign = 'center'

    ctx.fillText(this.level_name, constants.levelWidth/2, 240)
    ctx.fill()
    ctx.font = '36px Open Sans';
    if(this.victory) {
      ctx.fillStyle = "white"
      ctx.fillText("VICTORY", constants.levelWidth/2, 300)
    } else {
      ctx.fillStyle = "red"
      ctx.fillText("GAME OVER", constants.levelWidth/2, 300)
    }

    var score_y = 380;
    var score_label_y = 420;

    ctx.fillStyle = this.color
    ctx.font = '20px Open Sans'
    ctx.fillText("GAME TIME ", constants.levelWidth/2 + 100, score_y)
    ctx.font = '42px Open Sans'
    ctx.fillText(this.game_numbers.last_time, constants.levelWidth/2 + 100, score_label_y)
    ctx.fillStyle = this.color
    ctx.font = '20px Open Sans'
    ctx.fillText("SCORE", constants.levelWidth/2 - 100, score_y)

    ctx.font = '42px Open Sans'
    ctx.fillText(this.game_numbers.score, constants.levelWidth/2 - 100, score_label_y)

    var line_y = 440
    if (!this.high_score) {
      ctx.beginPath();
      ctx.moveTo(250, line_y);
      ctx.lineTo(350, line_y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = this.color;
      ctx.stroke();
    }

    if (!this.best_time) {
      ctx.beginPath();
      ctx.moveTo(450, line_y);
      ctx.lineTo(550, line_y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = this.color;
      ctx.stroke();
    }

    var high_score_y = 445;
    var best_score_y = 500;
    var best_score_label_y = 470;

    if(this.best_time) {
      ctx.fillStyle = this.color
      ctx.font = '16px Open Sans'
      ctx.fillText("NEW BEST TIME!", constants.levelWidth/2 + 100, high_score_y)
    } else {
      ctx.save();
      ctx.globalAlpha *= 0.6;
      ctx.fillStyle = this.color
      ctx.font = '12px Open Sans'
      ctx.fillText("BEST TIME", constants.levelWidth/2  + 100, best_score_label_y)
      ctx.font = '28px Open Sans'
      if (saveData.hasBeatenLevel(this.level_name)) {
        ctx.font = '28px Open Sans'
        ctx.fillText(utils.convertSecondsToTimeString(saveData.getBestTimeForLevel(this.level_name)),
          constants.levelWidth/2 + 100, best_score_y)
      } else {
        ctx.font = '24px Open Sans'
        ctx.fillText("UNDEFEATED",
          constants.levelWidth/2 + 100, best_score_y)
      }
      ctx.restore();
    }
  } else {


    ctx.globalAlpha /= 3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 230, 80, true)
    ctx.globalAlpha *= 3

    ctx.save();
    ctx.globalAlpha *= 0.5;
    ctx.fillStyle = "white"
    ctx.font = '20px Open Sans'
    if (saveData.difficultyMode == "normal") {
      ctx.textAlign = 'center';
      ctx.fillText("HARD MODE", constants.levelWidth/2, 180)
    }
    ctx.restore();

    ctx.beginPath()
    ctx.fillStyle = this.color
    ctx.textAlign = 'center'

    ctx.font = '32px Open Sans'
    ctx.fillText(levelData.bossNames[this.world_num], constants.levelWidth/2, 240)

    ctx.fill()
    ctx.font = '48px Open Sans';
    if (this.level.boss_victory) {
      ctx.fillStyle = "white"
      ctx.fillText("VICTORY", constants.levelWidth/2, 300)
    } else {
      ctx.fillStyle = "red"
      ctx.fillText("GAME OVER", constants.levelWidth/2, 300)
    }

    var score_y = 380;
    var score_label_y = 420;

    ctx.fillStyle = this.color
    ctx.font = '20px Open Sans'
    ctx.fillText("GAME TIME ", constants.levelWidth/2, score_y)
    ctx.font = '42px Open Sans'
    ctx.fillText(this.game_numbers.last_time, constants.levelWidth/2, score_label_y)

    var line_y = 440

    if (!this.best_time) {
      ctx.beginPath();
      ctx.moveTo(350, line_y);
      ctx.lineTo(450, line_y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = this.color;
      ctx.stroke();
    }

    var high_score_y = 445;
    var best_score_y = 500;
    var best_score_label_y = 470;

    if(this.best_time) {
      ctx.fillStyle = this.color
      ctx.font = '16px Open Sans'
      ctx.fillText("NEW BEST TIME!", constants.levelWidth/2, high_score_y)
    } else {
      ctx.save();
      ctx.globalAlpha *= 0.6;
      ctx.fillStyle = this.color
      ctx.font = '12px Open Sans'
      ctx.fillText("BEST TIME", constants.levelWidth/2, best_score_label_y)
      ctx.font = '28px Open Sans'
      if (saveData.hasBeatenLevel(this.level_name)) {
        ctx.font = '28px Open Sans'
        ctx.fillText(utils.convertSecondsToTimeString(saveData.getBestTimeForLevel(this.level_name)),
          constants.levelWidth/2, best_score_y)
      } else {
        ctx.font = '24px Open Sans'
        ctx.fillText("UNDEFEATED",
          constants.levelWidth/2, best_score_y)
      }
      ctx.restore();
    }
  }

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(ctx)
  }
  ctx.restore();
}

GameOverState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
}

GameOverState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

GameOverState.prototype.on_key_down = function(keyCode) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_key_down(keyCode)
  }
}

module.exports = GameOverState;

},{"../core/controls.js":2,"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/level_data.js":16,"../data/sprite_data.js":18,"../game_states/fader_util.js":47,"../game_states/game_state.js":49,"../load/hive_numbers.js":66,"../load/save_data.js":69,"../render/background.js":73,"../render/ui.js":82,"../ui/icon_button.js":87}],49:[function(require,module,exports){
var GameState = function() {
  //empty constructor since GameState should not be constructed
}

GameState.prototype.isGameState = true;

GameState.prototype.process = function(dt) {}
GameState.prototype.draw = function(ctx) {}
GameState.prototype.on_mouse_move = function(x, y) {}
GameState.prototype.on_click = function(x, y) {}
GameState.prototype.on_mouse_down = function(x, y) {}
GameState.prototype.on_mouse_up = function(x, y) {}
GameState.prototype.on_right_click = function(x, y) {}
GameState.prototype.on_right_mouse_down = function(x, y) {}
GameState.prototype.on_right_mouse_up = function(x, y) {}
GameState.prototype.on_key_down = function(keyCode) {}
GameState.prototype.on_key_up = function(keyCode) {}
GameState.prototype.dispose = function() {}
GameState.prototype.on_visibility_change = function(event_type) {
}

module.exports = GameState;

},{}],50:[function(require,module,exports){
var gsKeys = require('../data/constants.js').gsKeys;

var CreditsState = require('../game_states/credits_state.js');
var GameOverState = require('../game_states/game_over_state.js');
var ImpulseGameState = require('../game_states/impulse_game_state.js');
var IntroState = require('../game_states/intro_state.js');
var LevelEditorState = require('../game_states/level_editor_state.js');
var LevelIntroState = require('../game_states/level_intro_state.js');
var MainGameSummaryState = require('../game_states/main_game_summary_state.js');
var MainGameTransitionState = require('../game_states/main_game_transition_state.js');
var MusicPlayerState = require('../game_states/music_player_state.js');
var QuestGameState = require('../game_states/quest_game_state.js');
var RewardGameState = require('../game_states/reward_game_state.js');
var TitleState = require('../game_states/title_state.js');
var WorldMapState = require('../game_states/world_map_state.js');

var GameStateFactory = {};

var a = gsKeys.CREDITS_STATE;

var gameStateMap = {};
gameStateMap[gsKeys.CREDITS_STATE] = CreditsState;
gameStateMap[gsKeys.GAME_OVER_STATE] = GameOverState;
gameStateMap[gsKeys.IMPULSE_GAME_STATE] = ImpulseGameState;
gameStateMap[gsKeys.INTRO_STATE] = IntroState;
gameStateMap[gsKeys.LEVEL_EDITOR_STATE] = LevelEditorState;
gameStateMap[gsKeys.LEVEL_INTRO_STATE] = LevelIntroState;
gameStateMap[gsKeys.MAIN_GAME_SUMMARY_STATE] = MainGameSummaryState;
gameStateMap[gsKeys.MAIN_GAME_TRANSITION_STATE] = MainGameTransitionState;
gameStateMap[gsKeys.MUSIC_PLAYER_STATE] = MusicPlayerState;
gameStateMap[gsKeys.QUEST_GAME_STATE] = QuestGameState;
gameStateMap[gsKeys.REWARD_GAME_STATE] = RewardGameState;
gameStateMap[gsKeys.TITLE_STATE] = TitleState;
gameStateMap[gsKeys.WORLD_MAP_STATE] = WorldMapState;

GameStateFactory.createGameState = function(gameStateKey, opts) {
  return new (gameStateMap[gameStateKey])(opts);
};

module.exports = GameStateFactory;

},{"../data/constants.js":13,"../game_states/credits_state.js":46,"../game_states/game_over_state.js":48,"../game_states/impulse_game_state.js":51,"../game_states/intro_state.js":52,"../game_states/level_editor_state.js":53,"../game_states/level_intro_state.js":54,"../game_states/main_game_summary_state.js":56,"../game_states/main_game_transition_state.js":57,"../game_states/music_player_state.js":58,"../game_states/quest_game_state.js":59,"../game_states/reward_game_state.js":60,"../game_states/title_state.js":61,"../game_states/world_map_state.js":62}],51:[function(require,module,exports){
var audioData = require('../data/audio_data.js');
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var controls = require('../core/controls.js');
var debugVars = require('../data/debug.js');
var enemyData = require('../data/enemy_data.js');
var game_engine = require('../core/game_engine.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var GameState = require('../game_states/game_state.js');
var Player = require('../player/player.js');
var PauseMenu = require('../ui/dialog_boxes.js').PauseMenu;
var TutorialOverlayManager = require('../ui/tutorial_overlay.js').Manager;

ImpulseGameState.prototype = new GameState

ImpulseGameState.prototype.constructor = ImpulseGameState

ImpulseGameState.prototype.isImpulseGameState = true;

function ImpulseGameState(opts) {
  // world
  // level
  // visibility_graph
  // hive_numbers
  // main_game
  if(opts.world == null || opts.world == undefined) return

  this.init(opts.world, opts.level, opts.visibility_graph, opts.hive_numbers, opts.main_game);
}

ImpulseGameState.prototype.init = function(world, level, visibility_graph, hive_numbers, main_game) {
  this.hive_numbers = hive_numbers
  this.main_game = main_game

  this.pause = true
  this.ready = false
  this.buttons = []

  this.last_fps_time = 0
  this.fps_counter = null
  this.fps = 0
  this.score_labels = []
  this.score_label_duration = 1000
  this.score_label_rise = 30
  this.buffer_radius = 1 //primarily for starting player location
  this.bg_drawn = false
  this.boss_intro_text_activated = false
  this.boss_after_death_actions = false;

  // Is the multiplier mechanic enabled in this game?
  this.combo_enabled = saveData.difficultyMode == "normal";

  this.world_num = world

  this.progress_bar_prop = 0
  this.progress_bar_adjust = 3000
  var gravity = new box_2d.b2Vec2(000, 000);
  var doSleep = false; //objects in our world will rarely go to sleep
  this.world = new box_2d.b2World(gravity, doSleep);
  this.hive0bg_transition = false;

  if(level) {
    this.level = level
    this.level.impulse_game_state = this
    this.level.reset() //we re-use the level
    this.level_name = this.level.level_name
    this.is_level_zero = (parseInt(this.level_name.substring(7, 8)) === 0);
    this.is_boss_level = this.level_name.slice(0,4) == "BOSS"
    this.is_tutorial_level = this.world_num == 0;
    this.make_player()
    if(this.level_name == "BOSS 4") {
      music_player.play_bg(audioData.songs["Final Tessellation"])
    }
    else if(this.level_name.slice(0, 4) == "BOSS")
      music_player.play_bg(audioData.songs["Tessellation"])
    else if (!this.is_tutorial_level&& !this.is_level_zero) {
      music_player.play_bg(audioData.songs["Hive "+this.world_num])
    } else {
      music_player.play_bg(audioData.songs["Menu"]);
    }
    // Set up game numbers for level.
    if(!this.hive_numbers.game_numbers.hasOwnProperty(this.level.level_name)) {
      this.hive_numbers.game_numbers[this.level.level_name] = {}
      this.hive_numbers.game_numbers[this.level.level_name].visited = true
      this.hive_numbers.game_numbers[this.level.level_name].deaths = 0
    }
    this.game_numbers = this.hive_numbers.game_numbers[this.level.level_name];
    this.reset_game_numbers();
  }

  if (this.hive_numbers.total_time[this.level_name] === undefined) {
    this.hive_numbers.total_time[this.level_name] = 0;
  }

  this.visibility_graph = visibility_graph
  this.color = this.is_boss_level ? constants.colors["boss "+this.world_num] : constants.colors["world "+this.world_num+" lite"]
  this.dark_color = constants.colors["world "+this.world_num +" dark"];
  this.lite_color = constants.colors["world "+this.world_num +" lite"];
  this.bright_color = constants.colors["world "+this.world_num +" bright"];

  this.boss_intro_text_interval = 6000
  this.boss_intro_text_duration = 0

  this.processed_death = false
  //add walls

  this.addWalls()

  var contactListener = new box_2d.b2ContactListener;
  contactListener.BeginContact = this.handle_collisions
  contactListener.PreSolve = this.filter_collisions
  contactListener.EndContact = this.handle_collisions_on_end_contact
  this.world.SetContactListener(contactListener);
  this.pause = false
  if (this.level)
    this.ready = true

  this.bg_visible = false

  this.world_visible = true

  this.world_visibility = 1

  this.shaking = false;
  this.shaking_timer = 0;
  this.shaking_interval = 0;
  this.shaking_intensity_max = 2;

  this.camera_center = {x: constants.levelWidth/2, y: constants.levelHeight/2}
  //this.zoom = 0.1

  this.slow_zoom_transition_period = 1500;
  this.fast_zoom_transition_period = 750
  this.zoom_transition_timer = 0;
  this.zoom_state = "none";
  this.zoom_start_pt = {x:constants.levelWidth, y:constants.levelHeight}
  this.zoom_target_pt = {x:constants.levelWidth, y:constants.levelHeight}
  this.zoom_start_scale = 0.1
  this.zoom_target_scale = 1
  this.zoom = 0.1
  this.zoom_bg_switch = true;
  this.first_time = true;
  this.zoom_in({x:constants.levelWidth/2, y:constants.levelHeight/2}, 1, this.slow_zoom_transition_period)

  this.fade_state = "in"
  this.victory = false
  this.gateway_unlocked = false

  this.draw_interface_interval = 100
  this.draw_interface_timer = this.draw_interface_interval

  this.level_redraw_bg = false

  this.message_canvas = document.createElement('canvas');
  this.message_canvas.width = 120
  this.message_canvas.height = 160
  this.message_ctx = this.message_canvas.getContext('2d');

  this.hive0bg_canvas = document.createElement('canvas');

  if(level) {
    this.check_new_enemies()
  }

  // if this is world zero. show the tutorial.
  this.show_tutorial = (this.is_tutorial_level ||
    saveData.tutorialsShown.length < TutorialOverlayManager.prototype.on_demand_overlays.length)

  // if we've never beaten the first boss, show the tutorial
  if (this.is_boss_level && this.world_num == 1 && saveData.difficultyMode == "easy" &&
    !saveData.hasBeatenLevel(this.level_name)) {
    this.show_tutorial = true
  }


  if (this.show_tutorial) {
    this.tutorial_overlay_manager = new TutorialOverlayManager(this);
    this.tutorial_signals = {};
    this.tutorial_signal_timeouts = {};
    this.tutorial_signal_timeout = 500
  }

  if (!this.is_boss_level && this.level) {
    this.check_cutoffs();
  }
}

ImpulseGameState.prototype.reset = function() {
  this.reset_game_numbers();
  this.processed_death = false;
  this.first_time = false;
  var gravity = new box_2d.b2Vec2(000, 000);
  var doSleep = false; //objects in our world will rarely go to sleep
  this.world = new box_2d.b2World(gravity, doSleep);
  this.addWalls()

  var contactListener = new box_2d.b2ContactListener;
  contactListener.BeginContact = this.handle_collisions
  contactListener.PreSolve = this.filter_collisions
  this.world.SetContactListener(contactListener);

  this.gateway_unlocked = false
  this.victory = false
  this.level.reset()
  if(this.level) {
    this.check_new_enemies()
  }
  layers.bgCtx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
  this.level.draw_bg(layers.bgCtx)
  layers.bgCtx.translate(-constants.sideBarWidth, 0)
  this.progress_bar_prop = 0
  this.boss_intro_text_activated = false

  if (this.is_boss_level && this.show_tutorial) {
    this.tutorial_overlay_manager = new TutorialOverlayManager(this);
    this.tutorial_signals = {};
    this.tutorial_signal_timeouts = {};
    this.tutorial_signal_timeout = 500
  }

  if (!this.is_boss_level && this.level) {
    this.check_cutoffs();
  }

  this.boss_after_death_actions = false;
}

ImpulseGameState.prototype.reset_game_numbers = function () {
  this.game_numbers.score = 0;
  this.game_numbers.combo = 1;
  this.game_numbers.base_combo = 1;
  this.game_numbers.seconds = 0;
  this.game_numbers.kills = 0;
  this.game_numbers.game_length = 0;
  this.game_numbers.last_time = null;
  this.game_numbers.impulsed = false;
}

ImpulseGameState.prototype.check_new_enemies = function() {
  if (this.is_tutorial_level) return;
  for(var enemy in levelData.levels[this.level_name].enemies) {
    if(!enemyData[enemy].is_boss && saveData.enemiesSeen.indexOf(enemy) === -1) {
      game_engine.set_popup_message("enemy_" + enemy, 5000, this.bright_color, this.world_num)
      saveData.enemiesSeen.push(enemy);
      saveData.saveGame()
    }
  }
}

ImpulseGameState.prototype.make_player = function() {
  this.player = new Player(this.world, this.level.get_starting_loc().x/constants.drawFactor, this.level.get_starting_loc().y/constants.drawFactor, this)
}

ImpulseGameState.prototype.zoom_in = function(center, target, interval) {
  this.zoom_state = "in"
  this.zoom_transition_period = interval
  this.zoom_transition_timer = interval
  this.zoom_target_pt = center;
  this.zoom_target_scale = target;
  this.zoom_start_pt = {x:this.camera_center.x, y:this.camera_center.y};
  this.zoom_start_scale = this.zoom;
  this.zoom_bg_switch = false;
}

ImpulseGameState.prototype.zoom_out = function(center, target, interval) {
  this.zoom_state = "out"
  this.zoom_transition_period = interval
  this.zoom_transition_timer = interval;
  this.zoom_target_pt = center;
  this.zoom_target_scale = target;
  this.zoom_start_pt = {x:this.camera_center.x, y:this.camera_center.y};
  this.zoom_start_scale = this.zoom;
  this.zoom_bg_switch = false;
}

ImpulseGameState.prototype.loading_screen = function() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath()
  ctx.font = '30px Open Sans'
  ctx.fillStyle = 'black'
  ctx.textAlign = 'center'
  ctx.fillText("LOADING", constants.levelWidth/2, (constants.levelHeight)/2)
  ctx.fill()
}

ImpulseGameState.prototype.transition_to_hive0bg = function (dur) {
  this.hive0bg_transition = true;
  this.hive0bg_transition_interval = dur;
  this.hive0bg_transition_timer = dur;
  this.hive0bg_canvas.width = constants.levelWidth;
  this.hive0bg_canvas.height = constants.levelHeight;
  var hive0bg_ctx = this.hive0bg_canvas.getContext('2d');
  this.draw_hive0bg(hive0bg_ctx);
}

ImpulseGameState.prototype.draw_hive0bg = function (ctx) {
  ctx.beginPath();
  ctx.rect(0, 0, constants.levelWidth, constants.levelHeight)
  ctx.fillStyle = constants.colors['world 0 bg'];
  ctx.fill();
  ctx.save();
  ctx.globalAlpha *= uiRenderUtils.getLevelBgOpacity(0);
  uiRenderUtils.tessellateBg(ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive 0")
  ctx.restore();
}

ImpulseGameState.prototype.check_pause = function() {
  if(document.webkitHidden) {
    this.pause = true
    game_engine.set_dialog_box(new PauseMenu(this.level, this.world_num, this.game_numbers, this, this.visibility_graph))
  }
}

ImpulseGameState.prototype.process = function(dt) {
  if(!this.ready) return
  if(this.fps_counter == null)
  {
    this.last_fps_time = (new Date()).getTime()
    this.fps_counter = 0
    this.fps = "???"
  }
  else if(this.fps_counter == 100)
  {
    this.fps_counter = 0
    var a = (new Date()).getTime()
    this.fps = Math.round(100000/(a-this.last_fps_time))
    this.last_fps_time = a
  }
  this.fps_counter+=1

  // We don't want any tutorial overlay to trigger way after the event has happened. So we timeout the tutorial signals after a short period.
  for (var signal in this.tutorial_signal_timeouts) {
    this.tutorial_signal_timeouts[signal] -= dt;
    if (this.tutorial_signal_timeouts[signal] < 0) {
      this.tutorial_signals[signal] = "timeout"
    }
  }
  if(!this.pause)
  {
    if (this.shaking_timer > 0) {
      this.shaking = true;
      this.shaking_timer -= dt;
    }
    if (this.hive0bg_transition_timer > 0) {
      this.hive0bg_transition_timer -= dt;
    } else if (this.hive0bg_transition) {
      this.hive0bg_transition = false;
      layers.bgCtx.save();
      layers.bgCtx.translate(constants.sideBarWidth, 0);
      this.draw_hive0bg(layers.bgCtx);
      layers.bgCtx.restore();
    }
    if (this.show_tutorial) {
      this.tutorial_overlay_manager.process(dt);
      if(this.gateway_unlocked && utils.pDist(this.level.gateway_loc, this.player.body.GetPosition()) < this.level.gateway_size) {
        this.add_tutorial_signal("moved_to_gateway")
      }
    }
    this.check_pause()
    this.draw_interface_timer -= dt

    // ZOOM TO PLAYER, WAS USED DURING TRAILER RECORDING
    if (!this.zoom_to_player) {
      if(this.zoom_state != "none") {
        if(this.zoom_transition_timer <= 0) {
          this.zoom_state = "none"
          this.zoom = this.zoom_target_scale;
          this.camera_center = this.zoom_target_pt;
          this.zoom_bg_switch = false;
        } else {
          var prop = (this.zoom_transition_timer) / (this.zoom_transition_period)
          //utils.bezierInterpolate(0.9, 0.9, (this.zoom_transition_timer) / (this.zoom_transition_period))
          this.zoom = 1/(1/(this.zoom_start_scale) * prop + 1/(this.zoom_target_scale) * (1-prop))
          this.camera_center.x = this.zoom_start_pt.x * prop + this.zoom_target_pt.x * (1-prop)
          this.camera_center.y = this.zoom_start_pt.y * prop + this.zoom_target_pt.y * (1-prop)
          this.zoom_transition_timer -= dt;
        }
      }
    } else {
      this.camera_center = {x: this.player.body.GetPosition().x * constants.drawFactor,
                            y: this.player.body.GetPosition().y * constants.drawFactor}
    }

    if(this.zoom_state == "none" && this.zoom == 1 && this.is_boss_level && !this.boss_intro_text_activated) {
      this.boss_intro_text_duration = this.boss_intro_text_interval
      if(this.world_num == 4) {
        this.boss_intro_text_duration /= 2
        this.boss_intro_text_interval /= 2
      }
      this.boss_intro_text_activated = true
    }

    if(this.boss_intro_text_duration > 0) {
      this.boss_intro_text_duration -= dt
    }

    if (this.player.dying && this.player.dying_duration > 0 && !this.processed_death) {
      this.processed_death = true
      this.level.prepare_level_for_reset();
      this.game_numbers.score = 0;
      this.game_numbers.combo = 1;

      // Save the game when the player dies.
      if (this.main_game && this.world_num > 0) {
        this.hive_numbers.game_numbers[this.level.level_name].deaths += 1
        saveData.savePlayerGame(this.hive_numbers);
      }
    }

    if((this.player.dying && this.player.dying_duration < 0))
    {
      this.reset();
      this.make_player();
      return;
    }

    if(this.level.boss && this.level.boss.dying && this.level.boss.dying_duration < 0 &&
        this.level.boss.dying != "fade" && !this.player.dying && !this.boss_after_death_actions) {
      this.boss_after_death_actions = true;
      this.level.open_gateway()
      this.gateway_unlocked = true;
    }

    if(this.victory)
    {
      if(this.zoom_state == "none" && this.zoom == 1) {
        this.zoom_out({x: this.player.body.GetPosition().x * constants.drawFactor, y: this.player.body.GetPosition().y * constants.drawFactor}, 10, this.slow_zoom_transition_period)
        this.fade_state = "out"
      } else if(this.zoom_state == "none"){
        this.ready = false
        this.level_defeated();
      }
      return;
    }

    if(!this.is_boss_level) {

      var prop = Math.min(this.game_numbers.score/this.level.cutoff_scores[0], 1)
      var adjust_time = this.progress_bar_adjust;
      if (this.player.dying) {
        adjust_time /= 3
      }
      if(this.progress_bar_prop > prop) {
        this.progress_bar_prop  = Math.max(this.progress_bar_prop - dt/adjust_time, prop)
      }
      else if(this.progress_bar_prop < prop) {
        this.progress_bar_prop  = Math.min(this.progress_bar_prop + dt/adjust_time, prop)
      }
    }

    if(this.world_visible && this.world_visibility < 1)
    {
      this.world_visibility = Math.min(1, this.world_visibility + dt/1000)
    }
    else if(!this.world_visible && this.world_visibility > 0)
    {
      this.world_visibility = Math.max(0, this.world_visibility - dt/1000)
    }
    this.player.process(dt)
    if (this.combo_enabled) {
      this.game_numbers.combo = this.game_numbers.base_combo + Math.floor(this.game_numbers.seconds/10)
    }
    this.game_numbers.last_time = utils.convertSecondsToTimeString(this.game_numbers.seconds);

    this.game_numbers.game_length += dt;
    if (this.world_num > 0 && !this.is_level_zero)
      this.hive_numbers.speed_run_countdown -= dt
    this.hive_numbers.total_time[this.level.level_name] += dt;

    this.game_numbers.seconds = Math.floor(this.game_numbers.game_length/1000)
    this.game_numbers.total_time += dt;
    this.level.process(dt)
    for(var i = this.score_labels.length - 1; i >= 0; i--) {
      this.score_labels[i].duration -= dt
      if(this.score_labels[i].duration <= 0) {
        this.score_labels.splice(i, 1)
      }
    }

    this.world.Step(1.0/60, 1, 10);

    this.additional_processing(dt)
  } else {

  }
}

ImpulseGameState.prototype.additional_processing = function(dt) {}

ImpulseGameState.prototype.bg_transition = function() {
  if(this.zoom_bg_switch) return
  if(this.zoom == 1 && this.zoom_state == "none") {
    bg_canvas.setAttribute("style","");//make background visible*/
    this.bg_visible = true
  } else {
    bg_canvas.setAttribute("style","display: none");//make background invisible*/
    this.bg_visible = false
  }
  this.zoom_bg_switch = true
}

ImpulseGameState.prototype.set_zoom_transparency = function(ctx) {
  if(this.fade_state == "in") {
      var prop = utils.bezierInterpolate(0.1, 0.5, (this.zoom_transition_timer) / (this.zoom_transition_period))
      ctx.globalAlpha = Math.min(1-prop,1)
  } else if(this.fade_state == "out"){
    var prop = utils.bezierInterpolate(0.1, 0.5, (this.zoom_transition_timer) / (this.zoom_transition_period))
    ctx.globalAlpha = Math.max(prop,0)
  }
}

ImpulseGameState.prototype.draw = function(ctx, bg_ctx) {
  if(!this.ready) return

  this.bg_transition()
  this.additional_draw(ctx, bg_ctx)
  ctx.save();
  ctx.translate(constants.sideBarWidth, 0)//allows us to have a topbar

  if(this.zoom_state != "none" ) {
    ctx.rect(0, 0, constants.levelWidth, constants.levelHeight);
    ctx.clip()
  }

  ctx.fillStyle = this.dark_color

  ctx.scale(this.zoom, this.zoom)
  ctx.translate((constants.levelWidth/2 - this.camera_center.x*this.zoom)/this.zoom, (constants.levelHeight/2 - this.camera_center.y*this.zoom)/this.zoom);

  if (this.shaking_timer > 0) {
    var prog = Math.max(0, this.shaking_timer / this.shaking_interval);
    var s = this.shaking_intensity_max * prog;
    var x = Math.ceil(2 * s * Math.random() - s);
    var y = Math.ceil(2 * s * Math.random() - s);
    ctx.translate(x, y);
    bg_canvas.style.left = x + 'px';
    bg_canvas.style.top = y + 'px';
  } else if (this.shaking) {
    this.shaking = false;
    bg_canvas.style.left = '0px';
    bg_canvas.style.top = '0px';
  }

  ctx.beginPath();
  if(this.zoom_state != "none" ) {
    ctx.rect(2, 2, constants.levelWidth-4, constants.levelHeight-4);
    ctx.clip();
  }

  this.set_zoom_transparency(ctx);
  if(this.zoom_state != "none") {
    ctx.drawImage(bg_canvas, constants.sideBarWidth, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
  }

  if (this.hive0bg_transition) {
    ctx.save();
    ctx.globalAlpha *= 1 - this.hive0bg_transition_timer / this.hive0bg_transition_interval;
    ctx.drawImage(this.hive0bg_canvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
    ctx.restore();
  }

  this.level.pre_draw(ctx, constants.drawFactor )
  this.player.pre_draw(ctx)

  if(this.boss_intro_text_duration > 0 && this.boss_intro_text_duration < this.boss_intro_text_interval &&
      this.main_game && this.zoom == 1 && this.world_num <= 4 && this.first_time) {
    this.draw_boss_text(ctx)
  }

  this.level.draw(ctx, constants.drawFactor)

  if(this.zoom != 1 && this.victory) {
    ctx.save()

    ctx.translate(this.player.body.GetPosition().x * constants.drawFactor, this.player.body.GetPosition().y * constants.drawFactor)
    ctx.scale(1/this.zoom, 1/this.zoom)
    ctx.translate(-this.player.body.GetPosition().x * constants.drawFactor, -this.player.body.GetPosition().y * constants.drawFactor)
    this.player.draw(ctx)
    ctx.restore();
  } else {
    this.player.draw(ctx)
  }

  this.level.final_draw(ctx, constants.drawFactor)

  if(this.level_redraw_bg) {
    this.level.open_gateway()
    this.level_redraw_bg = false
  }

  ctx.beginPath()

  if(this.zoom_state == "none") {
    ctx.rect(2, 2, constants.levelWidth-4, constants.levelHeight-4);
    ctx.clip();
  }



  if(!this.is_boss_level) {
    this.draw_score_labels(ctx)
  }

  ctx.restore()


  ctx.clearRect(0, 0, constants.sideBarWidth, constants.canvasHeight);
  ctx.clearRect(constants.canvasWidth - constants.sideBarWidth, 0, constants.sideBarWidth, constants.canvasHeight);


  if(this.zoom == 1 && this.zoom_state == "none") {
    if(this.draw_interface_timer < 0) {
      this.draw_interface(bg_ctx)
      this.draw_interface_timer = this.draw_interface_interval
    }
  } else {
    this.draw_interface(ctx)
  }

  this.draw_score_bar(ctx)

  ctx.save();
  this.set_zoom_transparency(ctx);
  for(var i=0; i < this.buttons.length; i++) {
    this.buttons[i].draw(ctx)
  }
  ctx.restore();

  ctx.save();
  ctx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
  this.set_zoom_transparency(ctx);
  // Draw the tutorial if applicable.
  if (this.show_tutorial) {
    this.tutorial_overlay_manager.draw(ctx);
  }
  ctx.restore();

  /*for(var i = 0; i < this.visibility_graph.vertices.length; i++)
  {
      ctx.beginPath()
    	ctx.fillStyle = 'green';
    	ctx.arc(this.visibility_graph.vertices[i].x*constants.drawFactor, this.visibility_graph.vertices[i].y*constants.drawFactor, 2, 0, 2*Math.PI, true)
      ctx.font = 'italic 10px sans-serif'
      ctx.fillText(i, this.visibility_graph.vertices[i].x*constants.drawFactor, this.visibility_graph.vertices[i].y*constants.drawFactor)
    	ctx.fill()
  }*/

  /*for(var i = 0; i < this.visibility_graph.poly_edges.length; i++)
  {
      ctx.beginPath()
      ctx.lineWidth = 1
    	ctx.strokeStyle = '#ccc';
      ctx.moveTo(this.visibility_graph.poly_edges[i].p1.x*constants.drawFactor +constants.sideBarWidth, this.visibility_graph.poly_edges[i].p1.y*constants.drawFactor)
      ctx.lineTo(this.visibility_graph.poly_edges[i].p2.x*constants.drawFactor + constants.sideBarWidth, this.visibility_graph.poly_edges[i].p2.y*constants.drawFactor)
    	ctx.stroke()
  }

  /*for(var i = 0; i < this.level.obstacle_edges.length; i++)
  {
      ctx.beginPath()
      ctx.lineWidth = 3
    	ctx.strokeStyle = 'brown';
      ctx.moveTo(this.level.obstacle_edges[i].p1.x*constants.drawFactor + constants.sideBarWidth, this.level.obstacle_edges[i].p1.y*constants.drawFactor)
      ctx.lineTo(this.level.obstacle_edges[i].p2.x*constants.drawFactor + constants.sideBarWidth, this.level.obstacle_edges[i].p2.y*constants.drawFactor)
    	ctx.stroke()
  }

  ctx.save()
  ctx.translate(constants.sideBarWidth, 0)
  for(var i = 0; i < this.visibility_graph.edges.length; i++)
  {
      ctx.beginPath()
    	ctx.strokeStyle = 'red';
      ctx.moveTo(this.visibility_graph.edges[i].p1.x*draw_factor, this.visibility_graph.edges[i].p1.y*draw_factor)
      ctx.lineTo(this.visibility_graph.edges[i].p2.x*draw_factor, this.visibility_graph.edges[i].p2.y*draw_factor)
    	ctx.stroke()
      ctx.beginPath()
      ctx.fillStyle = 'red'
      ctx.fillText(Math.round(utils.pDist(this.visibility_graph.edges[i].p1, this.visibility_graph.edges[i].p2)), (this.visibility_graph.edges[i].p1.x*constants.drawFactor+this.visibility_graph.edges[i].p2.x*constants.drawFactor)/2, (this.visibility_graph.edges[i].p1.y*constants.drawFactor+this.visibility_graph.edges[i].p2.y*constants.drawFactor)/2)
      ctx.fill()
  }
  ctx.restore()*/
  /*ctx.globalAlpha = 0.5*/


  /*ctx.save();

  var split_size = 50
  ctx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
  ctx.beginPath()
  for(var i = 0; i < constants.levelWidth; i += split_size) {
    ctx.moveTo(i, 0)
    ctx.lineTo(i, constants.levelHeight)
  }
  for(var j = 0; j < constants.levelHeight; j += split_size) {
    ctx.moveTo(0, j)
    ctx.lineTo(constants.levelWidth, j)
  }
  ctx.lineWidth = 2
  ctx.strokeStyle = "#ccc"
  ctx.stroke()

  if(this.last_loc) {
    var visible_vertices = this.visibility_graph.visible_vertices[Math.floor(this.last_loc.x/split_size)*split_size+" "+Math.floor(this.last_loc.y/split_size)*split_size]
    ctx.beginPath()
    for(var i = 0; i < visible_vertices.length; i++) {
      ctx.moveTo(this.last_loc.x, this.last_loc.y)

      ctx.lineTo(this.visibility_graph.vertices[visible_vertices[i]].x * draw_factor, this.visibility_graph.vertices[visible_vertices[i]].y * draw_factor)
    }
    ctx.stroke()
  }

  ctx.restore()*/



  /*for(var j = 0; j < Math.min(this.level.enemies.length, 10); j++)
  {
    if(this.level.enemies[j])
    {
      var this_path = this.level.enemies[j].path
      if(this_path)
      {

        ctx.beginPath()
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 3
        ctx.moveTo(this.level.enemies[j].body.GetPosition().x*constants.drawFactor + constants.sideBarWidth, this.level.enemies[j].body.GetPosition().y*constants.drawFactor)
        for(var i = 0; i < this_path.length; i++)
        {
            ctx.lineTo(this_path[i].x*constants.drawFactor + constants.sideBarWidth, this_path[i].y*constants.drawFactor)
        }
        ctx.stroke()
        ctx.lineWidth = 1
      }
    }
  }*/


}

ImpulseGameState.prototype.additional_draw = function(ctx, bg_ctx) {

}

ImpulseGameState.prototype.draw_score_labels = function(ctx) {
  for(var i = 0; i < this.score_labels.length; i++)
    {
      ctx.save()
      ctx.beginPath()
      ctx.font = this.score_labels[i].size+'px Open Sans'
      var prog = this.score_labels[i].duration / this.score_labels[i].max_duration

      ctx.globalAlpha *= prog
      ctx.fillStyle = this.score_labels[i].color
      ctx.textAlign = 'center'
      ctx.fillText(this.score_labels[i].text, this.score_labels[i].x * constants.drawFactor, this.score_labels[i].y * constants.drawFactor - (1 - prog) * this.score_label_rise)
      ctx.restore()
    }
}

ImpulseGameState.prototype.draw_boss_text = function(ctx) {
  ctx.save();
  var prog = (this.boss_intro_text_duration)/(this.boss_intro_text_interval)

  ctx.globalAlpha = Math.min(1, (1 - 2*Math.abs(prog-0.5))/.5)

  ctx.beginPath()

  ctx.fillStyle = constants.colors["boss "+this.world_num];
  ctx.textAlign = 'right'

  ctx.font = '24px Open Sans'
  ctx.fillText(this.hive_numbers.boss_name, constants.levelWidth - 50, constants.levelHeight - 50)
  ctx.fill()
  ctx.restore();
}

ImpulseGameState.prototype.draw_interface = function(context) {
  if (this.is_level_zero) {
    return;
  }

  context.save()
  context.globalAlpha = 1;
  context.beginPath()
  context.fillStyle = "black"
  context.clearRect(0, 0, constants.sideBarWidth, constants.canvasHeight);
  context.clearRect(constants.canvasWidth - constants.sideBarWidth, 0, constants.sideBarWidth, constants.canvasHeight);

  this.set_zoom_transparency(context);
  // draw the level name

  context.fillStyle = this.color;
  context.textAlign = 'center'

  var titleTextY = 0;

  var showHardMode = this.world_num != 0 && saveData.difficultyMode == "normal" &&
    !this.is_boss_level;

  var showLevelName = !this.is_boss_level && (
    this.world_num != 0 || levelData.levels[this.level_name].show_full_interface);

  var showMenuHint = !this.is_boss_level && (
    this.world_num != 0 || levelData.levels[this.level_name].show_full_interface);

  var showGameTime = this.world_num != 0 ||
    levelData.levels[this.level_name].show_full_interface;

  var showScoreLabels = !this.is_boss_level && (!this.is_tutorial_level ||
    levelData.levels[this.level_name].show_full_interface ||
    levelData.levels[this.level_name].show_score_interface);

  if (showHardMode) {
    context.font = "20px Open Sans"
    context.save()
    context.globalAlpha *= 1
    context.fillText("HARD MODE", constants.sideBarWidth/2, titleTextY + 170)
    context.restore()
  }

  // Draw the level name.
  if (showLevelName) {
    if (this.is_tutorial_level) {
      context.font = '40px Open Sans'
      context.fillText("TUTORIAL", constants.sideBarWidth/2, titleTextY + 70)
    } else {
      context.font = '64px Open Sans'
      type = this.level_name.split(" ")[0]
      context.fillText(type, constants.sideBarWidth/2, titleTextY + 70)

      context.font = '80px Open Sans'
      if(type == "BOSS") {
        context.fillText(this.world_num, constants.sideBarWidth/2, titleTextY + 140)
      } else if(type == "HOW") {
        context.font = '60px Open Sans'
        context.fillText("PLAY", constants.sideBarWidth/2, titleTextY + 130)
      } else {
        context.fillText(this.level_name.slice(5, this.level_name.length), constants.sideBarWidth/2, titleTextY + 140)
      }
    }
  }

  var menuY = constants.canvasHeight - 15;//constants.canvasHeight / 2 - 70;

  if (showMenuHint) {
    var w = 190;
    var h = 30;
    context.fillStyle = this.bright_color;
    context.font = '18px Open Sans';
    context.save();
    context.globalAlpha *= 0.4;
    if(saveData.optionsData.control_hand == "right") {
      context.fillText("Q FOR MENU", constants.sideBarWidth/2, menuY);
    } else {
      context.fillText("ENTER FOR MENU", constants.sideBarWidth/2, menuY);
    }
    context.restore();
  }

  var timeY = constants.canvasHeight/2 - 20;
  // draw the game time
  if (showGameTime) {
    // Show speed run countdown, even if in boss.
    if (saveData.difficultyMode == "normal" && this.world_num > 0 &&
      this.main_game && saveData.optionsData.speed_run_countdown) {
      context.fillStyle = "white"
      context.font = '16px Open Sans';
      context.fillText("SPEED RUN", constants.sideBarWidth/2, timeY - 30);
      context.fillText("TIME LEFT", constants.sideBarWidth/2, timeY - 10);
      context.font = '32px Open Sans';
      var total_time = utils.convertSecondsToTimeString(Math.max(0, Math.ceil(this.hive_numbers.speed_run_countdown / 1000)));
      context.fillText(total_time, constants.sideBarWidth/2, timeY + 22);
    } else if (!this.is_boss_level) {
      context.fillStyle = this.color;
      context.font = '16px Open Sans';
      context.fillText("LEVEL TIME", constants.sideBarWidth/2, timeY - 10);
      context.font = '32px Open Sans';
      context.fillText(this.game_numbers.last_time, constants.sideBarWidth/2, timeY + 22);
    }
  }

  if(showScoreLabels) {
    // draw score
    context.font = '21px Open Sans'
    context.fillText("SCORE", constants.canvasWidth - constants.sideBarWidth/2, constants.canvasHeight - 10)
    context.font = '40px Open Sans'
    context.fillText(this.game_numbers.score, constants.canvasWidth - constants.sideBarWidth/2, constants.canvasHeight - 35)

    if (this.gateway_unlocked)  {
      context.fillStyle = this.bright_color
      context.font = '21px Open Sans'
      context.fillText("GATEWAY", constants.canvasWidth - constants.sideBarWidth/2, 45)
      context.font = '42px Open Sans'
      context.fillText("OPEN", constants.canvasWidth - constants.sideBarWidth/2, 85)
    } else {
      context.fillStyle = this.lite_color
      context.font = '21px Open Sans'
      context.fillText("GOAL", constants.canvasWidth - constants.sideBarWidth/2, 45)
      context.font = '42px Open Sans'
      context.fillText(this.level.cutoff_scores[0], constants.canvasWidth - constants.sideBarWidth/2, 85)
    }
  }
  context.restore()
}

ImpulseGameState.prototype.draw_score_bar = function(ctx) {
  if (this.is_tutorial_level && !levelData.levels[this.level_name].show_full_interface &&
    !levelData.levels[this.level_name].show_score_interface) {
    return;
  }

  if (this.is_level_zero) {
    return;
  }

  ctx.save()
  this.set_zoom_transparency(ctx)

  if(!this.is_boss_level) {
    uiRenderUtils.drawVProgressBar(ctx, constants.canvasWidth - constants.sideBarWidth/2, constants.canvasHeight/2,
      40, constants.canvasHeight * 3/4 - 50, this.progress_bar_prop, this.color, true)
    ctx.textAlign = 'center'
    ctx.font = '72px Open Sans'
    ctx.fillStyle = "white"
    if (this.combo_enabled) {
      if (this.world_num != 0 || levelData.levels[this.level_name].show_full_interface) {
        ctx.fillText("x"+this.game_numbers.combo, constants.canvasWidth - constants.sideBarWidth/2, constants.canvasHeight/2)
      }
    }
  }
  ctx.restore()
}

ImpulseGameState.prototype.transform_to_zoomed_space = function(pt) {

  var new_point = {x: (pt.x - (constants.levelWidth/2 - this.camera_center.x*this.zoom))/this.zoom,
    y: (pt.y - (constants.levelHeight/2 - this.camera_center.y*this.zoom))/this.zoom};
  return new_point
}

ImpulseGameState.prototype.on_mouse_move = function(x, y) {
  if(!this.ready) return
  for(var i = 0; i <this.buttons.length; i++) {
    this.buttons[i].on_mouse_move(x, y)
  }
  if(!this.pause) {
    this.player.mouseMove(this.transform_to_zoomed_space({x: x - constants.sideBarWidth, y: y}))
  }
}

ImpulseGameState.prototype.on_mouse_down = function(x, y) {

  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
  if(!this.pause) {
    this.player.mouse_down(this.transform_to_zoomed_space({x: x - constants.sideBarWidth, y: y}))
    //this.last_loc = {x: x - constants.sideBarWidth, y: y}
  }
}


ImpulseGameState.prototype.on_right_mouse_down = function(x, y) {

  if(!this.pause) {
    this.player.right_mouse_down(this.transform_to_zoomed_space({x: x - constants.sideBarWidth, y: y}))
    //this.last_loc = {x: x - constants.sideBarWidth, y: y}
  }
}

ImpulseGameState.prototype.reset_player_state = function() {
  this.player.keyDown(controls.keys.PAUSE)
  this.player.mouse_up(null)
}

ImpulseGameState.prototype.on_mouse_up = function(x, y) {
  if(this.pause) return

  this.player.mouse_up(this.transform_to_zoomed_space({x: x - constants.sideBarWidth, y: y}))
}

ImpulseGameState.prototype.on_right_mouse_up = function(x, y) {
  if(!this.pause) {
    this.player.right_mouse_up(this.transform_to_zoomed_space({x: x - constants.sideBarWidth, y: y}))
  }
}

ImpulseGameState.prototype.toggle_pause = function() {
  this.pause = !this.pause
  if(this.pause) {
    this.reset_player_state()
    game_engine.set_dialog_box(new PauseMenu(this.level, this.world_num, this.game_numbers, this, this.visibility_graph))
  } else {
    game_engine.clear_dialog_box()
  }
}

ImpulseGameState.prototype.on_key_down = function(keyCode) {
  if(!this.ready) return

  if(keyCode == 90 && (debugVars.dev || debugVars.instant_victory_enabled)) {//Z - insta-victory if debug is on.
    this.victory = true
    if (!this.is_boss_level) {
      this.game_numbers.score = this.level.cutoff_scores[2];
    }
    this.on_victory();
  }
  if(keyCode == controls.keys.PAUSE || keyCode == controls.keys.SECONDARY_PAUSE) {
    if ((this.is_boss_level && this.victory)) {
      // Do not allow player to pause if they've beaten the boss.
    } else {
      this.toggle_pause()
    }
  } else if(keyCode == controls.keys.GATEWAY_KEY && this.gateway_unlocked && utils.pDist(this.level.gateway_loc, this.player.body.GetPosition()) < this.level.gateway_size) {
    //if(this.game_numbers.score >= this.level.cutoff_scores[saveData.difficultyMode]["bronze"]) {
    this.on_victory();
  }
  // USED FOR TRAILER RECORDING
  else if (keyCode == 69 && debugVars.dev) { // E KEY
    this.zoom_to_player = !this.zoom_to_player
    if (this.zoom_to_player) {
      this.zoom = 1.7
      this.zoom_state = "player"
    } else {
      this.zoom = 1
      this.camera_center = {x: constants.levelWidth/2, y: constants.levelHeight/2}
      this.zoom_state = "none"
      this.fade_state = "none"
      this.zoom_bg_switch = false
    }
  } else
    this.player.keyDown(keyCode)  //even if paused, must still process
}

ImpulseGameState.prototype.on_visibility_change = function() {


}

ImpulseGameState.prototype.on_key_up = function(keyCode) {
  if(!this.ready) return
  this.player.keyUp(keyCode)
}

ImpulseGameState.prototype.addWalls = function() {
  var wall_dim, wall_pos;

    wall_dim = [{x: constants.levelWidth/constants.drawFactor/2, y: 2},
      {x: constants.levelWidth/constants.drawFactor/2, y: 2},
      {x: 2, y: (constants.levelHeight)/constants.drawFactor/2},
      {x: 2, y: (constants.levelHeight)/constants.drawFactor/2}]

    wall_pos = [{x: constants.levelWidth/constants.drawFactor/2, y: -2},
      {x: constants.levelWidth/constants.drawFactor/2, y: (constants.levelHeight)/constants.drawFactor+2},
      {x: -2, y: (constants.levelHeight)/constants.drawFactor/2},
      {x: constants.levelWidth/constants.drawFactor+2, y: (constants.levelHeight)/constants.drawFactor/2}]


  for(var i = 0; i < 4; i++) {
    var fixDef = new box_2d.b2FixtureDef;
    fixDef.filter.categoryBits = box_2d.WALL_BIT
    fixDef.filter.maskBits = box_2d.PLAYER_BIT
    var bodyDef = new box_2d.b2BodyDef;
    bodyDef.type = box_2d.b2Body.b2_staticBody;
    fixDef.shape = new box_2d.b2PolygonShape;
    fixDef.shape.SetAsBox(wall_dim[i].x, wall_dim[i].y)
  bodyDef.position.Set(wall_pos[i].x, wall_pos[i].y)
    this.world.CreateBody(bodyDef).CreateFixture(fixDef);
  }
}

ImpulseGameState.prototype.handle_collisions = function(contact) {
  var first = contact.GetFixtureA().GetUserData()
  var second = contact.GetFixtureB().GetUserData()

  if(!first || !second) return

  first["owner"].collide_with(second["owner"], first["body"], second["body"])
  second["owner"].collide_with(first["owner"], second["body"], first["body"])

  //contact.SetEnabled(false)
}

ImpulseGameState.prototype.handle_collisions_on_end_contact = function(contact) {
  // This method is a special case. Only run if both objects are tanks.
  // When tanks are already touching each other, we want them to explode if we impulse them.
  var first = contact.GetFixtureA().GetUserData()
  var second = contact.GetFixtureB().GetUserData()

  if(!first || !second) return
  if (first["owner"].type != "tank" || second["owner"].type != "tank") {
    return;
  }

  first["owner"].collide_with(second["owner"], first["body"], second["body"])
  second["owner"].collide_with(first["owner"], second["body"], first["body"])

  //contact.SetEnabled(false)
}

ImpulseGameState.prototype.filter_collisions = function(contact) {
  var first = contact.GetFixtureA().GetUserData()
  var second = contact.GetFixtureB().GetUserData()
  if(first == null || second == null) return

  var first_object = first["self"]
  var second_object = second["self"]

  if(first_object == null || second_object == null) return

  var harpoon_object = null

  var objects = [first_object, second_object]
  var other_objects =[second_object, first_object]

  for(var index in objects) {
    var first_object = objects[index]
    if(first_object.type == "harpoonhead" && first_object.harpoon.harpoon_state != "inactive") {
      var second_object = other_objects[index]

      if(second_object != first_object.harpoon && second_object.type != "harpoonhead" && !second_object.is_boss && !second["owner"].is_boss) {
        if((second_object.type == "boss_four_spawner" || second_object.type == "boss_four_attacker") && !second_object.spawned) continue
        if(utils.pDist(first_object.body.GetPosition(), second_object.body.GetPosition()) < first_object.effective_radius + second_object.effective_radius) {
          if(second_object.is_enemy)
          {
            second_object.open(3000)
          }
          first_object.harpoon.engage_harpoon(second_object)
        }
      }

      contact.SetEnabled(false)
    }
  }
}

ImpulseGameState.prototype.addScoreLabel = function(str, color, x, y, font_size, duration) {
  var this_duration = duration ? duration : this.score_label_duration
  var max_duration = duration ? duration : this.score_label_duration
  var temp_score_label = {text: str, color: color, x: x, y: y, duration: this_duration, max_duration: max_duration, size: font_size}
  this.score_labels.push(temp_score_label)
}

ImpulseGameState.prototype.check_cutoffs = function() {

  // Pulse the gateway every time an enemy is killed after reaching the score.
  if(this.game_numbers.score >= this.level.cutoff_scores[0]) {
    this.gateway_unlocked = true
    this.level_redraw_bg = true
    if (this.show_tutorial) {
      this.add_tutorial_signal("gateway_opened")
    }
  }
}

ImpulseGameState.prototype.increment_combo = function() {
  if (this.combo_enabled) {
    this.game_numbers.base_combo += 1
    this.game_numbers.combo = this.game_numbers.base_combo + Math.floor(this.game_numbers.seconds/10)
  }
}

ImpulseGameState.prototype.reset_combo = function() {
  this.hive_numbers.hit = true;
  if (!this.combo_enabled) return;
  if (this.show_tutorial && !this.level.is_boss_level) {
    this.add_tutorial_signal("multiplier_reset")
  }
  this.game_numbers.base_combo = 1
  this.game_numbers.combo = this.game_numbers.base_combo + Math.floor(this.game_numbers.seconds/10)
}

ImpulseGameState.prototype.level_defeated = function() {
  if (this.main_game) {
    game_engine.switch_game_state(gsKeys.MAIN_GAME_TRANSITION_STATE, {
      world_num: this.world_num,
      last_level: this.level,
      visibility_graph: this.visibility_graph,
      hive_numbers: this.hive_numbers,
      loading_saved_game: false
    });

  } else {
    game_engine.switch_game_state(gsKeys.REWARD_GAME_STATE, {
      hive_numbers: this.hive_numbers,
      main_game: this.main_game,
      game_args: {
        game_numbers: this.game_numbers,
        level: this.level,
        world_num: this.world_num,
        visibility_graph: this.visibility_graph,
        victory: this.victory
      }
    });
  }
}

ImpulseGameState.prototype.on_victory = function() {
  // Check if high score and best time. If so, save.
  if (!this.is_tutorial_level && !this.is_level_zero) {
    this.update_save_data_for_level();
  }
  this.victory = true
  if(this.is_boss_level) {
    this.level.boss_victory = true
  }
  if (this.main_game) {
    if (!this.is_boss_level && !(this.world_num == 0
        && this.level.level_name === levelData.lastTutorialLevel)) {
      // Advance the level to the next level.
      this.hive_numbers.current_level = utils.getNextLevelName(this.level, this.world_num);
      if (!this.is_tutorial_level) {
        saveData.savePlayerGame(this.hive_numbers);
        game_engine.set_popup_message("saved_alert", 1000, "white", this.world_num)
      }
    } else {
      // Clear the game data.
      saveData.clearSavedPlayerGame();
    }
  }
}

ImpulseGameState.prototype.update_save_data_for_level = function () {
  var new_time = this.game_numbers.seconds;

  if (!saveData.hasBeatenLevel(this.level.level_name) ||
    new_time < saveData.getBestTimeForLevel(this.level.level_name)) {
    this.game_numbers.best_time = true;
    saveData.setBestTimeForLevel(this.level.level_name, new_time);
    saveData.saveGame()
  } else {
    this.game_numbers.best_time = false;
  }
}

ImpulseGameState.prototype.shake_level = function (dur) {
  this.shaking_timer = dur;
  this.shaking_interval = dur;
}

ImpulseGameState.prototype.add_tutorial_signal = function(signal) {
  if (this.show_tutorial) {
    this.tutorial_signals[signal] = "fresh";
    this.tutorial_signal_timeouts[signal] = this.tutorial_signal_timeout
  }
}

ImpulseGameState.prototype.dispose = function() {
  this.level.dispose();
}

module.exports = ImpulseGameState;

},{"../core/controls.js":2,"../core/game_engine.js":4,"../core/layers.js":7,"../core/music_player.js":10,"../core/utils.js":11,"../data/audio_data.js":12,"../data/constants.js":13,"../data/debug.js":14,"../data/enemy_data.js":15,"../data/level_data.js":16,"../game_states/game_state.js":49,"../load/save_data.js":69,"../player/player.js":72,"../render/ui.js":82,"../ui/dialog_boxes.js":86,"../ui/tutorial_overlay.js":96,"../vendor/box2d.js":97}],52:[function(require,module,exports){
var audioData = require('../data/audio_data.js');
var constants = require('../data/constants.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var music_player = require('../core/music_player.js');
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');

var Background = require('../render/background.js');
var Fader = require('../game_states/fader_util.js');
var GameState = require('../game_states/game_state.js');

IntroState.prototype = new GameState

IntroState.prototype.constructor = IntroState

function IntroState() {
  music_player.play_bg(audioData.songs["Menu"])
  this.bg_drawn = false;
  this.fader = new Fader({
    "fade_in": 1000,
    "pause": 500,
    "fade_out": 1000
  });
  this.fade_states = ["fade_in", "pause", "fade_out"]
  this.fade_state_index = 0;
  this.fader.set_animation(this.fade_states[this.fade_state_index]);
}

IntroState.prototype.process = function(dt) {
  this.fader.process(dt);
  if(this.fader.animation === null) {
    this.fade_state_index += 1;
    if (this.fade_state_index >= this.fade_states.length) {
      game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
    }
    this.fader.set_animation(this.fade_states[this.fade_state_index]);
  }
}

IntroState.prototype.draw = function(ctx, bg_ctx) {
  if(!this.bg_drawn) {
    layers.bgCanvas.setAttribute("style", "")
    game_engine.setBg(graphics.menuBackground);
    this.bg_drawn = true
  }

  ctx.save()

  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }
  uiRenderUtils.drawPorcelainLogo(ctx, 400, 250);
  ctx.restore()
}

module.exports = IntroState;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../core/music_player.js":10,"../data/audio_data.js":12,"../data/constants.js":13,"../data/sprite_data.js":18,"../game_states/fader_util.js":47,"../game_states/game_state.js":49,"../render/background.js":73,"../render/ui.js":82}],53:[function(require,module,exports){
  //A = align
  //C = crop
  //O = turn into outline
  //Q = cancel selected
  //D = delete
  //X = reflect horizontally
  //Z = reflect vertically
  //N = add polygon
  //P = print polygons
  //arrows = move selected polygon
  //+ = zoom in
  //- = zoom out
var constants = require('../data/constants.js');
var levelData = require('../data/level_data.js');
var saveData = require('../load/save_data.js');
var utils = require('../core/utils.js');

var GameState = require('../game_states/game_state.js');

LevelEditorState.prototype = new GameState

LevelEditorState.prototype.constructor = LevelEditorState

function LevelEditorState() {
  this.polygons = []

  this.outline_polygons = []

  this.accumulated_vertices = []

  this.selected_v = null
  this.selected_p = null

  this.crop_coordinates = null


  this.drag_loc = null
  this.dragging = false
  this.levelWidth = 800
  this.levelHeight = 600
  this.bg_drawn = false

  this.zoom = 1
  this.camera_center = {x:constants.levelWidth/2, y:constants.levelHeight/2}
}

LevelEditorState.prototype.process = function(dt) {

}

LevelEditorState.prototype.draw = function(context, bg_ctx) {
  if(!this.bg_drawn) {
    bg_ctx.clearRect(0, 0, constants.canvasWidth, constants.canvasHeight);
    bg_ctx.fillStyle = "white"
    bg_ctx.fillRect(0, 0, constants.canvasWidth, constants.canvasHeight);
    this.bg_drawn = true
  }

  context.save();

  context.scale(this.zoom, this.zoom)
  context.translate((constants.levelWidth/2 - this.camera_center.x*this.zoom)/this.zoom, (constants.levelHeight/2 - this.camera_center.y*this.zoom)/this.zoom);

  context.beginPath()
  context.rect(0, 0, 800, 600)
  context.strokeStyle = "gray"
  context.stroke()

  for(var i = 0; i < this.polygons.length; i++) {
    context.beginPath()
    context.moveTo(this.polygons[i][0].x, this.polygons[i][0].y)
    for(var j = 1; j < this.polygons[i].length; j++)
    {
      context.lineTo(this.polygons[i][j].x, this.polygons[i][j].y)
    }
    context.closePath()
    context.strokeStyle = "black"
    context.stroke()
    context.fillStyle = (this.selected_p != null && this.selected_p == i) ? "red" : "black"
    context.globalAlpha = .5
    context.fill()
    context.globalAlpha = 1

    context.beginPath()
    context.arc(this.polygons[i][0].x, this.polygons[i][0].y, 5, 0, 2*Math.PI * 0.999)
    context.fillStyle = (this.selected_v && this.selected_v[0] == i && this.selected_v[1] == 0) ? "red" : "black"
    context.fill()
    for(var j = 1; j < this.polygons[i].length; j++)
    {
      context.beginPath()
      context.arc(this.polygons[i][j].x, this.polygons[i][j].y, 5, 0, 2*Math.PI * 0.999)
      context.fillStyle = (this.selected_v && this.selected_v[0] == i && this.selected_v[1] == j) ? "red" : "black"
      context.fill()
    }

    context.globalAlpha = 1
  }

  for(var i= 0; i < this.accumulated_vertices.length; i++) {
    context.beginPath()
    context.fillStyle = (this.selected_av != null && this.selected_av == i) ? "red" : "black"
    context.arc(this.accumulated_vertices[i].x, this.accumulated_vertices[i].y, 5, 0, 2*Math.PI * 0.999)
    context.fill()
  }

  for(var i = 0; i < this.outline_polygons.length; i++) {
    context.beginPath()
    context.moveTo(this.outline_polygons[i][0].x, this.outline_polygons[i][0].y)
    for(var j = 1; j < this.outline_polygons[i].length; j++)
    {
      context.lineTo(this.outline_polygons[i][j].x, this.outline_polygons[i][j].y)
    }
    context.closePath()
    context.strokeStyle = "cyan"
    context.stroke()
    context.fillStyle = "cyan"
    context.globalAlpha = .2
    context.fill()

    for(var j = 0; j < this.outline_polygons[i].length; j++)
    {
      context.beginPath()
      context.arc(this.outline_polygons[i][j].x, this.outline_polygons[i][j].y, 5, 0, 2*Math.PI * 0.999)
      context.fillStyle = "cyan"
      context.fill()
    }

    context.globalAlpha = 1
  }

  context.restore()

}

LevelEditorState.prototype.rotate_world = function(angle, center_point, duplicate) {
  var new_polygons = []
  if(center_point === undefined)
    center_point = {x: 400, y: 300}

  for(var i = 0; i < this.polygons.length; i++) {
    var new_polygon = []
    for(var j = 0; j < this.polygons[i].length; j++) {
      var pt = this.polygons[i][j]
      var r = utils.pDist(pt, center_point)
      var theta = utils.atan(center_point, pt)
      var new_pt = {x: center_point.x + r*Math.cos(angle + theta), y: center_point.y + r*Math.sin(angle + theta)}
      new_polygon.push(new_pt)
    }
    new_polygons.push(new_polygon)

  }
  if (duplicate) {
    this.polygons = this.polygons.concat(new_polygons)
  } else {
    this.polygons = new_polygons
  }
}

LevelEditorState.prototype.scale_world = function(sx, sy, center_point) {
  var new_polygons = []
  if(center_point === undefined)
    center_point = {x: 400, y: 300}

  for(var i = 0; i < this.polygons.length; i++) {
    var new_polygon = []
    for(var j = 0; j < this.polygons[i].length; j++) {
      var pt = this.polygons[i][j]
      var r = utils.pDist(pt, center_point)
      var theta = utils.atan(center_point, pt)
      var new_pt = {x: center_point.x + sx*r*Math.cos(theta), y: center_point.y + sy*r*Math.sin(theta)}
      new_polygon.push(new_pt)
    }
    new_polygons.push(new_polygon)

  }
  this.polygons = new_polygons
}

LevelEditorState.prototype.scale_polygon = function(polygon, sx, sy, center_point) {
  if(center_point === undefined)
    center_point = {x: 400, y: 300}

  var new_polygon = []
  for(var j = 0; j < this.polygons[polygon].length; j++) {
    var pt = this.polygons[polygon][j]
    var r = utils.pDist(pt, center_point)
    var theta = utils.atan(center_point, pt)
    var new_pt = {x: center_point.x + sx*r*Math.cos(theta), y: center_point.y + sy*r*Math.sin(theta)}
    new_polygon.push(new_pt)
  }
  this.polygons.push(new_polygon);
}

LevelEditorState.prototype.scale_polygon_around_centroid = function(polygon, s) {
  var centroid = {x: 0, y: 0}
  for(var j = 0; j < this.polygons[polygon].length; j++) {
    centroid.x += this.polygons[polygon][j].x
    centroid.y += this.polygons[polygon][j].y
  }
  centroid.x /= this.polygons[polygon].length
  centroid.y /= this.polygons[polygon].length

  var new_polygon = []
  for(var j = 0; j < this.polygons[polygon].length; j++) {
    var pt = this.polygons[polygon][j]
    var r = utils.pDist(pt, centroid)
    var theta = utils.atan(centroid, pt)
    var new_pt = {x: centroid.x + s*r*Math.cos(theta), y: centroid.y + s*r*Math.sin(theta)}
    new_polygon.push(new_pt)
  }
  this.polygons[polygon] = new_polygon
}

LevelEditorState.prototype.scale_all_polygons_around_centroid = function(s) {
  for(var j = 0; j < this.polygons.length; j++) {
    this.scale_polygon_around_centroid(j, s)
  }
}

LevelEditorState.prototype.scale_these_polygons_around_centroid = function(arr, s) {
  for(var j = 0; j < arr.length; j++) {
    this.scale_polygon_around_centroid(arr[j], s)
  }
}

LevelEditorState.prototype.translate_world = function(dx, dy) {
  var new_polygons = []

  for(var i = 0; i < this.polygons.length; i++) {
    var new_polygon = []
    for(var j = 0; j < this.polygons[i].length; j++) {
      var pt = this.polygons[i][j]
      var new_pt = {x: pt.x + dx, y: pt.y + dy}
      new_polygon.push(new_pt)
    }
    new_polygons.push(new_polygon)

  }
  this.polygons = new_polygons
}

LevelEditorState.prototype.duplicate_polygon = function(index, translation) {
  var new_polygon = []
    for(var j = 0; j < this.polygons[index].length; j++) {
      var pt = this.polygons[index][j]
      var new_pt = {x: pt.x + translation.x, y: pt.y + translation.y}
      new_polygon.push(new_pt)
    }
  this.polygons.push(new_polygon)

}

LevelEditorState.prototype.duplicate_translate_world = function(dx, dy) {
  var new_polygons = []

  for(var i = 0; i < this.polygons.length; i++) {
    var new_polygon = []
    for(var j = 0; j < this.polygons[i].length; j++) {
      var pt = this.polygons[i][j]
      var new_pt = {x: pt.x + dx, y: pt.y + dy}
      new_polygon.push(new_pt)
    }
    new_polygons.push(new_polygon)

  }
  this.polygons = this.polygons.concat(new_polygons)
}


LevelEditorState.prototype.rotate_polygon = function(index, angle, center_point) {
  if(center_point === undefined)
    center_point = {x: 400, y: 300}
  var new_polygon = []
  for(var j = 0; j < this.polygons[index].length; j++) {
    var pt = this.polygons[index][j]
    var r = utils.pDist(pt, center_point)
    var theta = utils.atan(center_point, pt)
    var new_pt = {x: center_point.x + r*Math.cos(angle + theta), y: center_point.y + r*Math.sin(angle + theta)}
    new_polygon.push(new_pt)
  }
  this.polygons.push(new_polygon)
}

LevelEditorState.prototype.transform_to_zoomed_space = function(pt) {

  var new_point = {x: (pt.x - (constants.levelWidth/2 - this.camera_center.x*this.zoom))/this.zoom,
    y: (pt.y - (constants.levelHeight/2 - this.camera_center.y*this.zoom))/this.zoom};
  return new_point
}

LevelEditorState.prototype.on_mouse_move = function(x, y) {
  var trans_point = this.transform_to_zoomed_space({x:x, y:y});

  if(this.dragging) {
    for(var i = 0; i < this.polygons[this.selected_p].length; i++) {
      this.polygons[this.selected_p][i].x += (trans_point.x - this.drag_loc.x)
      this.polygons[this.selected_p][i].y += (trans_point.y - this.drag_loc.y)
    }
    this.drag_loc = trans_point
  }

}

LevelEditorState.prototype.on_mouse_up = function(x, y) {
  this.dragging = false
  this.drag_loc = null
}

LevelEditorState.prototype.on_mouse_down = function(x, y) {
  var trans_point = this.transform_to_zoomed_space({x:x, y:y});
  if(this.selected_p != null && utils.pointInPolygon(this.polygons[this.selected_p], trans_point)) {
    this.drag_loc = trans_point
    this.dragging = true
  }
}


LevelEditorState.prototype.on_click = function(x, y) {
  var trans_point = this.transform_to_zoomed_space({x:x, y:y});
  console.log(trans_point.x+" "+trans_point.y)

  if(this.selected_v != null) {
    this.polygons[this.selected_v[0]][this.selected_v[1]].x = trans_point.x
    this.polygons[this.selected_v[0]][this.selected_v[1]].y = trans_point.y
    return
  }

  if(this.selected_av != null) {
    this.accumulated_vertices[this.selected_av].x = trans_point.x
    this.accumulated_vertices[this.selected_av].y = trans_point.y
    return
  }

  if(this.selected_p != null) {
    return
  }

  for(var i = 0; i < this.polygons.length; i++) {
    for(var j = 0; j < this.polygons[i].length; j++) {
      if(utils.pDist({x: this.polygons[i][j].x, y: this.polygons[i][j].y}, trans_point) < 5/this.zoom) {
        this.selected_v = [i, j]
        return
      }
    }
  }

  for(var i = 0; i < this.polygons.length; i++) {
    if(utils.pointInPolygon(this.polygons[i], trans_point)) {
      this.selected_p = i
      console.log("CLICKED ON POLYGON "+i)
      return
    }

  }

  for(var i = 0; i < this.accumulated_vertices.length; i++) {
    if(utils.pDist({x: this.accumulated_vertices[i].x, y: this.accumulated_vertices[i].y}, trans_point) < 5/this.zoom) {
        this.selected_av = i
        return
      }
  }


  this.accumulated_vertices.push(trans_point)
}

LevelEditorState.prototype.get_closest_coords = function(x, y) {
  var ans_x = 0
  var ans_y = 0
  for(var i= 0; i < this.polygons.length; i++) {
    for(var j = 0; j < this.polygons[i].length; j++) {
      if(Math.abs(this.polygons[i][j].x - x) != 0 && Math.abs(this.polygons[i][j].x - x) < Math.abs(x - ans_x)) {
        ans_x = this.polygons[i][j].x
      }
      if(Math.abs(this.polygons[i][j].y - y) != 0 && Math.abs(this.polygons[i][j].y - y) < Math.abs(y - ans_y)) {
        ans_y = this.polygons[i][j].y
      }
    }
  }
  for(var i= 0; i < this.outline_polygons.length; i++) {
    for(var j = 0; j < this.outline_polygons[i].length; j++) {
      if(Math.abs(this.outline_polygons[i][j].x - x) != 0 && Math.abs(this.outline_polygons[i][j].x - x) < Math.abs(x - ans_x)) {
        ans_x = this.outline_polygons[i][j].x
      }
      if(Math.abs(this.outline_polygons[i][j].y - y) != 0 && Math.abs(this.outline_polygons[i][j].y - y) < Math.abs(y - ans_y)) {
        ans_y = this.outline_polygons[i][j].y
      }
    }
  }

  for(var i = 0; i < this.accumulated_vertices.length; i++) {
    if(Math.abs(this.accumulated_vertices[i].x - x) != 0 && Math.abs(this.accumulated_vertices[i].x - x) < Math.abs(x - ans_x)) {
      ans_x = this.accumulated_vertices[i].x
    }
    if(Math.abs(this.accumulated_vertices[i].y - y) != 0 && Math.abs(this.accumulated_vertices[i].y - y) < Math.abs(y - ans_y)) {
      ans_y = this.accumulated_vertices[i].y
    }
  }

  return {x: ans_x, y: ans_y}

}

LevelEditorState.prototype.on_key_down = function(keyCode) {

  if(keyCode == 65) { //A = align
    if(this.selected_v != null) {
      var selected = this.polygons[this.selected_v[0]][this.selected_v[1]]
      var ans = this.get_closest_coords(selected.x, selected.y)
      selected.x = ans.x
      selected.y = ans.y

    }
    if(this.selected_av != null) {
      var selected = this.accumulated_vertices[this.selected_av]
      var ans = this.get_closest_coords(selected.x, selected.y)
      selected.x = ans.x
      selected.y = ans.y
    }

  }

  if(keyCode == 67) { //C = crop
    this.crop_coordinates = [Math.min(this.accumulated_vertices[0].x, this.accumulated_vertices[1].x), Math.min(this.accumulated_vertices[0].y, this.accumulated_vertices[1].y), Math.max(this.accumulated_vertices[0].x, this.accumulated_vertices[1].x), Math.max(this.accumulated_vertices[0].y, this.accumulated_vertices[1].y)]
    this.accumulated_vertices = []
  }

  if(keyCode == 79) {
    if(this.selected_p != null) {
      this.outline_polygons.push(this.polygons[this.selected_p])
      this.polygons.splice(this.selected_p, 1)
      this.selected_p = null
    }
  }

  if(keyCode == 81) { //Q = cancel selected
    this.selected_v = null
    this.selected_p = null
    this.selected_av = null
  }

  if(keyCode == 68) { //D = delete
    if(this.selected_p != null) {
      this.polygons.splice(this.selected_p, 1)
      this.selected_p = null
    }

    if(this.selected_v != null) {
      this.polygons[this.selected_v[0]].splice(this.selected_v[1], 1)
      this.selected_v = null
    }

    if(this.selected_av !=null) {
      this.accumulated_vertices.splice(this.selected_av, 1)
      this.selected_av = null
    }

  }

  if(keyCode == 88) { //X = reflect horizontally
    if(this.selected_av != null) {
      this.accumulated_vertices.push({x: constants.levelWidth - this.accumulated_vertices[this.selected_av].x, y: this.accumulated_vertices[this.selected_av].y})
      return
    }

    if(this.selected_p != null) {
      var poly = []
      for(var j = this.polygons[this.selected_p].length - 1; j >= 0; j--) {
        poly.push({x: constants.levelWidth - this.polygons[this.selected_p][j].x, y: this.polygons[this.selected_p][j].y})
      }
      this.polygons.push(poly)
      return
    }
  }

  if(keyCode == 90) { //Z = reflect vertically
    if(this.selected_av != null) {
      this.accumulated_vertices.push({x: this.accumulated_vertices[this.selected_av].x, y: constants.levelHeight - this.accumulated_vertices[this.selected_av].y})
      return
    }

    if(this.selected_p != null) {
      var poly = []
      for(var j = this.polygons[this.selected_p].length - 1; j >= 0; j--) {
        poly.push({x: this.polygons[this.selected_p][j].x, y: constants.levelHeight - this.polygons[this.selected_p][j].y})
      }
      this.polygons.push(poly)
      return
    }
  }
  console.log(keyCode)

  if(keyCode == 78) { //N = add polygon
    this.polygons.push(this.accumulated_vertices)
    this.accumulated_vertices = []
  }
  if(keyCode == 80) { //P = print polygons
    this.print_polygon()
  }

  if(keyCode >= 37 && keyCode <= 40) {
    var dx = 0;
    var dy = 0;
    if(keyCode == 37) dx = -1
    if(keyCode == 38) dy = -1
    if(keyCode == 39) dx = 1
    if(keyCode == 40) dy = 1

    if(this.selected_p != null) {
      for(var i = 0; i < this.polygons[this.selected_p].length; i++) {
        this.polygons[this.selected_p][i].x += dx
        this.polygons[this.selected_p][i].y += dy
      }
      return
    }


    if(this.selected_v != null) {
      this.polygons[this.selected_v[0]][this.selected_v[1]].x += dx
      this.polygons[this.selected_v[0]][this.selected_v[1]].y += dy
      return
    }

    if(this.selected_av != null) {
      this.accumulated_vertices[this.selected_av].x += dx
      this.accumulated_vertices[this.selected_av].y += dy
      return
    }
  }


  if(keyCode == 187) {
    this.zoom *=1.25
  }
  if(keyCode == 189) {
    this.zoom /=1.25
  }


}

LevelEditorState.prototype.on_key_up = function(keyCode) {
}

LevelEditorState.prototype.print_polygon = function() {
  var polygon_ans = []
  for(var i = 0; i < this.polygons.length; i++) {
    var temp_p = []
    for(var j = 0; j < this.polygons[i].length; j++) {
      temp_p.push([Math.round(this.polygons[i][j].x), Math.round(this.polygons[i][j].y)])
    }
    polygon_ans.push(temp_p)
  }
  console.log(JSON.stringify(polygon_ans))
  return JSON.stringify(polygon_ans)
}

LevelEditorState.prototype.print_accumulated_vertices = function() {
  var temp_p = []
  for(var i = 0; i < this.accumulated_vertices.length; i++) {
    temp_p.push([Math.round(this.accumulated_vertices[i].x), Math.round(this.accumulated_vertices[i].y)])
  }
  console.log(JSON.stringify(temp_p))
  return JSON.stringify(temp_p)
}

LevelEditorState.prototype.reverse_all_polygon_vertices = function() {
  for(var i = 0; i < this.polygons.length; i++) {
    this.reverse_polygon_vertice_order(i)
  }
}

LevelEditorState.prototype.reverse_polygon_vertice_order = function(index) {

  var new_polygon = []
  for(var j = this.polygons[index].length - 1; j >= 0 ; j--) {

    new_polygon.push(this.polygons[index][j])
  }
  this.polygons[index] = new_polygon
}


LevelEditorState.prototype.save = function(string) {
  localStorage[string] = this.print_polygon()
}

LevelEditorState.prototype.load = function(string) {
  var polygon_ans = JSON.parse(localStorage[string])
  this.polygons = []
  for(var i = 0; i < polygon_ans.length; i++) {
    var temp_p = []
    for(var j = 0; j < polygon_ans[i].length; j++) {

      temp_p.push({x: polygon_ans[i][j][0], y: polygon_ans[i][j][1]})
    }
    this.polygons.push(temp_p)
  }
}

LevelEditorState.prototype.load_level = function(string, mode) {
  var polygon_ans = null
  var difficulty_mode = mode ? mode : saveData.difficultyMode

  if (difficulty_mode == "easy") {
    polygon_ans = levelData.levels[string].obstacle_v_easy
  }
  if (!polygon_ans) {
    polygon_ans = levelData.levels[string].obstacle_v
  }
  this.polygons = []
  for(var i = 0; i < polygon_ans.length; i++) {
    var temp_p = []
    for(var j = 0; j < polygon_ans[i].length; j++) {

      temp_p.push({x: polygon_ans[i][j][0], y: polygon_ans[i][j][1]})
    }
    this.polygons.push(temp_p)
  }
}

LevelEditorState.prototype.add_level = function(string) {
  var polygon_ans = null
  if (saveData.difficultyMode == "easy") {
    polygon_ans = levelData.levels[string].obstacle_v_easy
  }
  if (!polygon_ans) {
    polygon_ans = levelData.levels[string].obstacle_v
  }
  for(var i = 0; i < polygon_ans.length; i++) {
    var temp_p = []
    for(var j = 0; j < polygon_ans[i].length; j++) {

      temp_p.push({x: polygon_ans[i][j][0], y: polygon_ans[i][j][1]})
    }
    this.polygons.push(temp_p)
  }
}

module.exports = LevelEditorState;

},{"../core/utils.js":11,"../data/constants.js":13,"../data/level_data.js":16,"../game_states/game_state.js":49,"../load/save_data.js":69}],54:[function(require,module,exports){
var constants = require('../data/constants.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var iconRenderUtils = require('../render/icons.js');
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var levelPreviewRenderUtils = require('../render/level_preview.js');
var saveData = require('../load/save_data.js');
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Background = require('../render/background.js');
var EnemyBox = require('../ui/dialog_boxes.js').EnemyBox;
var Fader = require('../game_states/fader_util.js');
var HiveNumbers = require('../load/hive_numbers.js');
var IconButton = require('../ui/icon_button.js');
var LoaderGameState = require('../game_states/loader_game_state.js');
var SmallEnemyButton = require('../ui/small_enemy_button.js');

LevelIntroState.prototype = new LoaderGameState

LevelIntroState.prototype.constructor = LevelIntroState

function LevelIntroState(opts) {
  // level_name
  // world
  this.level_name = opts.level_name
  this.buttons = []
  this.world_num = opts.world
  this.bg_drawn = false

  this.color = constants.colors['world '+ this.world_num + ' lite']
  this.bright_color = constants.colors['world '+ this.world_num + ' bright']

  this.is_boss_level = this.level_name.slice(0, 4) == "BOSS"

  this.buttons.push(new IconButton("BACK", 16, 70, constants.levelHeight/2+260, 60, 65, this.bright_color, "white", function(_this){return function(){

    _this.fader.set_animation("fade_out_to_main", function() {
      if(_this.world_num) {
        game_engine.switch_game_state(gsKeys.WORLD_MAP_STATE, {
          world: _this.world_num,
          is_practice_mode: true
        });
      }
      else {
        game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
      }
      game_engine.setBg(graphics.menuBackground);
    });
  }}(this), "back"))

  this.drawn_enemies = null

  if(this.is_boss_level) {
    this.drawn_enemies = {}
  }
  else {
    this.drawn_enemies = levelData.levels[this.level_name].enemies
    this.num_enemy_type = 0
    for(var j in levelData.levels[this.level_name].enemies) {
      this.num_enemy_type += 1
    }
  }
  this.enemy_image_size = 40

  this.level = this.load_level(levelData.levels[this.level_name])

  var num_row = 12

  var i = 0

  for(var j in this.drawn_enemies) {

    var k = 0
    var num_in_this_row = 0

    while(k < i+1 && k < this.num_enemy_type) {
      k+=num_row
    }

    if(k <= this.num_enemy_type) {
      num_in_this_row = num_row
    }
    else {
      num_in_this_row = this.num_enemy_type - (k - num_row)
    }
    var diff = (i - (k - num_row)) - (num_in_this_row - 1)/2

    var h_diff = Math.floor(i/num_row) - (Math.ceil(this.num_enemy_type/num_row) - 1)/2

    var cur_x =  constants.levelWidth/2 + (this.enemy_image_size+10) * diff
    var cur_y = 400 + this.enemy_image_size * h_diff
    this.buttons.push(new SmallEnemyButton(j, this.enemy_image_size, cur_x, cur_y, this.enemy_image_size, this.enemy_image_size, constants.colors["world "+this.world_num+" lite"],
      (function(enemy, _this) { return function() {
        _this.fader.set_animation("fade_out", function() {
          game_engine.set_dialog_box(new EnemyBox(enemy, _this))
        });
      }})(j, this)
      ))

    i+=1
  }

  this.fader = new Fader({
    "fade_in": 500,
    "fade_out": 250,
    "fade_out_to_main": 250
  });
  this.fader.set_animation("fade_in");
}

LevelIntroState.prototype.process = function(dt) {
  this.fader.process(dt);
  game_engine.processAndDrawBg(dt);
}


LevelIntroState.prototype.draw = function(ctx, bg_ctx) {
  if(!this.bg_drawn) {
    var world_bg_ctx = layers.worldMenuBgCanvas.getContext('2d')
    world_bg_ctx.clearRect(0, 0, constants.levelWidth, constants.levelHeight);
    uiRenderUtils.tessellateBg(world_bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+this.world_num)
    bg_ctx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
    this.level.draw_bg(bg_ctx)
    this.bg_drawn = true
    bg_ctx.translate(-constants.sideBarWidth, 0)
    bg_canvas.setAttribute("style", "display:none")
  }

  if (this.fader.get_current_animation() != "fade_out_to_main") {
    ctx.save()
    ctx.fillStyle = constants.colors["world "+this.world_num+" dark"]
    ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)
    ctx.globalAlpha *= uiRenderUtils.getBgOpacity(this.world_num);
    ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
    ctx.restore()
  } else {
    ctx.save()
    ctx.globalAlpha *= this.fader.get_animation_progress();
    ctx.fillStyle = "black"
    ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)
    ctx.globalAlpha *= uiRenderUtils.getBgOpacity(0);
    ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
    ctx.restore()
  }
  ctx.save();
  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out" || this.fader.get_current_animation() == "fade_out_to_main") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }
  if (!this.is_boss_level) {
    ctx.globalAlpha /= 3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 130, 40, true)
    ctx.globalAlpha *= 3

    ctx.fillStyle = "white"
    ctx.font = '18px Open Sans'
    if (saveData.difficultyMode == "normal") {
      ctx.fillText("HARD MODE", constants.levelWidth/2, 100)
    }

    ctx.beginPath()
    ctx.fillStyle = constants.colors['world '+ this.world_num + ' bright']
    ctx.font = '30px Open Sans'
    ctx.textAlign = 'center'

    ctx.fillText(this.level_name, constants.levelWidth/2, 140)
    ctx.fill()

    for(var i = 0; i < this.buttons.length; i++)
    {
      this.buttons[i].draw(ctx)
    }

    levelPreviewRenderUtils.drawLevelObstaclesWithinRect(ctx, this.level_name, constants.levelWidth/2, 255, 200, 150, constants.colors['world '+ this.world_num + ' lite'])
    ctx.beginPath()
    ctx.rect(constants.levelWidth/2 - 100, 100, 250, 150)

    ctx.strokeStyle = "rgba(0, 0, 0, .3)"
    ctx.stroke()

    if (this.load_percentage < 1) {

      ctx.textAlign = 'center'
      iconRenderUtils.drawLoadingIcon(ctx, constants.levelWidth - 70, constants.levelHeight - 53, 20, "gray", this.load_percentage)
      ctx.font = '16px Open Sans'
      ctx.fillStyle = "gray"
      ctx.fillText("LOADING", constants.levelWidth - 70, constants.levelHeight - 19)
    }

    ctx.fillStyle = this.bright_color
    ctx.font = '12px Open Sans'
    ctx.fillText("ENEMIES",  constants.levelWidth/2, 370)

    ctx.fillStyle = this.bright_color
    ctx.font = '12px Open Sans'
    ctx.fillText("BEST TIME", constants.levelWidth/2, 480)
    if (saveData.hasBeatenLevel(this.level_name)) {
      ctx.font = '28px Open Sans'
      ctx.fillText(utils.convertSecondsToTimeString(saveData.getBestTimeForLevel(this.level_name)),
        constants.levelWidth/2, 505)
    } else {
      ctx.font = '24px Open Sans'
      ctx.fillText("UNDEFEATED", constants.levelWidth/2, 505)
    }
  } else {

    ctx.fillStyle = constants.colors['world '+ this.world_num + ' bright']
    ctx.textAlign = 'center'

    ctx.font = '42px Open Sans'
    ctx.shadowBlur = 0;
    ctx.save();
    ctx.globalAlpha *= 0.3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, constants.levelHeight/2 - 50, 100)
    ctx.restore();
    ctx.font = '16px Open Sans'
    ctx.fillText(this.level.level_name, constants.levelWidth/2, constants.levelHeight/2 - 60)
    ctx.font = '40px Open Sans'
    ctx.fillText(levelData.bossNames[this.world_num], constants.levelWidth/2, constants.levelHeight/2 - 20)
    ctx.font = '24px Open Sans'

    if(saveData.hasBeatenLevel(this.level_name)) {
      ctx.font = '12px Open Sans'
      ctx.fillText("BEST TIME", constants.levelWidth/2, 390)
      ctx.font = '28px Open Sans'
      ctx.fillText(utils.convertSecondsToTimeString(saveData.getBestTimeForLevel(this.level_name)), constants.levelWidth/2, 415)
    } else {
      ctx.fillStyle = constants.colors['boss '+ this.world_num]
      ctx.fillText("UNDEFEATED",  constants.levelWidth/2, 400)
    }

    for(var i = 0; i < this.buttons.length; i++)
    {
      this.buttons[i].draw(ctx)
    }
  }
  ctx.restore();
}

LevelIntroState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
}

LevelIntroState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

LevelIntroState.prototype.load_complete = function() {
  var hive_numbers = new HiveNumbers(this.world_num, false)
  this.buttons.push(new IconButton("START", 16, constants.levelWidth - 70, constants.levelHeight/2 + 260, 100, 65, this.bright_color, "white", function(_this){
    return function(){
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.IMPULSE_GAME_STATE, {
          world: _this.world_num,
          level: _this.level,
          visibility_graph: _this.visibility_graph,
          hive_numbers: hive_numbers,
          main_game: false
        });
      });
    }
  }(this), "start"))
}

module.exports = LevelIntroState;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../core/utils.js":11,"../data/constants.js":13,"../data/level_data.js":16,"../data/sprite_data.js":18,"../game_states/fader_util.js":47,"../game_states/loader_game_state.js":55,"../load/hive_numbers.js":66,"../load/save_data.js":69,"../render/background.js":73,"../render/icons.js":77,"../render/level_preview.js":78,"../render/ui.js":82,"../ui/dialog_boxes.js":86,"../ui/icon_button.js":87,"../ui/small_enemy_button.js":95}],55:[function(require,module,exports){
var constants = require('../data/constants.js');
var debugVars = require('../data/debug.js');

var GameState = require('../game_states/game_state.js');
var Level = require('../level/level.js');
var VisibilityGraph = require('../lib/visibility_graph.js');

var LoaderGameState = function() {
  //empty constructor
}
LoaderGameState.prototype = new GameState()

LoaderGameState.prototype.constructor = LoaderGameState

LoaderGameState.prototype.load_level = function(level_data) {
  var level = new Level(level_data, this)

  level.generate_obstacles()

  if(debugVars.use_minified_worker)
    var visibility_graph_worker = new Worker("js/lib/worker.js")
  else
    var visibility_graph_worker = new Worker("js/lib/visibility_graph_worker_real.js")
  visibility_graph_worker.postMessage({"a": level.boundary_polygons, /*polygons*/
     "b": level.obstacle_edges, /*obstacle_edges*/
     "c": constants.drawFactor, /*draw_factor*/
     "d": constants.levelWidth, /*levelWidth*/
     "e": constants.levelHeight}) /*levelHeight*/

  this.load_percentage = 0

  visibility_graph_worker.onmessage = function(_this) {
    return function(event) {
      if (event.data["z"]) {
        _this.load_percentage = event.data["z"]
      }
      else if(event.data["a"]) {
        _this.visibility_graph = new VisibilityGraph(
          level,
          event.data["a"], /*poly_edges*/
          event.data["b"], /*vertices*/
          event.data["c"], /*edges*/
          event.data["d"], /*edge_list*/
          event.data["e"], /*shortes_paths*/
          event.data["f"]) /*visible_vertices*/
        _this.load_percentage = 1
        _this.load_complete()
      }
    }

  }(this)

  return level
}

LoaderGameState.prototype.load_complete = function() {

}

module.exports = LoaderGameState;

},{"../data/constants.js":13,"../data/debug.js":14,"../game_states/game_state.js":49,"../level/level.js":64,"../lib/visibility_graph.js":65}],56:[function(require,module,exports){
var constants = require('../data/constants.js');
var controls = require('../core/controls.js');
var game_engine = require('../core/game_engine.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var logging = require('../core/logging.js');
var music_player = require('../core/music_player.js');
var questData = require('../data/quest_data.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var GameState = require('../game_states/game_state.js');
var IconButton = require('../ui/icon_button.js');

MainGameSummaryState.prototype = new GameState

MainGameSummaryState.prototype.constructor = MainGameSummaryState

function MainGameSummaryState(opts) {
  // world_num
  // victory
  // hive_numbers
  // visibility_graph
  // save_screen
  // just_saved

  this.world_num = opts.world_num
  this.victory = opts.victory
  this.hive_numbers = opts.hive_numbers
  this.visibility_graph = opts.visibility_graph
  this.save_screen = opts.save_screen
  this.just_saved = opts.just_saved

  this.buttons = []
  this.bg_drawn = false

  if(opts.save_screen) {
    this.hive_numbers = saveData.savedGame
    saveData.saveGame()
    this.world_num = this.hive_numbers.world
    this.victory = null
  }

  this.transition_interval = 250
  this.transition_timer = this.transition_interval
  this.transition_state = "in"
  this.buttons = []

  this.shift_down_time = 0
  this.ctrl_down_time = 0

  this.color = constants.colors["world "+this.world_num]
  this.lite_color = constants.colors["world "+this.world_num+" lite"]
  this.bright_color = constants.colors["world "+this.world_num+" bright"]
  this.dark_color = constants.colors["world "+this.world_num+" dark"]

  this.is_first_victory_over_world = false;

  if (this.world_num > 0) {
    this.total_time = Math.ceil((questData["blitz_hive" + this.world_num].time_cutoff * 1000 - this.hive_numbers.speed_run_countdown) / 1000);
    this.total_deaths = 0;
  }

  for(var i = 0; i < 8; i++) {
    var title = i == 7 ? "BOSS "+(this.world_num) : "HIVE "+this.world_num+"-"+(i+1)
    if(this.hive_numbers.game_numbers[title]) {
      this.total_deaths += this.hive_numbers.game_numbers[title].deaths
    }
  }

  if(this.victory) {
    this.calculate_deaths()
    this.send_logging();
    this.victory_text = levelData.hiveNames[this.world_num]+" DEFEATED";

    if (!saveData.hasBeatenWorld(this.world_num)) {
      this.is_first_victory_over_world = true;
    }

    if (!saveData.hasBeatenWorld(this.world_num) ||
        this.total_time < saveData.getBestTimeForWorld(this.world_num)) {
      saveData.setBestTimeForWorld(this.world_num, this.total_time);
      saveData.saveGame()
    }
  }

  var _this = this;

  if(this.save_screen && !this.just_saved) {
    this.resume_button = new IconButton("RESUME", 16, 730, constants.levelHeight/2+260, 100, 65, this.bright_color, this.bright_color, function(_this){return function(){
      _this.resume_game()
    }}(this), "start")
    this.resume_button.shadow = false
    this.buttons.push(this.resume_button)

    this.delete_button = new IconButton("DELETE", 16, constants.levelWidth/2, constants.levelHeight/2+260, 100, 65, this.bright_color, this.bright_color, function(_this){return function(){
      _this.delete_game()
    }}(this), "delete_small")
    this.buttons.push(this.delete_button)
    this.delete_button.shadow = false
    this.return_to_main_button = new IconButton("EXIT", 16, 70, constants.levelHeight/2 + 260, 60, 65, this.bright_color, this.bright_color, function(_this) { return function() {
      _this.exit_game()
    }}(this), "back")

    this.buttons.push(this.return_to_main_button)
  }

  if (this.world_num != 0) {
    music_player.stop_bg()
  }


  if (!this.save_screen && this.victory)
    this.check_quests();
}

MainGameSummaryState.prototype.send_logging = function () {
  // Logging for world 0 occurs in Reward Game State, since user can quit tutorial with pause menu.
  if (this.world_num === 0) return;
  // Determine first-victory by checking world_rankings.
  var first_victory = saveData.hasBeatenWorld(this.world_num);

  logging.send_logging_to_server('BEAT WORLD ' + this.world_num, {
    first_victory: first_victory,
    difficulty_mode: saveData.difficultyMode,
    hive_numbers: this.hive_numbers
  });
};

MainGameSummaryState.prototype.calculate_deaths = function() {
  var deaths = 0;
  for(var i = 0; i < 8; i++) {
    var title = i == 7 ? "BOSS "+(this.world_num) : "HIVE "+this.world_num+"-"+(i+1)

    if(this.hive_numbers.game_numbers[title]) {
      deaths += this.hive_numbers.game_numbers[title].deaths;
    }
  }
  this.total_deaths = deaths
}

MainGameSummaryState.prototype.draw = function(ctx, bg_ctx) {
  if (this.world_num == 0 && !this.save_screen) {
    return;
  }
  if(!this.bg_drawn) {
    bg_canvas.setAttribute("style", "display:none")
    this.bg_drawn = true
    uiRenderUtils.tessellateBg(layers.worldMenuBgCanvas.getContext('2d'), 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+this.world_num)
  }

  ctx.save()
  this.transition_timer -= dt;
  if(this.transition_timer < 0) {
    if(this.transition_state == "in") {
      this.transition_state = "none"
    }
    if(this.transition_state == "out") {
      this.go_to_next_state();
    }
  }

  ctx.fillStyle = this.dark_color
  ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)

  if(this.transition_state == "in") {
    var prog = (this.transition_timer/this.transition_interval);
    ctx.globalAlpha = 1 - prog
  } else if(this.transition_state == "out") {
    var prog = (this.transition_timer/this.transition_interval);
    ctx.globalAlpha = Math.max(0, prog)
  }

  ctx.save()
  ctx.globalAlpha *= uiRenderUtils.getBgOpacity(this.world_num);

  ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)

  ctx.restore();
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(ctx)
  }

  ctx.shadowBlur = 0;

  ctx.textAlign = 'center'


  ctx.font = '20px Open Sans'
  if(this.victory) {
    ctx.globalAlpha *= 0.3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 100, 80)
    ctx.globalAlpha /= 0.3
    ctx.fillStyle = this.bright_color
    ctx.font = '40px Open Sans'
    ctx.fillText(this.victory_text, constants.levelWidth/2, 130)
  }
  else if(this.save_screen) {
    ctx.globalAlpha *= 0.3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 220, 80)
    ctx.globalAlpha /= 0.3
    ctx.fillStyle = "white"
    ctx.fillText("GAME SAVED" , constants.levelWidth/2, 210)
    ctx.fillStyle = this.bright_color;
    ctx.font = '40px Open Sans'
    ctx.fillText(this.hive_numbers.hive_name, constants.levelWidth/2, 250)
    ctx.font = '24px Open Sans'
    ctx.fillText(this.hive_numbers.current_level, constants.levelWidth/2, 280);

    ctx.textAlign = 'center'

    var score_y = 380;
    var score_label_y = 420;

    ctx.fillStyle = this.bright_color
    ctx.font = '20px Open Sans'
    ctx.fillText("TOTAL TIME ", constants.levelWidth/2 - 100, score_y)
    ctx.font = '42px Open Sans'
    ctx.fillText(utils.convertSecondsToTimeString(this.total_time), constants.levelWidth/2 - 100, score_label_y)
    ctx.fillStyle = this.bright_color
    ctx.font = '20px Open Sans'
    ctx.fillText("DEATHS", constants.levelWidth/2 + 100, score_y)
    ctx.font = '42px Open Sans'
    ctx.fillText(this.total_deaths, constants.levelWidth/2 + 100, score_label_y)

  } else {
    ctx.globalAlpha *= 0.3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 100, 80)
    ctx.globalAlpha /= 0.3
    ctx.fillStyle = 'red'
    ctx.fillText("GAME OVER", constants.levelWidth/2, 80)
    ctx.fillStyle = this.bright_color
    ctx.font = '40px Open Sans'
    ctx.fillText(this.hive_numbers.hive_name, constants.levelWidth/2, 130)
  }

  if(this.victory) {
    ctx.fillStyle = this.bright_color
    ctx.font = '14px Open Sans'
    ctx.fillText("TOTAL TIME", constants.levelWidth/2, 167)
    ctx.font = '24px Open Sans'
    ctx.fillText(utils.convertSecondsToTimeString(this.total_time), constants.levelWidth/2, 190)

  }

  if(!this.save_screen) {
    ctx.shadowBlur = 0

    ctx.font = '18px Open Sans'
    ctx.textAlign = 'center'

    var start_y = 250
    ctx.fillStyle = this.bright_color;

    ctx.fillText("LEVEL",260, start_y)
    //ctx.fillText("SCORE", 270, start_y)
    ctx.fillText("TIME", 400, start_y)
    //ctx.fillText("COMBO", 510, start_y)
    ctx.fillText("DEATHS", 540, start_y)

    for(var i = 0; i < 8; i++) {
      var title = i == 7 ? "BOSS "+(this.world_num) : "HIVE "+this.world_num+"-"+(i+1)

      var real_title = title;
      if(i==7) {
        real_title = this.hive_numbers.boss_name;
      }
      var gn;
      if(this.hive_numbers.game_numbers[title]) {
        gn = this.hive_numbers.game_numbers[title];
      } else {
        gn = {}
      }
      ctx.fillStyle = gn.visited ? this.bright_color : "#666";
      var y = start_y + 30 + 27 * i;
      ctx.fillText(real_title,260, y)

      ctx.fillStyle = gn.visited ? this.bright_color : "#666";
      if(this.hive_numbers.total_time[title] != undefined)
        ctx.fillText(utils.convertSecondsToTimeString(Math.floor(this.hive_numbers.total_time[title] / 1000)), 400, y)
      else {
        ctx.fillText('---', 400, y)
      }

      if(gn.deaths != undefined)
        ctx.fillText(gn.deaths, 540, y)
      else {
        ctx.fillText('---', 540, y)
      }
    }
  }

  ctx.font = '16px Open Sans'
  ctx.fillStyle = this.lite_color
  if(this.save_screen) {
    if(this.just_saved)
      ctx.fillText("PRESS ANY KEY FOR MAIN MENU", constants.levelWidth/2, constants.levelHeight - 30)
  } else if(this.victory) {
    ctx.fillText("PRESS ANY KEY TO CONTINUE", constants.levelWidth/2, constants.levelHeight - 30)
  } else {
    ctx.fillText("PRESS ANY KEY FOR MAIN MENU", constants.levelWidth/2, constants.levelHeight - 30)
  }

  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].draw(ctx)
  }
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].post_draw(ctx)
  }
  ctx.restore()

}

MainGameSummaryState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
}

MainGameSummaryState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

MainGameSummaryState.prototype.on_key_down = function(keyCode) {
  if(this.transition_state=="none" && (!this.save_screen || this.just_saved)) {
    this.transition_state="out";
    this.transition_timer = this.transition_interval
  }

}
MainGameSummaryState.prototype.on_key_up = function(keyCode) {
  if(keyCode == 16) {
    this.shift_held= false
  }
  if(keyCode == 17) {
    this.ctrl_held = false
  }
}

MainGameSummaryState.prototype.shift_down = function() {
  return (new Date()).getTime() - this.shift_down_time < 1000
}

MainGameSummaryState.prototype.ctrl_down = function() {
  return (new Date()).getTime() - this.ctrl_down_time < 1000
}

MainGameSummaryState.prototype.process = function(dt) {
  if (this.world_num == 0 && !this.save_screen) {
    this.go_to_next_state();
  }
}

MainGameSummaryState.prototype.resume_game = function() {
  saveData.clearSavedPlayerGame();
  game_engine.switch_game_state(gsKeys.MAIN_GAME_TRANSITION_STATE, {
    world_num: this.world_num,
    last_level: null,
    visibility_graph: null,
    hive_numbers: this.hive_numbers,
    loading_saved_game: true
  });
}

MainGameSummaryState.prototype.delete_game = function() {
  saveData.clearSavedPlayerGame();
  game_engine.switch_game_state(gsKeys.WORLD_MAP_STATE, {
    world: this.world_num,
    is_practice_mode: false
  });
}

MainGameSummaryState.prototype.check_quests = function() {
  if (this.world_num <= 0) return;

  if (saveData.difficultyMode == "normal" && this.hive_numbers.speed_run_countdown > 0) {
    saveData.setQuestCompleted("blitz_hive" + this.world_num);
  }

  if (!this.hive_numbers.hit) {
    saveData.setQuestCompleted("untouchable");
  }

  if(this.is_first_victory_over_world) {
    if (this.hive_numbers.world < 4) {
      saveData.setQuestCompleted("beat_hive")
    }

    if (this.hive_numbers.world == 4) {
      saveData.setQuestCompleted("final_boss")
    }
  }
}

MainGameSummaryState.prototype.exit_game = function() {
  game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
}

MainGameSummaryState.prototype.go_to_next_state = function() {
  if(this.victory) {
    if (this.world_num === 4 && this.is_first_victory_over_world) {
      game_engine.switch_game_state(gsKeys.CREDITS_STATE, {
        after_main_game: true,
        main_game_hive_numbers: this.hive_numbers,
        main_game_args: {
          victory: true,
          is_tutorial: this.world_num == 0,
          first_time_tutorial: saveData.firstTime,
          skipped: false,
          just_saved: this.just_saved
        }
      });
    } else {
      game_engine.switch_game_state(gsKeys.REWARD_GAME_STATE, {
        hive_numbers: this.hive_numbers,
        main_game: true,
        game_args: {
          victory: true,
          is_tutorial: this.world_num == 0,
          first_time_tutorial: saveData.firstTime,
          skipped: false,
          just_saved: this.just_saved
        }
      });
    }
  } else {
    game_engine.switch_game_state(gsKeys.REWARD_GAME_STATE, {
      hive_numbers: this.hive_numbers,
      main_game: true,
      game_args: {
        victory: false,
        is_tutorial: this.world_num == 0,
        first_time_tutorial: saveData.firstTime,
        skipped: false,
        just_saved: this.just_saved
      }
    });
  }
}

module.exports = MainGameSummaryState;

},{"../core/controls.js":2,"../core/game_engine.js":4,"../core/layers.js":7,"../core/logging.js":8,"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/level_data.js":16,"../data/quest_data.js":17,"../game_states/game_state.js":49,"../load/save_data.js":69,"../render/ui.js":82,"../ui/icon_button.js":87}],57:[function(require,module,exports){
// There are exactly four cases that bring us to this game state:
// - We win through ImpulseGameState.
// - We start a new hive through WorldMapState
// - We load an old game through MainGameSummaryState
// - We go automatically to the next hive through RewardGameState.
// Pre-condition: If we pass in a level, we are assumed to have beaten it.
var audioData = require('../data/audio_data.js');
var constants = require('../data/constants.js');
var debugVars = require('../data/debug.js');
var game_engine = require('../core/game_engine.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var HiveNumbers = require('../load/hive_numbers.js');
var LoaderGameState = require('../game_states/loader_game_state.js');

MainGameTransitionState.prototype = new LoaderGameState

MainGameTransitionState.prototype.constructor = MainGameTransitionState

function MainGameTransitionState(opts) {
  // world_num
  // last_level
  // visibility_graph
  // hive_numbers
  // loading_saved_game

  this.world_num = opts.world_num
  this.visibility_graph = opts.visibility_graph
  this.hive_numbers = opts.hive_numbers
  this.loading_saved_game = opts.loading_saved_game;
  this.last_level = opts.last_level;

  if (this.hive_numbers && this.last_level) {
    this.game_numbers = this.hive_numbers.game_numbers[this.last_level.level_name];
  }
  this.has_processed_once = false

  this.level_intro_interval = 2200
  this.last_level_summary_interval = 4000
  this.level_loaded = true
  this.color = constants.colors["world "+this.world_num]
  this.lite_color = constants.colors["world "+this.world_num+" lite"]
  this.bright_color = constants.colors["world "+this.world_num+" bright"]
  this.dark_color = constants.colors["world "+this.world_num+" dark"]
  this.buttons = []
  this.bg_drawn = false

  // Set the next game state.
  if(this.last_level && !this.is_level_zero(this.last_level.level_name)) {
    this.last_level_name = this.last_level.level_name

    this.state = "last_level_summary"
    this.transition_timer = this.last_level_summary_interval
    this.compute_last_level_stats();
  } else if (this.last_level && this.is_level_zero(this.last_level.level_name)) {
    this.state = "level_intro"
    this.transition_timer = this.level_intro_interval
  } else {
    this.state = "level_intro"
    if(!this.loading_saved_game) {
      this.hive_numbers = new HiveNumbers(this.world_num, true)
      this.hive_numbers.current_level = utils.getFirstLevelName(this.world_num);
    }
    this.transition_timer = this.level_intro_interval
  }

  if(this.last_level && this.last_level.is_boss_level) {
    // do not do the following if we have beat the last level.. will transfer to summary_state later
    return
  }
  if(this.world_num == 0 && this.last_level && this.last_level.level_name == levelData.lastTutorialLevel) {
    // do not do the following if we have beat the last tutorial level.. will transfer to summary_state later
    return
  }

  this.load_next_level(this.loading_saved_game);

  if(this.level.is_boss_level) {
    // Still give the player a moment before the BOSS, but we won't display anything in draw().
    this.level_intro_interval = 1000
  }


  if(this.world_num != 0 && (!this.last_level || !this.last_level.is_boss_level) &&
      !(this.loading_saved_game && this.hive_numbers.current_level &&
      this.hive_numbers.current_level.substring(0, 4) == "BOSS")) {
    if (this.is_level_zero(this.level.level_name)) {
      music_player.play_bg(audioData.songs["Menu"])
    } else {
      music_player.play_bg(audioData.songs["Hive "+this.world_num])
    }
  }
}


MainGameTransitionState.prototype.load_next_level = function () {
  // Set the next level to load.
  this.level_loaded = false
  this.level = this.load_level(levelData.levels[this.hive_numbers.current_level]);
  this.level_name = this.level.level_name;
}

MainGameTransitionState.prototype.compute_last_level_stats = function() {
  this.check_completed_quests(this.last_level.level_name, this.hive_numbers.game_numbers[this.last_level.level_name])
}

MainGameTransitionState.prototype.should_skip_transition_state = function () {
  // Should skip the transition state entirely as soon as the level is loaded.
  return true;
}

MainGameTransitionState.prototype.maybe_switch_states = function () {
  // if last level of tutorial, go to summary state.
  if(this.world_num == 0 && this.last_level && this.last_level.level_name == levelData.lastTutorialLevel) {
    game_engine.switch_game_state(gsKeys.MAIN_GAME_SUMMARY_STATE, {
      world_num: this.world_num,
      victory: true,
      hive_numbers: this.hive_numbers,
      visibility_graph: null,
      save_screen: false,
      just_saved: false
    });
    return true;
  }

  if(this.last_level && this.last_level.is_boss_level) {
    game_engine.switch_game_state(gsKeys.MAIN_GAME_SUMMARY_STATE, {
      world_num: this.world_num,
      victory: true,
      hive_numbers: this.hive_numbers,
      visibility_graph: null,
      save_screen: false,
      just_saved: false
    });
    return true;
  }

  // if tutorial, skip the transition state. Also, if this is the first time, go directly to impulse game state.
  if(this.should_skip_transition_state()) {
    if(this.level_loaded) {
     game_engine.switch_game_state(gsKeys.IMPULSE_GAME_STATE, {
        world: this.world_num,
        level: this.level,
        visibility_graph: this.visibility_graph,
        hive_numbers: this.hive_numbers,
        main_game: true
      });
    }
    return true;
  }

  return false;
}

MainGameTransitionState.prototype.process = function(dt) {
  if (this.maybe_switch_states()) {
    return;
  }
  this.has_processed_once = true

  // Pause in the middle of the current state until the level is loaded.
  if(this.level_loaded ||
    (this.state == "last_level_summary" && this.transition_timer >= this.last_level_summary_interval/2) ||
    (this.state == "level_intro" && this.transition_timer >= this.level_intro_interval/2)) {
    this.transition_timer -= dt;
  }

  if(this.transition_timer < 0) {
    if(this.state == "last_level_summary" && this.level_loaded) {
      if(this.level.is_boss_level) {
        music_player.stop_bg()
      }
      this.state = "level_intro"
      this.transition_timer = this.level_intro_interval
    } else if(this.state == "level_intro") {
      game_engine.switch_game_state(gsKeys.IMPULSE_GAME_STATE, {
        world: this.world_num,
        level: this.level,
        visibility_graph: this.visibility_graph,
        hive_numbers: this.hive_numbers,
        main_game: true
      });
    }
  }
}

MainGameTransitionState.prototype.draw = function(ctx, bg_ctx) {
  // When we should_skip_transition_state, we still need these lines so that the bg_canvas is set to
  // invisible. At the start of this state, the bgcanvas may still have a bg, if we don't hide this,
  // there will be a flicker while in this state.
  if(!this.bg_drawn && this.level) {
    this.bg_drawn = true

    bg_canvas.setAttribute("style", "display:none")
    uiRenderUtils.tessellateBg(layers.worldMenuBgCanvas.getContext('2d'), 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+this.world_num)
  }

  ctx.fillStyle = constants.colors["world "+this.world_num+" dark"]
  ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)

  if (this.should_skip_transition_state()) {
    return;
  }

  ctx.save()

  ctx.globalAlpha *= uiRenderUtils.getBgOpacity(this.world_num);
  if (this.state == "level_intro") {
    var prog = (this.transition_timer/this.level_intro_interval);
    if (prog < 0.5) {
      ctx.globalAlpha *= Math.min(1, (1 - 2*Math.abs(prog-0.5))/.5)
    }
  } else if (this.state == "last_level_summary") {
    var prog = (this.transition_timer/this.last_level_summary_interval);
    if (prog > 0.5) {
      ctx.globalAlpha *= Math.min(1, (1 - 2*Math.abs(prog-0.5))/.5)
    }
  }
  ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
  ctx.restore()
  if(!this.has_processed_once) return

  if(this.state == "level_intro") {

    if(!this.level.is_boss_level) {
      ctx.save()
      var prog = (this.transition_timer/this.level_intro_interval);

      ctx.globalAlpha = Math.min(1, (1 - 2*Math.abs(prog-0.5))/.5)


      ctx.fillStyle = this.bright_color;
      ctx.textAlign = 'center'


      ctx.shadowBlur = 0;
      ctx.shadowColor = "black"

      ctx.save()
      ctx.globalAlpha *= 0.3
      uiRenderUtils.drawTessellationSign(ctx,this.world_num, constants.levelWidth/2, 300, 100)
      ctx.restore()
      ctx.font = '24px Open Sans'
      ctx.save();
      ctx.globalAlpha *= 0.5;
      ctx.fillText(this.hive_numbers.hive_name, constants.levelWidth/2, 250)
      ctx.restore();
      ctx.font = '56px Open Sans'
      ctx.fillText(this.level.level_name, constants.levelWidth/2, 320)

      ctx.shadowBlur = 0
      ctx.fillStyle = this.lite_color;
      ctx.shadowColor = ctx.fillStyle
      ctx.font = '12px Open Sans'
      ctx.fillText("PRESS ANY KEY TO SKIP", constants.levelWidth/2, constants.levelHeight/2 + 270)
      ctx.restore()
    }
  }
  else if(this.state == "last_level_summary") {
    ctx.save()
    var prog = (this.transition_timer/this.last_level_summary_interval);

    ctx.globalAlpha = Math.min(1, (1 - 2*Math.abs(prog-0.5))/.5)
    ctx.globalAlpha /= 3
    uiRenderUtils.drawTessellationSign(ctx, this.world_num, constants.levelWidth/2, 230, 80, true)
    ctx.globalAlpha *= 3

    ctx.save();
    ctx.globalAlpha *= 0.5;
    ctx.fillStyle = "white"
    ctx.font = '20px Open Sans'
    if (saveData.difficultyMode == "normal") {
      ctx.fillText("HARD MODE", constants.levelWidth/2, 180)
    }
    ctx.restore();

    ctx.beginPath()
    ctx.fillStyle = this.bright_color
    ctx.font = '42px Open Sans'
    ctx.textAlign = 'center'

    ctx.fillText(this.last_level_name, constants.levelWidth/2, 240)
    ctx.fill()
    ctx.font = '36px Open Sans';
    ctx.fillStyle = "white"
    ctx.fillText("VICTORY", constants.levelWidth/2, 300)

    var score_y = 380;
    var score_label_y = 420;

    ctx.fillStyle = this.bright_color
    ctx.font = '20px Open Sans'
    ctx.fillText("GAME TIME ", constants.levelWidth/2 + 100, score_y)
    ctx.font = '42px Open Sans'
    ctx.fillText(this.game_numbers.last_time, constants.levelWidth/2 + 100, score_label_y)
    ctx.fillStyle = this.bright_color
    ctx.font = '20px Open Sans'
    ctx.fillText("SCORE", constants.levelWidth/2 - 100, score_y)

    ctx.font = '42px Open Sans'
    ctx.fillText(this.game_numbers.score, constants.levelWidth/2 - 100, score_label_y)

    var line_y = 440
    if (!this.game_numbers.high_score) {
      ctx.beginPath();
      ctx.moveTo(250, line_y);
      ctx.lineTo(350, line_y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = this.bright_color;
      ctx.stroke();
    }

    if (!this.game_numbers.best_time) {
      ctx.beginPath();
      ctx.moveTo(450, line_y);
      ctx.lineTo(550, line_y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = this.bright_color;
      ctx.stroke();
    }

    var high_score_y = 445;
    var best_score_y = 500;
    var best_score_label_y = 470;

    if(this.game_numbers.best_time) {
      ctx.fillStyle = this.bright_color
      ctx.font = '16px Open Sans'
      ctx.fillText("NEW BEST TIME!", constants.levelWidth/2 + 100, high_score_y)
    } else {
      ctx.save();
      ctx.globalAlpha *= 0.6;
      ctx.fillStyle = this.bright_color
      ctx.font = '12px Open Sans'
      ctx.fillText("BEST TIME", constants.levelWidth/2 + 100, best_score_label_y)
      ctx.font = '28px Open Sans'
      if (saveData.hasBeatenLevel(this.last_level_name)) {
        ctx.font = '28px Open Sans'
        ctx.fillText(utils.convertSecondsToTimeString(saveData.getBestTimeForLevel(this.level_name)),
          constants.levelWidth/2 + 100, best_score_y)
      } else {
        ctx.font = '24px Open Sans'
        ctx.fillText("UNDEFEATED",
          constants.levelWidth/2 + 100, best_score_y)
      }
      ctx.restore();

      ctx.shadowBlur = 0

      ctx.fillStyle = this.lite_color;
      ctx.font = '12px Open Sans'
      ctx.fillText("PRESS ANY KEY TO SKIP", constants.levelWidth/2, constants.levelHeight/2 + 270)
    }
    ctx.restore();

  }
}

MainGameTransitionState.prototype.on_key_down = function(keyCode) {
  if(this.level_loaded) {
    this.level_intro_interval /=4
    this.last_level_summary_interval /=4
    this.transition_timer /=4
    }
}

MainGameTransitionState.prototype.on_click = function(keyCode) {
  if(this.level_loaded) {
    this.level_intro_interval /= 4
    this.last_level_summary_interval /= 4
    this.transition_timer /= 4
  }
}

MainGameTransitionState.prototype.load_complete = function() {
  this.level_loaded = true
  // Hide the bg_canvas and draw the level on it.
  bg_canvas.setAttribute("style", "display:none")
  layers.bgCtx.translate(constants.sideBarWidth, 0)
  this.level.draw_bg(layers.bgCtx)
  layers.bgCtx.translate(-constants.sideBarWidth, 0)
}

MainGameTransitionState.prototype.is_level_zero = function(level_name) {
  return (parseInt(level_name.substring(7, 8)) === 0);
}

MainGameTransitionState.prototype.check_completed_quests = function(level_name, game_numbers) {
  var world = parseInt(level_name.substring(5, 6))

  if (world != 0 && !this.is_level_zero(level_name) && game_numbers.impulsed == false) {
    saveData.setQuestCompleted("pacifist")
  }
}

module.exports = MainGameTransitionState;

},{"../core/game_engine.js":4,"../core/layers.js":7,"../core/music_player.js":10,"../core/utils.js":11,"../data/audio_data.js":12,"../data/constants.js":13,"../data/debug.js":14,"../data/level_data.js":16,"../game_states/loader_game_state.js":55,"../load/hive_numbers.js":66,"../load/save_data.js":69,"../render/ui.js":82}],58:[function(require,module,exports){
var audioData = require('../data/audio_data.js');
var constants = require('../data/constants.js');
var game_engine = require('../core/game_engine.js');
var gsKeys = constants.gsKeys;
var music_player = require('../core/music_player.js');

var GameState = require('../game_states/game_state.js');
var Slider = require('../ui/slider.js');
var SmallButton = require('../ui/small_button.js');

MusicPlayerState.prototype = new GameState

MusicPlayerState.prototype.constructor = MusicPlayerState

function MusicPlayerState() {
  this.buttons = []

  this.first_column = constants.levelWidth*3/8;
  this.second_column = constants.levelWidth*5/8;
  this.column_top = 300;
  this.column_space = 50;
  this.button_color = constants.colors["impulse_blue"]
  this.setup_ui()

  this.cur_song = null
  music_player.stop_bg()
}

MusicPlayerState.prototype.draw = function(context, bg_ctx) {
  if(!this.bg_drawn) {
    bg_canvas.setAttribute("style", "")
    bg_ctx.clearRect(0, 0, canvas.width, canvas.height);
    bg_ctx.fillStyle = "black"
    bg_ctx.fillRect(0, 0, canvas.width, canvas.height);
    this.bg_drawn = true
  }

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(context)
  }
  this.slider.draw(context)

  if(this.cur_song != null) {
    context.beginPath()
    context.textAlign = "center"
    context.font = "12px Open Sans"
    context.fillStyle = constants.colors["impulse_blue"]
    context.fillText("Currently Playing: " + this.cur_song, constants.levelWidth/2, 175)
    var duration = Math.round(music_player.getCurrentSong().sound.getDuration())
    var curTime = Math.round(music_player.getCurrentSong().sound.getTime())
    var durSecondsString = Math.floor(duration%60)
    if(durSecondsString < 10) durSecondsString = "0"+durSecondsString
    var curSecondsString = Math.floor(curTime%60)
    if(curSecondsString < 10) curSecondsString = "0"+curSecondsString

    context.fillText(Math.floor(curTime/60)+":"+curSecondsString, constants.levelWidth*1/4, 220)
    context.fillText(Math.floor(duration/60)+":"+durSecondsString, constants.levelWidth*3/4, 220)

  }
}

MusicPlayerState.prototype.setup_ui = function() {

  this.slider = new Slider(constants.levelWidth/2, 200, constants.levelWidth/2, 5, this.button_color)
  this.slider.value = 0
  this.slider.active = false


  this.buttons.push(new SmallButton("PLAY", 20, constants.levelWidth/2 - 50, 250, 100, 50, this.button_color, "blue",

        function() {
          music_player.resume_bg();
        }))

  this.buttons.push(new SmallButton("PAUSE", 20, constants.levelWidth/2 + 50, 250, 100, 50, this.button_color, "blue",

        function() {
          music_player.pause_bg();
        }))
  this.setup_music_buttons()

    this.buttons.push(new SmallButton("MAIN MENU", 20, constants.levelWidth/2, constants.levelHeight/2+270, 200, 50, this.button_color, "blue",
      function (){
        setTimeout(function (){
          game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
        }, 20)
      }));
}

MusicPlayerState.prototype.setup_music_buttons = function() {

  var index = 0;
  for(song in audioData.songs) {
    var x = (index%2 == 0) ? this.first_column : this.second_column;
    var _this = this;
    this.buttons.push(new SmallButton(song, 20, x, this.column_top + Math.floor(index/2) * this.column_space, 200, 50, this.button_color, "blue",
          (function(this_song) {
          return function() {
            _this.cur_song = this_song;
            music_player.play_bg(audioData.songs[_this.cur_song])
          }})(song)

          ))

    index++

  }
}

MusicPlayerState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
  this.slider.on_mouse_move(x,y)
}

MusicPlayerState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

MusicPlayerState.prototype.on_mouse_down = function(x,y) {
  this.slider.on_mouse_down(x,y)
}


MusicPlayerState.prototype.on_mouse_up = function(x,y) {
  if(music_player.getCurrentSong().sound != null && this.slider.drag) {
    music_player.skip(music_player.getCurrentSong().sound.getDuration() * this.slider.value)
  }
  this.slider.on_mouse_up(x,y)
}

MusicPlayerState.prototype.process = function(dt) {
  if(this.cur_song != null && !this.slider.drag) {
    var value = music_player.getCurrentPercent()
    this.slider.value = value
  }
}

module.exports = MusicPlayerState;

},{"../core/game_engine.js":4,"../core/music_player.js":10,"../data/audio_data.js":12,"../data/constants.js":13,"../game_states/game_state.js":49,"../ui/slider.js":92,"../ui/small_button.js":94}],59:[function(require,module,exports){
var constants = require('../data/constants.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var spriteData = require('../data/sprite_data.js');

var Background = require('../render/background.js');
var Fader = require('../game_states/fader_util.js');
var GameState = require('../game_states/game_state.js');
var IconButton = require('../ui/icon_button.js');
var QuestButton = require('../ui/quest_button.js');

QuestGameState.prototype = new GameState

QuestGameState.prototype.constructor = QuestGameState

function QuestGameState() {
  this.fader = new Fader({
    "fade_in": 500,
    "fade_out": 250
  });
  this.fader.set_animation("fade_in");
  this.buttons = [];
  this.buttons.push(new IconButton("BACK", 16, constants.levelWidth/2, constants.levelHeight/2+260, 60, 65, "white", constants.colors["impulse_blue"], function(_this){return function(){
    _this.fader.set_animation("fade_out", function() {
      game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
    });
  }}(this), "back"));
  this.set_up_quests();
}


QuestGameState.prototype.process = function(dt) {
  this.fader.process(dt);
  this.trailer_fade_in += dt
}

QuestGameState.prototype.set_up_quests = function() {
  var quest_size = 50;

  var first_row_x = 200;
  var first_row_gap = 150;
  this.buttons.push(new QuestButton("beat_hive", constants.levelWidth/2 - 2 * first_row_gap, first_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("final_boss", constants.levelWidth/2 - 1 * first_row_gap, first_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("high_roller", constants.levelWidth/2 + 0 * first_row_gap, first_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("pacifist", constants.levelWidth/2 + 1 * first_row_gap, first_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("untouchable", constants.levelWidth/2 + 2 * first_row_gap, first_row_x, quest_size, quest_size));

  var second_row_x = 350;
  var second_row_gap = 150;
  this.buttons.push(new QuestButton("beat_hard", constants.levelWidth/2 - 2 * second_row_gap, second_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("blitz_hive1", constants.levelWidth/2 - 1 * second_row_gap, second_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("blitz_hive2", constants.levelWidth/2 - 0 * second_row_gap, second_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("blitz_hive3", constants.levelWidth/2 + 1 * second_row_gap, second_row_x, quest_size, quest_size));
  this.buttons.push(new QuestButton("blitz_hive4", constants.levelWidth/2 + 2 * second_row_gap, second_row_x, quest_size, quest_size));
}


QuestGameState.prototype.draw = function(ctx, bg_ctx) {
  if(!this.bg_drawn) {
    layers.bgCanvas.setAttribute("style", "")
    game_engine.setBg(graphics.menuBackground);
    this.bg_drawn = true
  }

  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }

  ctx.textAlign = "center"
  ctx.font = '24px Open Sans'
  ctx.fillStyle = "white"

  ctx.fillText("ACHIEVEMENTS", constants.levelWidth/2, 50)
  ctx.font = '12px Open Sans'
  ctx.fillText("MOUSE OVER TO VIEW", constants.levelWidth/2, 75)

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(ctx)
  }
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].post_draw(ctx)
  }
}

QuestGameState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
}

QuestGameState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

module.exports = QuestGameState;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../data/constants.js":13,"../data/sprite_data.js":18,"../game_states/fader_util.js":47,"../game_states/game_state.js":49,"../render/background.js":73,"../ui/icon_button.js":87,"../ui/quest_button.js":90}],60:[function(require,module,exports){
// Currently responsible only for first time tutorial and final victory scores after hive 4. Also
// Also might stil take user to ult tutorial, but that will soon be deprecated.
var constants = require('../data/constants.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var logging = require('../core/logging.js');
var music_player = require('../core/music_player.js');
var questData = require('../data/quest_data.js');
var questRenderUtils = require('../render/quest.js');
var saveData = require('../load/save_data.js');
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');

var Background = require('../render/background.js');
var GameState = require('../game_states/game_state.js');
var IconButton = require('../ui/icon_button.js');

RewardGameState.prototype = new GameState

RewardGameState.prototype.constructor = RewardGameState

function RewardGameState(opts) {
  // hive_numbers
  // main_game
  // game_args
  this.hive_numbers = opts.hive_numbers
  this.main_game = opts.main_game
  this.game_args = opts.game_args
  this.rewards = []
  this.cur_reward_index = -1
  this.transition_interval = 250
  this.transition_timer = this.transition_interval
  this.transition_state = "in"
  this.first_time = saveData.firstTime // cache the first time variable, since it might change during this game state
  this.victory = this.game_args.victory
  this.bg_drawn = false
  this.ult_num_pages = 7
  this.ult_cur_page = 0
  this.hard_mode_just_unlocked = false;
  var _this = this;
  this.initial_difficulty_mode = saveData.difficultyMode;

  this.normal_mode_button = new IconButton("NORMAL MODE", 20, constants.levelWidth/2-150, 300, 250, 125, "white", constants.colors["impulse_blue"], function(){_this.change_mode("easy")}, "easy_mode")
  this.challenge_mode_button = new IconButton("CHALLENGE MODE", 20, constants.levelWidth/2+150, 300, 250, 125, "white", constants.colors["impulse_blue"], function(){_this.change_mode("normal")}, "normal_mode")

  this.debug()

  this.determine_rewards()
  this.next_reward()
  if(this.rewards.length > 0) {
    music_player.stop_bg()
  }

  this.auto_advance_duration = 3000;
  this.auto_advance_timer = 0;
}

RewardGameState.prototype.change_mode = function(type) {
  if (this.transition_state == "none") {
    saveData.difficultyMode = type;
    saveData.saveGame();
    this.adjust_difficulty_button_border()
    this.transition_state="out";
    this.transition_timer = this.transition_interval * 4
  }
}

RewardGameState.prototype.draw = function(ctx, bg_ctx) {
  if(this.rewards.length == 0) {
    return
  }

  // draw the background
  var cur_reward = this.rewards[this.cur_reward_index]
  if(!this.bg_drawn) {
    bg_canvas.setAttribute("style", "display:none")
    var world_bg_ctx = layers.worldMenuBgCanvas.getContext('2d')
    if (cur_reward.type == "world_victory") {
      uiRenderUtils.tessellateBg(world_bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+(cur_reward.data+1))
    } else if (cur_reward.type == "final_victory") {
      uiRenderUtils.tessellateBg(world_bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Title Alt4")
    } else {
      uiRenderUtils.tessellateBg(world_bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive 0")
    }
    this.bg_drawn = true
  }
  ctx.save()
  if (cur_reward.type == "world_victory") {
    ctx.globalAlpha *= uiRenderUtils.getBgOpacity(cur_reward.data + 1);
  } else if (cur_reward.type == "final_victory") {
    ctx.globalAlpha *= uiRenderUtils.getBgOpacity(0) / 2;
  } else {
    ctx.globalAlpha *= uiRenderUtils.getBgOpacity(0);
  }
  ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
  ctx.restore()
  ctx.save();
  // change transparency for transition
  if(this.transition_state == "in") {
    var prog = (this.transition_timer/this.transition_interval);
    ctx.globalAlpha = 1 - prog
  } else if(this.transition_state == "out") {
    var prog = (this.transition_timer/this.transition_interval);
    ctx.globalAlpha = Math.max(0, prog)
  }
  // draw tessellation if applicable
  if (cur_reward.type != "quest" && cur_reward.type != "ult_tutorial" && cur_reward.type != "select_difficulty" &&
       cur_reward.type != "share") {
    var tessellation_num = cur_reward.type == "world_victory" ? cur_reward.data + 1 : 0
    ctx.save()
    ctx.globalAlpha *= 0.2
    uiRenderUtils.drawTessellationSign(ctx, tessellation_num, constants.levelWidth/2, 250, 100)
    ctx.restore()
  }
  var main_message = ""
    var main_message_teaser = ""
    var main_reward_text_y = 250
    var new_values_text_y = 430
    var message_size = 32

    if(cur_reward.type == "world_victory") {
      ctx.fillStyle = constants.colors["world "+(cur_reward.data+1)+ " bright"]
      message_size = 24
      main_message = "NEW HIVE UNLOCKED"
      main_message_teaser = this.initial_difficulty_mode == "easy" ? "STANDARD MODE" : "CHALLENGE MODE"
      ctx.textAlign = "center"
      ctx.font = "48px Open Sans"
      ctx.fillText(levelData.hiveNames[cur_reward.data+1], constants.levelWidth/2, 270)
    }

    if(cur_reward.type == "final_victory") {

      final_message = this.initial_difficulty_mode == "easy" ? "HARD MODE UNLOCKED FOR ALL HIVES" : "HARD MODE COMPLETED"
      final_message_teaser = this.initial_difficulty_mode == "easy" ? "THE REAL GAME BEGINS" : ""

      ctx.textAlign = "center"
      ctx.fillStyle = "white"
      ctx.font = "24px Open Sans"
      ctx.fillText(final_message, constants.levelWidth/2, 240)
      ctx.font = "20px Open Sans"
      ctx.fillStyle = "red"
      ctx.fillText(final_message_teaser, constants.levelWidth/2, 280)

      ctx.font = "16px Open Sans"
      ctx.fillStyle = "white"
      if (this.initial_difficulty_mode == "easy") {
      } else {
        ctx.fillText("THANKS FOR PLAYING IMPULSE", constants.levelWidth/2, 320)
        // TODO: add sharing
      }
    }

    if(cur_reward.type == "rating") {

      main_message = "YOUR SKILL RATING WENT UP"
      main_message_teaser = "CONGRATULATIONS!"
      message_size = 32
      ctx.textAlign = "center"
      ctx.fillStyle = "white"
      ctx.font = "60px Open Sans"
      ctx.fillText("+"+cur_reward.data.diff, constants.levelWidth/2, main_reward_text_y + 20)

      ctx.textAlign = 'center'
      ctx.font = '12px Open Sans'
      ctx.fillStyle = 'white'
      ctx.fillText("NEW SKILL RATING", constants.levelWidth/2, new_values_text_y - 25)
      ctx.font = '48px Open Sans'
      ctx.fillText(cur_reward.data.new_rating, constants.levelWidth/2, new_values_text_y + 25)
    }

    if(cur_reward.type == "quest") {
      var tessellation_num = 0
      ctx.save()
      uiRenderUtils.drawTessellationSign(ctx, tessellation_num, constants.levelWidth/2, 250, 150)
      ctx.restore()
      ctx.textAlign = "center"
      ctx.fillStyle = constants.colors["impulse_blue"]

      ctx.font = '32px Open Sans'
      ctx.fillText("CHALLENGE COMPLETE!", constants.levelWidth/2, 120)


      questRenderUtils.draw_quest_button(ctx, constants.levelWidth/2, main_reward_text_y, 60, cur_reward.data.type);

      ctx.font = '24px Open Sans'
      ctx.fillStyle = "white"
      for (var i = 0; i < questData[cur_reward.data.type].text.length; i++) {
        var text = questData[cur_reward.data.type].text[i];
        ctx.fillText(text, constants.levelWidth / 2, main_reward_text_y + 150 + i * 36);
      }

    }

    if(cur_reward.type == "first_time_tutorial") {
      ctx.font = "30px Open Sans"
      ctx.textAlign = "center"
      ctx.fillStyle = "white"
      ctx.fillText("INTRO TUTORIAL COMPLETE", constants.levelWidth/2, 250)
      ctx.fillStyle = "white"
      ctx.font = "16px Open Sans"
      ctx.fillText("INITIALIZING MAIN GAME...", constants.levelWidth/2, 550)
    }

    if(cur_reward.type == "select_difficulty") {
      main_message_teaser = "LET'S DO THIS"
      message_size = 36
      main_message = "SELECT DIFFICULTY"

      this.normal_mode_button.draw(ctx)
      this.challenge_mode_button.draw(ctx)
    }

    // write a main message if it applies
    if (main_message) {
      ctx.fillStyle = "white"
      ctx.textAlign = "center"
      ctx.font = "16px Open Sans"
      ctx.fillText(main_message_teaser, constants.levelWidth/2, 70)
      ctx.font = message_size + "px Open Sans"
      if (cur_reward.type == "world_victory") {
        ctx.fillStyle = constants.colors["world "+(cur_reward.data+1)+ " bright"]
      } else {
        ctx.fillStyle = constants.colors["impulse_blue"]
      }
      ctx.fillText(main_message, constants.levelWidth/2, 120)
    }

    if (cur_reward.type != "select_difficulty") {
      ctx.textAlign = "center"
      ctx.fillStyle = cur_reward.type == "world_victory" ? constants.colors["world "+(cur_reward.data+1)+ " bright"] : "white"
      ctx.font = "16px Open Sans"
      if (cur_reward.type != "first_time_tutorial") {
        if (cur_reward.type != "ult")
          ctx.fillText("PRESS ANY KEY TO CONTINUE", constants.levelWidth/2, constants.levelHeight - 30)
        else
          ctx.fillText("PRESS ANY KEY FOR ULT TUTORIAL", constants.levelWidth/2, constants.levelHeight - 30)
      }
    } else {
      ctx.font = "16px Open Sans"
      ctx.textAlign = "center"
      ctx.fillStyle = constants.colors["impulse_blue"]
      ctx.fillText("YOU CAN SWITCH DIFFICULTY ON THE TITLE SCREEN OPTIONS MENU", constants.levelWidth/2, constants.levelHeight - 75)
    }
    ctx.restore();
}

RewardGameState.prototype.debug = function() {
  if (false) {
  }
}

RewardGameState.prototype.process = function(dt) {

  if(this.rewards.length == 0) {
    this.advance_game_state()
  }
  if (this.cur_reward_index < this.rewards.length && this.cur_reward_index >= 0) {
    var cur_reward = this.rewards[this.cur_reward_index]
    if (cur_reward.type == "first_time_tutorial") {
      this.auto_advance_timer -= dt;
      if (this.auto_advance_timer <= 0 && this.transition_state == "none") {
        this.transition_state = "out"
        this.transition_timer = this.transition_interval
      }
    }
  }

  this.transition_timer -= dt;
  if(this.transition_timer < 0) {
    if(this.transition_state == "in") {
      this.transition_state = "none"
      this.auto_advance_timer = this.auto_advance_duration;
    }
    if(this.transition_state == "out") {
      this.next_reward()

      if(this.cur_reward_index >= this.rewards.length) {
        this.advance_game_state()
      } else {
        this.transition_state="in";
        this.transition_timer = this.transition_interval
        this.bg_drawn = false
      }
    }
  }
}

RewardGameState.prototype.next_reward = function() {
  this.cur_reward_index += 1

  if (this.cur_reward_index < this.rewards.length) {
    var cur_reward = this.rewards[this.cur_reward_index]
  }
}

RewardGameState.prototype.switch_to_world_map = function(is_practice_mode) {
  // If we just unlocked hard mode, go to 1.
  var go_to_world_num = this.hard_mode_just_unlocked ? 1 : this.hive_numbers.world;
  game_engine.setBg(graphics.menuBackground);
  game_engine.switch_game_state(gsKeys.WORLD_MAP_STATE, {
    world: go_to_world_num,
    is_practice_mode: is_practice_mode
  });
}

RewardGameState.prototype.advance_game_state = function() {
  if (this.main_game) {
    if (this.victory && this.hive_numbers.world >= 1 && this.hive_numbers.world <= 3) {
      // Immediately move to the next world.
      game_engine.switch_game_state(gsKeys.MAIN_GAME_TRANSITION_STATE, {
        world_num: this.hive_numbers.world + 1,
        last_level: null,
        visibility_graph: null,
        hive_numbers: null,
        loading_saved_game: false
      });
    } else if (this.victory && this.hive_numbers.world == 0 && this.first_time) {
      game_engine.switch_game_state(gsKeys.MAIN_GAME_TRANSITION_STATE, {
        world_num: this.hive_numbers.world + 1,
        last_level: null,
        visibility_graph: null,
        hive_numbers: null,
        loading_saved_game: false
      });
    } else if (this.victory && this.hive_numbers.world == 4) {
      this.switch_to_world_map(false);
    } else if (this.game_args.just_saved) {
      game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
    } else {
      this.switch_to_world_map(false);
    }
  } else {
    if (this.victory) {
      game_engine.switch_game_state(gsKeys.GAME_OVER_STATE, {
        final_game_numbers: this.game_args.game_numbers,
        level: this.game_args.level,
        world_num: this.game_args.world_num,
        visibility_graph: this.game_args.visibility_graph,
        args: {
          best_time: this.game_args.game_numbers.best_time,
          high_score: this.game_args.game_numbers.high_score,
          victory: this.victory
        }
      });
    } else {
      this.switch_to_world_map(true);
    }
  }
}

RewardGameState.prototype.determine_rewards = function() {
  if(this.game_args.is_tutorial) {
    if(this.game_args.tutorial_type == "first_time_tutorial" || this.game_args.first_time_tutorial) {
      logging.send_logging_to_server('COMPLETED TUTORIAL', {skipped: this.game_args.skipped});
      /* this.rewards.push({
        type: "first_time_tutorial"
      }) */
      saveData.firstTime = false;
      saveData.saveGame();
    }
    return
  }

  if (this.main_game && this.victory) {
    if(this.hive_numbers.world == 4 &&
        saveData.tutorialsShown.indexOf(saveData.difficultyMode + "_final_victory") == -1) {
      saveData.tutorialsShown.push(saveData.difficultyMode + "_final_victory");

      this.rewards.push({
        type: "final_victory",
      })
      if (this.initial_difficulty_mode == "easy") {
        this.hard_mode_just_unlocked = true;
        saveData.difficultyMode = "normal";
      }
      saveData.saveGame();
    }
  }
}

RewardGameState.prototype.on_key_down = function(keyCode) {
  if(this.rewards.length == 0) {
    return
  }
  if(this.transition_state=="none" && this.rewards[this.cur_reward_index].type != "select_difficulty" &&
    this.rewards[this.cur_reward_index].type != "first_time_tutorial") {
    this.transition_state="out";
    this.transition_timer = this.transition_interval
  }
}

RewardGameState.prototype.on_click = function(x, y) {
  if(this.rewards.length == 0 ||
    (this.cur_reward_index >= 0 && this.cur_reward_index < this.rewards.length && this.rewards[this.cur_reward_index].type == "share") ||
     this.rewards[this.cur_reward_index].type == "first_time_tutorial" ||
     this.cur_reward_index >= this.rewards.length) {
    return
  }
  if (this.rewards[this.cur_reward_index].type == "select_difficulty") {
    this.normal_mode_button.on_click(x, y)
    this.challenge_mode_button.on_click(x, y)
  }

  if(this.transition_state=="none" && this.rewards[this.cur_reward_index].type != "select_difficulty") {
    this.transition_state="out";
    this.transition_timer = this.transition_interval
  }
}


RewardGameState.prototype.on_mouse_move = function(x, y) {
  if(this.rewards.length == 0) {
    return
  }
  if (this.rewards[this.cur_reward_index].type == "select_difficulty") {
    this.normal_mode_button.on_mouse_move(x, y)
    this.challenge_mode_button.on_mouse_move(x, y)
  }
}

module.exports = RewardGameState;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../core/logging.js":8,"../core/music_player.js":10,"../data/constants.js":13,"../data/level_data.js":16,"../data/quest_data.js":17,"../data/sprite_data.js":18,"../game_states/game_state.js":49,"../load/save_data.js":69,"../render/background.js":73,"../render/quest.js":80,"../render/ui.js":82,"../ui/icon_button.js":87}],61:[function(require,module,exports){
var _ = require('lodash');
var audioData = require('../data/audio_data.js');
var constants = require('../data/constants.js');
var debugVars = require('../data/debug.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');

var Background = require('../render/background.js');
var CreditsState = require('../game_states/credits_state.js');
var Fader = require('../game_states/fader_util.js');
var GameState = require('../game_states/game_state.js');
var IconButton = require('../ui/icon_button.js');
var LevelEditorState = require('../game_states/level_editor_state.js');
var MainGameSummaryState = require('../game_states/main_game_summary_state.js');
var MessageBox = require('../ui/message_box.js');
var MusicPlayerState = require('../game_states/music_player_state.js');
var OptionsMenu = require('../ui/dialog_boxes.js').OptionsMenu;
var QuestGameState = require('../game_states/quest_game_state.js');
var SmallButton = require('../ui/small_button.js');
var WorldMapState = require('../game_states/world_map_state.js');

TitleState.prototype = new GameState

TitleState.prototype.constructor = TitleState

TitleState.prototype.isTitleState = true;

function TitleState() {
  this.buttons = [];
  var _this = this
  this.bg_drawn = false
  this.visibility = 0;

  this.setup_main_menu()

  music_player.play_bg(audioData.songs["Menu"])

  this.fader = new Fader({
    "fade_in": 500,
    "fade_out": 250
  });
  this.fader.set_animation("fade_in");
  this.trailer_fade_in = 0;
  this.trailer_fade_total = 8000;
  this.trailer_fade_delay = 7000;

  if (debugVars.is_beta) {
    this.feedback_button = new SmallButton(
    "HELP US IMPROVE THE BETA", 18, 400, 570, 200, 50, "#999", "#fff",
      function() {
        window.open('http://goo.gl/forms/dmZlmtpJd0');
    });
    this.buttons.push(this.feedback_button);
  }
}

TitleState.prototype.process = function(dt) {
  this.fader.process(dt);
  this.trailer_fade_in += dt
  game_engine.processAndDrawBg(dt);
}

TitleState.prototype.draw = function(ctx) {
  if(!this.bg_drawn) {
    layers.bgCanvas.setAttribute("style", "")
    game_engine.setBg(graphics.menuBackground);
    this.bg_drawn = true
  }

  ctx.save()

  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }

  ctx.shadowColor = constants.colors["impulse_blue"]
  ctx.shadowBlur = 0
  if (debugVars.is_beta) {
    uiRenderUtils.drawLogo(ctx,constants.levelWidth/2, 195, "BETA")
  } else {
    uiRenderUtils.drawLogo(ctx,constants.levelWidth/2, 195, "")
  }

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(ctx)
  }

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].post_draw(ctx)
  }

  ctx.restore()

}

TitleState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
}

TitleState.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
}

TitleState.prototype.setup_main_menu = function() {
  var buttons_to_add = [];

  buttons_to_add.push({
    text: 'START GAME',
    action: function () {
      if(saveData.savedGame && saveData.savedGame.game_numbers) {
        _this.fader.set_animation("fade_out", function() {
          game_engine.switch_game_state(gsKeys.MAIN_GAME_SUMMARY_STATE, {
            world_num: null,
            victory: null,
            hive_numbers: null,
            visibility_graph: null,
            save_screen: true,
            just_saved: false
          });
        });
      } else {
        var i = saveData.latestWorld();
        game_engine.setBg(graphics.menuBackground);
        _this.fader.set_animation("fade_out", function() {
          game_engine.switch_game_state(gsKeys.WORLD_MAP_STATE, {
            world: i,
            is_practice_mode: false
          });
        });
      }
    }
  });

  if (!saveData.firstTime) {
    buttons_to_add.push({
      text: 'PRACTICE',
      action: function () {
        var i = saveData.latestWorld();
        game_engine.setBg(graphics.menuBackground);
        _this.fader.set_animation("fade_out", function() {
          game_engine.switch_game_state(gsKeys.WORLD_MAP_STATE, {
            world: i,
            is_practice_mode: true
          });
        });
      }
    });
  }

  buttons_to_add.push({
    text: 'OPTIONS',
    action: function () {
      _this.fader.set_animation("fade_out", function() {
        game_engine.set_dialog_box(new OptionsMenu(_this))
      });
    }
  });

  buttons_to_add.push({
    text: 'ACHIEVEMENTS',
    action: function () {
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.QUEST_GAME_STATE, {});
      });
    }
  });

  buttons_to_add.push({
    text: 'CREDITS',
    action: function () {
      _this.fader.set_animation("fade_out", function() {
        game_engine.switch_game_state(gsKeys.CREDITS_STATE, {});
      });
    }
  });

  if (debugVars.jukebox_enabled) {
    buttons_to_add.push({
      text: 'JUKEBOX',
      action: function () {
        _this.fader.set_animation("fade_out", function() {
          game_engine.switch_game_state(gsKeys.MUSIC_PLAYER_STATE, {});
        });
      }
    })
  }

  if (debugVars.dev) {
    buttons_to_add.push({
      text: 'LEVEL EDITOR',
      action: function () {
        _this.fader.set_animation("fade_out", function() {
          game_engine.switch_game_state(gsKeys.LEVEL_EDITOR_STATE, {});
          window.gs = game_engine.cur_game_state;
        });
      }
    })
  }

  var _this = this;
  _.forEach(buttons_to_add, function(button_data, i) {
    var height = 292 + 36 * i;
    _this.buttons.push(new SmallButton(button_data.text, 24, 400, height, 200, 36, "#999", "#fff",
      button_data.action));
  });

  return;
  _this = this;
  this.buttons["menu"] = []
  var button_color = "white"

  var fullscreenButton = new IconButton("", 20, constants.levelWidth - 20, 20, 30, 30, button_color, constants.colors["impulse_blue"], function() {
    game_engine.toggleFullScreen();
  }, "fullscreen_in_game");
  fullscreenButton.add_hover_overlay(new MessageBox("fullscreen_msg", constants.colors["world 0 bright"], 0))
  this.buttons["menu"].push(fullscreenButton);
  var muteButton = new IconButton("", 20, constants.levelWidth - 50, 20, 30, 30, button_color, constants.colors["impulse_blue"], function() {
     game_engine.toggleMute();
  }, "mute_in_game");
  muteButton.add_hover_overlay(new MessageBox("mute_msg", constants.colors["world 0 bright"], 0))
  this.buttons["menu"].push(muteButton);
}

TitleState.prototype.change_mode = function(type) {
  saveData.difficultyMode = type;

  saveData.saveGame();
  this.set_difficulty_button_underline();
}

TitleState.prototype.set_difficulty_button_underline = function() {
  this.easy_mode_button.underline = (saveData.difficultyMode == "easy");
  this.normal_mode_button.underline = (saveData.difficultyMode == "normal");
}

module.exports = TitleState;

},{"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../core/music_player.js":10,"../data/audio_data.js":12,"../data/constants.js":13,"../data/debug.js":14,"../data/sprite_data.js":18,"../game_states/credits_state.js":46,"../game_states/fader_util.js":47,"../game_states/game_state.js":49,"../game_states/level_editor_state.js":53,"../game_states/main_game_summary_state.js":56,"../game_states/music_player_state.js":58,"../game_states/quest_game_state.js":59,"../game_states/world_map_state.js":62,"../load/save_data.js":69,"../render/background.js":73,"../render/ui.js":82,"../ui/dialog_boxes.js":86,"../ui/icon_button.js":87,"../ui/message_box.js":89,"../ui/small_button.js":94,"lodash":99}],62:[function(require,module,exports){
var audioData = require('../data/audio_data.js');
var constants = require('../data/constants.js');
var controls = require('../core/controls.js');
var debugVars = require('../data/debug.js');
var game_engine = require('../core/game_engine.js');
var graphics = require('../core/graphics.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var saveData = require('../load/save_data.js');
var spriteData = require('../data/sprite_data.js');
var uiRenderUtils = require('../render/ui.js');

var Background = require('../render/background.js');
var Fader = require('../game_states/fader_util.js');
var GameState = require('../game_states/game_state.js');
var IconButton = require('../ui/icon_button.js');
var Level = require('../level/level.js');
var SelectDifficultyButton = require('../ui/select_difficulty_button.js');

WorldMapState.prototype = new GameState

WorldMapState.prototype.constructor = WorldMapState

function WorldMapState(opts) {
  // is_practice_mode
  // world

  this.is_practice_mode = opts.is_practice_mode;
  this.world_num = opts.world

  this.bg_drawn = false
  this.color = "white"//constants.colors["impulse_blue"]

  this.next_world = null;

  this.cur_difficulty_mode = saveData.difficultyMode;
  this.next_difficulty_mode = null;
  this.transition_to_world_num = null;

  this.buttons = []
  var _this = this

  this.buttons.push(new IconButton("BACK", 16, 70, constants.levelHeight/2+260, 60, 65, this.color, constants.colors["impulse_blue"], function(){
    _this.fader.set_animation("fade_out", function() {
      game_engine.switch_game_state(gsKeys.TITLE_STATE, {});
    });
    game_engine.setBg(graphics.menuBackground);
  }, "back"));

  this.difficulties = ["easy", "normal"];

  if (saveData.isHardModeUnlocked() || debugVars.dev || debugVars.god_mode) {
    this.select_difficulty_button = new SelectDifficultyButton(16, 730, constants.levelHeight/2+260, 100, 65, this.color, constants.colors["impulse_blue"], this)
    this.buttons.push(this.select_difficulty_button);
  }

  this.num_mode_buttons = 5

  this.requirements = {
    2: "DEFEAT HIVE 1 TO UNLOCK",
    3: "DEFEAT HIVE 2 TO UNLOCK",
    4: "DEFEAT HIVE 3 TO UNLOCK"
  }

  this.offsets = {
    1: 23,
    2: 18,
    3: 20,
    4: 20
  }


  this.world_button_y = constants.levelHeight/2;
  this.set_up_buttons();

  music_player.play_bg(audioData.songs["Menu"])

  this.fade_out_interval_main = 500
  this.fade_out_interval_practice = 250
  this.fade_out_interval = null
  this.fade_out_duration = null

  this.fader = new Fader({
    "fade_in": 250,
    "fade_across": 250,
    "fade_out": 250
  });

  this.fader.set_animation("fade_in");

  // This uses methods from level.js
  this.gateway_particles = []
  this.gateway_particle_gen_interval = 1000
  this.gateway_particle_gen_timer = this.gateway_particle_gen_interval
  this.gateway_particle_duration = 2000
  // We need to divide by draw_factor due to the implementation in level.js
  this.gateway_loc = {x: constants.levelWidth/2/constants.drawFactor, y: this.world_button_y/constants.drawFactor}
  this.gateway_size = 5
  this.gateway_particles_per_round = 8

  // If this is the first time, take the player to the tutorial.
  if (saveData.firstTime) {
    // If we don't set timeout, the click event will set world map state back to the game state.
    setTimeout(function() {
      game_engine.switch_game_state(gsKeys.MAIN_GAME_TRANSITION_STATE, {
        world_num: 0,
        last_level: null,
        visibility_graph: null,
        hive_numbers: null,
        loading_saved_game: false
      });
    });
  }
}

WorldMapState.prototype.set_up_buttons = function() {

  this.world_unlocked = {};

  for (var i = 0; i < this.difficulties.length; i++) {
    var difficulty = this.difficulties[i];
    this.world_unlocked[difficulty] = {
      0: true,
      1: true,
      2: saveData.hasBeatenWorldForDifficulty(1, difficulty) || debugVars.dev || debugVars.god_mode,
      3: saveData.hasBeatenWorldForDifficulty(2, difficulty) || debugVars.dev || debugVars.god_mode,
      4: saveData.hasBeatenWorldForDifficulty(3, difficulty) || debugVars.dev || debugVars.god_mode,
    }
  }

  this.world_buttons = {}
  // the things you select at the bottom
  this.mode_buttons = {}

  this.practice_buttons = {}

  for (var i = 0; i < this.difficulties.length; i++) {
    this.world_buttons[this.difficulties[i]] = {};
    this.mode_buttons[this.difficulties[i]] = [];
    this.practice_buttons[this.difficulties[i]] = {};
    this.set_up_mode_buttons(this.difficulties[i])
    if (!this.is_practice_mode) {
      this.set_up_world_map(this.difficulties[i])
    } else {
      this.set_up_practice_buttons(this.difficulties[i])
      this.set_up_world_icon(0, constants.levelWidth/2, this.world_button_y, true, this.difficulties[i])
    }
  }
}

WorldMapState.prototype.set_up_world_map = function(difficulty) {
    var _this = this;
    for (var i = 0; i <= 4; i++) {
      this.set_up_world_icon(i, constants.levelWidth/2, this.world_button_y, this.world_unlocked[difficulty][i], difficulty)
    }
}

WorldMapState.prototype.set_up_mode_buttons = function(difficulty) {
  var diff = 75
  var button_color = "white"
  var text = ["T", "1", "2", "3", "4"]
  var num_buttons_to_show = 2; // always show world 1 and tutorial
  // Get the number of buttons to show.
  for(var i = 2; i < this.num_mode_buttons; i++) {
    if(i > 1 && !this.world_unlocked[difficulty][i]) {
      break;
    } else {
      num_buttons_to_show += 1;
    }
  }
  var cur_x =  constants.levelWidth/2 - ((num_buttons_to_show - 1) * 0.5) * diff

  for(var i = 0; i < num_buttons_to_show; i++) {
    var _this = this;
    var callback = (function(index) {
      return function() {
        if (_this.world_num != index) {
          _this.fader.set_animation("fade_across", function() {
            _this.world_num = index;
          });
          _this.next_world = index;
          _this.next_difficulty_mode = _this.cur_difficulty_mode;
        }
      };
    })(i)
    this.mode_buttons[difficulty].push(new IconButton(text[i], 16, cur_x + (i)*diff, constants.levelHeight/2+250, 60, 60, constants.colors["world "+i+" bright"], constants.colors["impulse_blue"], callback, "world"+i))
  }
}

// Update background based on index and current difficulty.
WorldMapState.prototype.update_on_difficulty_change = function(difficulty) {
  if (this.cur_difficulty_mode != difficulty) {
    var _this = this;
    // If the current world isn't unlocked in the new difficulty, change to the latest that is unlocked.
    var i = this.world_num;
    while (i > 1 && !this.world_unlocked[difficulty][i]) {
      i -= 1;
    }
    this.fader.set_animation("fade_across", function() {
      _this.cur_difficulty_mode = _this.next_difficulty_mode;
      _this.world_num = i;
    });

    this.next_world = i;
    this.next_difficulty_mode = difficulty
  }
};

WorldMapState.prototype.set_up_practice_buttons = function(difficulty) {

  var diff = 85

  for(var i = 1; i <= 4; i++) {
    this.practice_buttons[difficulty][i] = []
    // var colors = ["world "+i+" bright", "world "+i+" bright", "silver", "gold"]
    for(var j = 0; j < 8; j++) {

      var level_name = "HIVE "+i+"-"+(j+1);
      if(j == 7) {
        level_name = "BOSS "+i
      }
      var _this = this;
      var this_color = constants.colors["world "+i+" bright"];
      var callback = (function(level, index) {
        return function() {
          _this.fade_out_interval = _this.fade_out_interval_practice
          _this.fade_out_duration = _this.fade_out_interval;
          _this.fade_out_color = constants.colors["world "+ index +" dark"];
          _this.transition_to_world_num = index;
          var world_bg_ctx = layers.worldMenuBgCanvas.getContext('2d')
          _this.draw_world_bg(world_bg_ctx)
          setTimeout(function(){
            game_engine.switch_game_state(gsKeys.LEVEL_INTRO_STATE, {
              level_name: level,
              world: index
            });
          }, _this.fade_out_interval_practice)
        }

      })(level_name, i)
      var x = constants.levelWidth/2 + ((-1.5 + (j % 4)) * 150);
      var y = j >= 4 ? constants.levelHeight/2+100  : constants.levelHeight/2

      var new_button = new IconButton(j+1, 30, x, y, 75, 75, this_color, this_color, callback, "practice"+i);
      new_button.underline_on_hover = false
      new_button.level_name = level_name
      this.practice_buttons[difficulty][i].push(new_button)
      new_button.active = saveData.hasBeatenLevel(level_name) ||
        (j == 0 && this.world_unlocked[difficulty][i]) || (debugVars.dev || debugVars.god_mode)
      if(!new_button.active) {
        new_button.color = "gray"
      }
    }
  }
}

WorldMapState.prototype.set_up_world_icon = function(world_num, x, y, unlocked, difficulty) {
  var text = unlocked ? "START" : "LOCKED";
  var _this = this
  this.world_buttons[difficulty][world_num] = new IconButton(text, 50, x, y, 150, 150, constants.colors["world "+world_num+" bright"], constants.colors["world "+world_num+" bright"],
    function(){
      _this.fade_out_interval = _this.fade_out_interval_main
      _this.fade_out_duration = _this.fade_out_interval;
      _this.fade_out_color = constants.colors["world "+world_num+" dark"];
      _this.transition_to_world_num = world_num;
      var world_bg_ctx = layers.worldMenuBgCanvas.getContext('2d')
      _this.draw_world_bg(world_bg_ctx)
      setTimeout(function(){
        game_engine.switch_game_state(gsKeys.MAIN_GAME_TRANSITION_STATE, {
          world_num: world_num,
          last_level: null,
          visibility_graph: null,
          hive_numbers: null,
          loading_saved_game: false
        });
      }, _this.fade_out_interval_main)}, "world"+world_num)
  this.world_buttons[difficulty][world_num].active = unlocked
}

WorldMapState.prototype.draw_world_bg = function(ctx) {
  uiRenderUtils.tessellateBg(ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+this.world_num)
}

WorldMapState.prototype.draw = function(ctx, bg_ctx) {
  if (saveData.firstTime) {
    return
  }
  if(this.fade_out_color) {
    ctx.save()
    ctx.globalAlpha = 1-(this.fade_out_duration/this.fade_out_interval)
    ctx.fillStyle = this.fade_out_color
    ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)
    ctx.globalAlpha *= uiRenderUtils.getBgOpacity(this.world_num)
    if (!saveData.shouldShowLevelZero(this.transition_to_world_num) &&
      !debugVars.show_zero_level) {
      ctx.drawImage(layers.worldMenuBgCanvas, 0, 0, constants.levelWidth, constants.levelHeight, 0, 0, constants.levelWidth, constants.levelHeight)
    }
    ctx.restore()
  }
  ctx.save()

  if(this.fade_out_duration != null) {
    ctx.globalAlpha *= Math.max((this.fade_out_duration/this.fade_out_interval), 0)
  }

  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }


  if(!this.bg_drawn) {
    bg_canvas.setAttribute("style", "")
    this.bg_drawn = true
  }

  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].draw(ctx)
  }

  // Only draw gateway particles if the current world is active.
  if (!this.is_practice_mode && this.world_unlocked[saveData.difficultyMode][this.world_num] ) {
    this.draw_gateway_particles(ctx, constants.drawFactor);
  }


  ctx.font = '13px Open Sans'
  ctx.fillStyle = "white"
  ctx.fillText("SELECT HIVE", constants.levelWidth/2, constants.levelHeight/2 + 215)

  if (this.fader.get_current_animation() == "fade_across") {
    ctx.save();
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
    this.draw_world(ctx, this.world_num, this.cur_difficulty_mode);
    ctx.restore();
    ctx.save();
    ctx.globalAlpha *= this.fader.get_animation_progress();
    this.draw_world(ctx, this.next_world, this.next_difficulty_mode);
    ctx.restore();
  } else {
    this.draw_world(ctx, this.world_num, this.cur_difficulty_mode);
  }
}

// Draw everything associated with a particular hive.
WorldMapState.prototype.draw_world = function(ctx, index, difficulty) {

  if (!this.is_practice_mode || index == 0) {
    this.world_buttons[difficulty][index].draw(ctx)
  }

  if (index > 0) {
    if (this.is_practice_mode) {
      if (index != 0) {
        for(var i = 0; i < this.practice_buttons[difficulty][index].length; i++) {
          this.practice_buttons[difficulty][index][i].draw(ctx)
        }
      }
    }
  }

  if(index != 0) {
    if (this.is_practice_mode) {
      ctx.fillStyle = "white"
      ctx.font = "20px Open Sans"
      ctx.fillText("PRACTICE MODE", constants.levelWidth/2, this.world_button_y - 170)
    } else if (saveData.difficultyMode == "normal") {
      ctx.fillStyle = "white"
      ctx.font = "24px Open Sans"
      ctx.fillText("HARD MODE", constants.levelWidth/2, this.world_button_y - 170)
    }
  }

  // draw hive name
  ctx.fillStyle = constants.colors["world "+index+" bright"]
  ctx.font = "42px Open Sans"
  ctx.textAlign = "center"
  if (index > 0) {
    ctx.fillText(levelData.hiveNames[index], constants.levelWidth/2, this.world_button_y - 125)
  } else {
    ctx.fillText("TUTORIAL", constants.levelWidth/2, this.world_button_y - 125)
  }

  // mode buttons
  for(var i = 0; i < this.mode_buttons[difficulty].length; i++) {
    this.mode_buttons[difficulty][i].draw(ctx)
    if(this.mode_buttons[difficulty][i].mouseOver) {
      ctx.textAlign = "center"
      ctx.font = '15px Open Sans'
      if (i == 0) {
        ctx.fillStyle = constants.colors['world '+(i)+" bright"]
        ctx.fillText("TUTORIAL", constants.levelWidth/2, constants.levelHeight - 8)
      } else if(this.mode_buttons[difficulty][i].active) {
        ctx.fillStyle = constants.colors['world '+(i)+" bright"]
        ctx.fillText(levelData.hiveNames[i], constants.levelWidth/2, constants.levelHeight - 8)
      }
    }
  }
  if (!this.is_practice_mode || index == 0) {
    this.world_buttons[difficulty][index].post_draw(ctx)
  }

  if (index > 0 && this.is_practice_mode) {
    for(var i = 0; i < this.practice_buttons[difficulty][index].length; i++) {
      this.practice_buttons[difficulty][index][i].post_draw(ctx)
    }
  }
};

WorldMapState.prototype.process = function(dt) {
  if (saveData.firstTime) {
    return
  }
  if(this.fade_out_duration != null) {
    this.fade_out_duration -= dt
  }
  if (!this.is_practice_mode)
  this.process_gateway_particles(dt);
  this.fader.process(dt);

  game_engine.processAndDrawBg(dt);
}

WorldMapState.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++)
  {
    this.buttons[i].on_mouse_move(x, y)
  }
  var difficulty = saveData.difficultyMode;
  if (!this.is_practice_mode) {
    this.world_buttons[difficulty][this.world_num].on_mouse_move(x, y)
  } else {
    if (this.world_num != 0) {
      for(var i = 0; i < this.practice_buttons[difficulty][this.world_num].length; i++) {
        this.practice_buttons[difficulty][this.world_num][i].on_mouse_move(x, y)
      }
    } else {
      this.world_buttons[difficulty][this.world_num].on_mouse_move(x, y)
    }
  }

  for(var i = 0; i < this.mode_buttons[difficulty].length; i++) {
    this.mode_buttons[difficulty][i].on_mouse_move(x, y)
  }
}

WorldMapState.prototype.on_click = function(x, y) {
  if (this.fade_out_duration != null) return
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }
  var difficulty = saveData.difficultyMode;
  if (!this.is_practice_mode) {
    this.world_buttons[difficulty][this.world_num].on_click(x, y)
  } else {
    if (this.world_num != 0) {
      for(var i = 0; i < this.practice_buttons[difficulty][this.world_num].length; i++) {
        this.practice_buttons[difficulty][this.world_num][i].on_click(x, y)
      }
    } else {
      this.world_buttons[difficulty][this.world_num].on_click(x, y)
    }
  }

  for(var i = 0; i < this.mode_buttons[difficulty].length; i++) {
    this.mode_buttons[difficulty][i].on_click(x, y)
  }
}

WorldMapState.prototype.on_key_down = function(keyCode) {
  if(keyCode == controls.keys.GOD_MODE_KEY && debugVars.god_mode_enabled) { //G = god mode
    this.set_up_buttons();
  }
};
WorldMapState.prototype.process_gateway_particles = Level.prototype.process_gateway_particles;
WorldMapState.prototype.generate_gateway_particles = Level.prototype.generate_gateway_particles;
WorldMapState.prototype.draw_gateway_particles = Level.prototype.draw_gateway_particles;

module.exports = WorldMapState;

},{"../core/controls.js":2,"../core/game_engine.js":4,"../core/graphics.js":5,"../core/layers.js":7,"../core/music_player.js":10,"../data/audio_data.js":12,"../data/constants.js":13,"../data/debug.js":14,"../data/level_data.js":16,"../data/sprite_data.js":18,"../game_states/fader_util.js":47,"../game_states/game_state.js":49,"../level/level.js":64,"../load/save_data.js":69,"../render/background.js":73,"../render/ui.js":82,"../ui/icon_button.js":87,"../ui/select_difficulty_button.js":91}],63:[function(require,module,exports){
var EnemySpawner = function(
		type,
		first_spawn_time,
		spawn_period_init,
		spawn_period_decr_per_minute,
		spawn_period_min,
		num_per_spawn_init,
		num_per_spawn_incr_per_minute,
		max_enemies) {
  this.type = type;
  this.first_spawn_time = first_spawn_time;
  this.spawn_period_init = spawn_period_init;
  this.spawn_period_decr_per_minute = spawn_period_decr_per_minute;
  this.spawn_period_min = spawn_period_min;
  this.num_per_spawn_init = num_per_spawn_init;
  this.num_per_spawn_incr_per_minute = num_per_spawn_incr_per_minute;
  this.max_enemies = max_enemies;

  // if the first_spawn is 0, then it will be in the initial_spawn, so set spawn_period to full. Otherwise 0 so it spawns immediately
  this.spawn_period = this.first_spawn_time == 0 ? this.spawn_period_init * 1000 : 1;
};

// Decrement the spawn period if applicable
EnemySpawner.prototype.process = function(dt, game_seconds) {
	if (game_seconds > this.first_spawn_time) {
		this.spawn_period -= dt;
	}
};

// Get the number of enemies to spawn in this iteration.
EnemySpawner.prototype.get_spawn_number = function(game_seconds) {
	if (this.spawn_period <= 0) {
		this.spawn_period += this.calculate_current_spawn_period_(game_seconds);
		return this.calculate_current_num_spawn_(game_seconds);
	}
}

EnemySpawner.prototype.reset_spawn_period = function(game_seconds) {
	this.spawn_period = this.calculate_current_spawn_period_(game_seconds);
}

EnemySpawner.prototype.get_type = function() {
	return this.type
}

EnemySpawner.prototype.calculate_current_spawn_period_ = function(game_seconds) {
	return Math.max(this.spawn_period_init - (game_seconds - this.first_spawn_time) / 60 * this.spawn_period_decr_per_minute,
									this.spawn_period_min) * 1000;
}

EnemySpawner.prototype.calculate_current_num_spawn_ = function(game_seconds) {
	var num_per_spawn_adj = 0
	if (this.spawn_period_decr_per_minute > 0) {
		// Calculate the current spawn period.
		var current_spawn_period = (this.spawn_period_init - (game_seconds - this.first_spawn_time) / 60 * this.spawn_period_decr_per_minute)
		// Determine if we have already gone past the spawn period min. If so, the period will no longer decrease, and we need to increase the spawn to compensate.
		var minutes_over_spawn_period_min = Math.max(0, (this.spawn_period_min - current_spawn_period) / this.spawn_period_decr_per_minute);
		// Increase the spawn by the equivalent of increasing by 2 per minute with the original spawn period. (a reasonable heuristic)
		num_per_spawn_adj = minutes_over_spawn_period_min * 2 * this.spawn_period_min / this.spawn_period_init;
	}

	return (this.num_per_spawn_init + (game_seconds - this.first_spawn_time) / 60 * this.num_per_spawn_incr_per_minute) + num_per_spawn_adj

}

EnemySpawner.prototype.get_max_enemies = function() {
		return this.max_enemies
}

module.exports = EnemySpawner;

},{}],64:[function(require,module,exports){
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var objectRenderUtils = require('../render/object.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var BasicObstacle = require('../obstacle/basic_obstacle.js');
var EnemyFactory = require('../enemy/enemy_factory.js');
var EnemySpawner = require('../level/enemy_spawner.js');
var FragmentGroup = require('../render/fragment_group.js');

var Level = function(data, impulse_game_state) {
  this.init(data, impulse_game_state)
}

Level.prototype.init = function(data, level_intro_state) {

  this.world_num = level_intro_state.world_num

  this.level_intro_state = level_intro_state
  this.impulse_game_state = null
  this.spawn_pattern = data.spawn_pattern;
  this.impulse_disabled = data.impulse_disabled;

  // If the player has died, we tell the level to blow up enemies and other maintenance to prepare for restart.
  this.restarting_level = false;

  // The length of effects that occur during restart.
  this.restarting_effects_duration = 500;

  // Retrieve enemy data. Use easy mode if necessary but default to normal.
  if (saveData.difficultyMode == "easy") {
    this.enemies_data = data.enemies_easy
  }
  if (!this.enemies_data) {
    this.enemies_data = data.enemies
  } else {
    this.using_enemies_easy = true
  }

  if (saveData.difficultyMode == "easy") {
    this.initial_spawn_data = data.initial_spawn_data_easy
  }
  if (!this.initial_spawn_data) {
    this.initial_spawn_data = data.initial_spawn_data
  } else {
    this.using_initial_spawn_data_easy = true
  }
  this.enemy_numbers = {}
  this.level_name = data.level_name
  this.is_level_zero = (parseInt(this.level_name.substring(7, 8)) === 0);
  if (this.is_level_zero) {
    this.world_num = 0;
  }

  if (saveData.difficultyMode == "easy") {
    this.multi_spawn_points = data.multi_spawn_points_easy
  }
  if (!this.multi_spawn_points) {
    this.multi_spawn_points = data.multi_spawn_points
  }

  this.pick_alt_path = data.pick_alt_path

  this.starting_loc = data.player_loc
  if (saveData.difficultyMode == "easy" && data.player_loc_easy) {
    this.starting_loc = data.player_loc_easy
  }
  this.player_loc = this.get_starting_loc()

  this.spawn_points = data.spawn_points

  this.order_spawn_points();

  this.obstacle_num = data.obstacle_num

  if (saveData.difficultyMode == "easy") {
    this.obstacle_v = data.obstacle_v_easy
  }
  if (!this.obstacle_v) {
    this.obstacle_v = data.obstacle_v
  }
  this.get_obstacle_vertices = data.get_obstacle_vertices
  this.color = constants.colors["world "+level_intro_state.world_num]
  this.dark_color = constants.colors["world "+level_intro_state.world_num+" dark"]
  this.lite_color = constants.colors["world "+level_intro_state.world_num+" lite"]
  this.bright_color = constants.colors["world "+level_intro_state.world_num+" bright"]
  this.is_boss_level = this.level_name.slice(0, 4) == "BOSS"
  if(!this.is_boss_level) {
    this.level_number = parseInt(this.level_name.slice(this.level_name.length-1, this.level_name.length))
    this.cutoff_scores = data.cutoff_scores[saveData.difficultyMode]
  }
  this.boss_victory = false

  this.buffer_radius = data.buffer_radius

  this.boundary_polygons = []; //the polygons that enemies use to calculate pathfinding
  this.obstacle_polygons = []; //the actual polygons that kill players and enemies
  this.obstacles = []
  this.obstacle_edges = []

  this.obstacle_vertices = []

  this.fragments = []
  this.total_fragments = 0
  this.max_fragments = 20

  this.gateway_opened = false

  this.tessellation_angle = 0
  this.tessellation_rotate_rate = 12000

  if (data.gateway_loc) {
    this.gateway_loc = {x: data.gateway_loc.x/constants.drawFactor, y: data.gateway_loc.y/constants.drawFactor}
  } else {
    this.gateway_loc = {x: this.get_starting_loc().x/constants.drawFactor, y: this.get_starting_loc().y/constants.drawFactor}
  }
  this.gateway_size = 4

  this.gateway_pulse_radius = 300

  this.gateway_transition_interval = 1000
  this.gateway_transition_duration = null

  // structure:
  // start_x, start_y
  // prop
  this.gateway_particles = []
  this.gateway_particle_gen_interval = 1000
  this.gateway_particle_gen_timer = this.gateway_particle_gen_interval
  this.gateway_particle_duration = 2000
  this.gateway_particles_per_round = 5

  this.spawn_point_counter = 0;
  this.reset();

  this.enemy_images = {}

  this.bulk_draw_enemies = {} // allows us to use a single beginPath/stroke to draw the same characteristics for many enemies
  this.flash_obstacle_color = null;
  this.flash_obstacle_prop = 0;
}

Level.prototype.get_starting_loc = function() {
  return this.starting_loc
}

Level.prototype.prepare_level_for_reset = function() {
  this.restarting_level = true;
  this.restarting_timer = this.restarting_effects_duration;
  for (var i = 0; i < this.enemies.length; i++) {
    this.enemies[i].start_death("fade")
  }
}

Level.prototype.reset = function() {

  if(this.impulse_game_state && this.impulse_game_state.main_game) {
    this.main_game = true
  } else {
    this.main_game = false
  }
  this.restarting_level = false;
  this.enemies = []
  this.fragments = []
  this.enemy_counter = 0
  this.spawn_interval = 200
  this.spawn_timer = this.spawn_interval
  this.enemy_visibility = 1 // for boss four
  this.gateway_opened = false
  this.obstacles_visible_timer = 0
  this.boss_radius = 3
  this.boss = null
  this.boss_spawned = false
  this.boss_victory = false
  this.tessellation_angle = 0

  this.enemy_spawners = {};

  for (i in this.enemies_data) {
    var enemy_data = this.enemies_data[i];
    this.enemy_spawners[i] = new EnemySpawner(
      i, /* type */
      enemy_data[0], /* first_spawn_time */
      enemy_data[1], /* spawn_period_init */
      enemy_data[2], /* spawn_period_decr_per_minute */
      enemy_data[3], /* spawn_period_min */
      enemy_data[4], /* num_per_spawn_init */
      enemy_data[5], /* num_per_spawn_incr_per_minute */
      enemy_data[6]  /* max_enemies */
    );
    this.enemy_numbers[i] = 0
  }

  this.dead_enemies = []
  this.expired_enemies = []
  this.spawned_enemies = []
  this.spawn_queue = [] //enemies that need to be spawned
  this.initial_spawn_done = false

  this.multi_loc = null
  this.multi_duration = null
  this.multi_life = 10000
  this.multi_value = null
}

Level.prototype.generate_multi = function() {
  var multi_index = Math.floor(Math.random() * this.multi_spawn_points.length)
  this.multi_loc = {x: this.multi_spawn_points[multi_index][0], y: this.multi_spawn_points[multi_index][1]};
  var player_loc = {x: this.impulse_game_state.player.body.GetPosition().x * constants.drawFactor, y: this.impulse_game_state.player.body.GetPosition().y * constants.drawFactor}
  while(utils.pDist(player_loc,  this.multi_loc) < 125) {
    multi_index+=1
    multi_index = multi_index % this.multi_spawn_points.length
    this.multi_loc = {x: this.multi_spawn_points[multi_index][0], y: this.multi_spawn_points[multi_index][1]};
  }

  this.multi_duration = this.multi_life
  this.multi_value = 1
}

Level.prototype.process = function(dt) {
  //handle obstacle visibility
  if (!this.is_boss_level && this.multi_spawn_points.length > 0 && this.impulse_game_state.combo_enabled) {

    this.multi_duration -= dt
    if(this.multi_loc == null || this.multi_duration < 0) {
      this.generate_multi()
    } else {
      var player_loc = {x: this.impulse_game_state.player.body.GetPosition().x * constants.drawFactor, y: this.impulse_game_state.player.body.GetPosition().y * constants.drawFactor}
      if(utils.pDist(player_loc, this.multi_loc) < 25) {
        music_player.play_sound("multi")
        this.impulse_game_state.game_numbers.base_combo += 5
        this.impulse_game_state.game_numbers.combo =
          this.impulse_game_state.game_numbers.base_combo + Math.floor(this.impulse_game_state.game_numbers.seconds/10)
        //this.add_fragments("multi", {x: this.multi_loc.x, y: this.multi_loc.y})
        this.impulse_game_state.addScoreLabel(
          "x" + this.impulse_game_state.game_numbers.combo,
          "white",
          this.multi_loc.x / constants.drawFactor,
          this.multi_loc.y / constants.drawFactor,
          20,
          2000);
        this.generate_multi()
      }
    }
  }

  if(this.gateway_transition_duration != null) {
    if(this.gateway_transition_duration > 0) {
      this.gateway_transition_duration -= dt
    } else {
      layers.bgCtx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
      this.draw_bg(layers.bgCtx)
      layers.bgCtx.translate(-constants.sideBarWidth, 0)//allows us to have a topbar
      this.gateway_transition_duration = null
    }
  }

  if (this.restarting_level) {
    this.restarting_timer -= dt;
  }

  // if the gateway is opened, process the particles
  if (this.gateway_opened) {
    this.process_gateway_particles(dt);
  }


  if(this.obstacles_visible_timer <= 0 && this.obstacle_visibility < 1)
  {
    this.obstacle_visibility = Math.min(1, this.obstacle_visibility + dt/1000)
  }
  else if(this.obstacles_visible_timer > 0 && this.obstacle_visibility > 0)
  {
    this.obstacle_visibility = Math.max(0, this.obstacle_visibility - dt/1000)
  }
  if (this.obstacles_visible_timer > 0) {
    this.obstacles_visible_timer -= dt
  }

  this.dead_enemies = []
  this.spawned_enemies = []
  this.expired_enemies = []

  for(var i = 0; i < this.enemies.length; i++) {
    this.enemies[i].process(i, dt)
  }
  while(this.dead_enemies.length > 0)
  {
    var dead_i = this.dead_enemies.pop()

    this.impulse_game_state.world.DestroyBody(this.enemies[dead_i].body)
    if(this.enemies[dead_i].type === "harpoon" ) {
      this.impulse_game_state.world.DestroyBody(this.enemies[dead_i].harpoon_head.body)
    }

    if(this.enemies[dead_i] == this.boss) {
      this.boss_victory = true
    }
  }

  for(var i = this.fragments.length - 1; i >= 0; i--) {
    this.fragments[i].process(dt);
    if(this.fragments[i].isDone()) {
      this.fragments.splice(i, 1);
      this.total_fragments -= 4;
    }
  }

  while(this.expired_enemies.length > 0)
  {
    var dead_i = this.expired_enemies.pop()

    this.enemy_numbers[this.enemies[dead_i].type] -= 1

    if(this.enemies[dead_i].type == "goo" || this.enemies[dead_i].type == "disabler") { // if goo or disabler died, reset the death timer
      this.enemy_spawners[this.enemies[dead_i].type].reset_spawn_period(this.impulse_game_state.game_numbers.seconds);
    }

    this.enemies.splice(dead_i, 1)
  }

  while(this.spawned_enemies.length > 0)
  {
    var new_enemy = this.spawned_enemies.pop()
    this.add_enemy(new_enemy)
  }

  if(!this.initial_spawn_done) {
    this.initial_spawn()
    this.initial_spawn_done = true;
  } else {
    if (this.level_name == "HIVE 0-3" && this.impulse_game_state.gateway_unlocked) {
      // Do not spawn enemies if we're on tutorial level and have already unlocked gateway.
    } else {
      this.check_enemy_spawn_timers(dt)

      if(this.spawn_timer >= 0) {
        this.spawn_timer -= dt
      }
      else {
        if(this.spawn_queue.length > 0) {
          var enemy_type_to_spawn = this.spawn_queue[0].type;
          var spawn_point_index = this.spawn_queue[0].spawn_point;
          this.spawn_queue = this.spawn_queue.slice(1)
          this.spawn_this_enemy(enemy_type_to_spawn, spawn_point_index)
          this.spawn_timer = this.spawn_interval
        }
      }
    }
  }

  if(this.boss_victory) {
    for(var i = 0; i < this.enemies.length; i++) {
      if(!this.enemies[i].dying)
        this.enemies[i].start_death("kill")
    }
  }
}

Level.prototype.order_spawn_points = function() {
  this.spawn_points.sort(function(a, b) {
    var angle_a = utils.atan({x: 400, y: 300}, {x: a[0], y: a[1]});
    var angle_b = utils.atan({x: 400, y: 300}, {x: b[0], y: b[1]});
    return angle_a - angle_b;
  })
}

Level.prototype.initial_spawn = function() {
  if(this.initial_spawn_data) {
    var enemy_type_list = [];
    for(var enemy in this.initial_spawn_data) {

      var num_enemies_to_spawn = this.initial_spawn_data[enemy]
      if(!this.is_boss_level && saveData.difficultyMode == "easy" && !this.using_initial_spawn_data_easy) {
        num_enemies_to_spawn = Math.max(1, 0.5 * num_enemies_to_spawn)
      }

      for (var i = 0; i < num_enemies_to_spawn; i++) {
        enemy_type_list.push(enemy);
      }

      if (this.spawn_pattern == "separate_by_type") {
        this.spawn_enemy_set(enemy_type_list);
        enemy_type_list = [];
      }
    }
    if (this.spawn_pattern != "separate_by_type") {
      this.spawn_enemy_set(enemy_type_list);
    }
  }
}

Level.prototype.spawn_enemy_set = function(enemy_type_list) {
  var pivot_spawn_index = this.pick_pivot_spawn_index();
  var enemies_left = enemy_type_list.slice(0);
  for (var i = 0; i < enemy_type_list.length; i++) {
    // Spread the spawn around the unit circle.
    var next_spawn_index = pivot_spawn_index + Math.floor(i / enemy_type_list.length * this.spawn_points.length);
    var enemy_index = Math.floor(Math.random() * enemies_left.length);
    this.spawn_this_enemy(enemies_left[enemy_index], next_spawn_index);
    enemies_left.splice(enemy_index, 1);
  }
}

Level.prototype.pick_pivot_spawn_index = function() {
  // Pick the spawn point furthest from any enemy.
  if (this.spawn_pattern == "spread") {
    var max_distance = 0;
    var best_spawn_point = Math.floor(Math.random() * this.spawn_points.length);
    for (var i = 0; i < this.spawn_points.length; i++) {
      var spawn_point = {x: this.spawn_points[i][0] / constants.drawFactor, y: this.spawn_points[i][1] / constants.drawFactor};
      var min_dist = -1;
      for (var j = 0; j < this.enemies.length; j++) {
        var dist_to_enemy = utils.pDist(this.enemies[j].body.GetPosition(), spawn_point);
        if (min_dist == -1 || dist_to_enemy < min_dist) {
          min_dist = dist_to_enemy;
        }
      }
      if (min_dist > max_distance) {
        max_distance = min_dist;
        best_spawn_point = i;
      }
    }
    return best_spawn_point;
  } else {
    // The default is a random spawn point.
    return Math.floor(Math.random() * this.spawn_points.length)
  }
}

Level.prototype.check_enemy_spawn_timers = function(dt) {
  if (this.is_boss_level) return

  var enemy_type_list = [];

  for(var enemy_type in this.enemy_spawners) {
    var enemy_spawner = this.enemy_spawners[enemy_type]

    enemy_spawner.process(dt, this.impulse_game_state.game_numbers.seconds);

    var num_enemies_to_spawn = enemy_spawner.get_spawn_number(this.impulse_game_state.game_numbers.seconds);

    if(num_enemies_to_spawn > 0) {

      if(saveData.difficultyMode == "easy" && !this.using_enemies_easy) {
        num_enemies_to_spawn = Math.max(1, 0.5 * num_enemies_to_spawn)
      }

      for (var i = 1; i <= num_enemies_to_spawn; i++) {
        enemy_type_list.push(enemy_type);
      }
    }
  }
  this.spawn_enemy_set(enemy_type_list);
  if (this.enemies.length == 0 && this.spawn_queue.length == 0) {
    this.skip_enemy_spawn_timers()
  }
}

Level.prototype.skip_enemy_spawn_timers = function() {
  var min_timer = 1000
  // find the minimum time to next enemy spawn
  for(var enemy_type in this.enemy_spawners) {
    var enemy_spawner = this.enemy_spawners[enemy_type];
    if (this.impulse_game_state.game_numbers.seconds > enemy_spawner.first_spawn_time) {
      min_timer = Math.min(min_timer, enemy_spawner.spawn_period)
    }
  }

  // adjust all enemy timers accordingly, but skip those that haven't spawned yet
  for(var enemy_type in this.enemy_spawners) {
    var enemy_spawner = this.enemy_spawners[enemy_type];
    enemy_spawner.process(min_timer, this.impulse_game_state.game_numbers.seconds)
  }
}

//v = {x: 0, y: 0}
Level.prototype.add_fragments = function(enemy_type, loc, v, shadowed) {
  if(enemy_type == "player" || enemy_type == "shadow" || enemy_type == "multi" || enemy_type.slice(enemy_type.length - 4, enemy_type.length) == "boss"
    || (this.total_fragments < this.max_fragments && saveData.optionsData.explosions)) {
      this.fragments.push(new FragmentGroup(enemy_type, loc, v, shadowed))
      this.total_fragments += 4;
  }
}

Level.prototype.spawn_this_enemy = function(enemy_type, spawn_point) {
  if (this.restarting_level) {
    return
  }

  var this_enemy = EnemyFactory.getEnemyClassFromType(enemy_type);

  if(this_enemy.prototype.is_boss && this.boss_spawned) {
    return;
  }

  //if at the cap, don't spawn more
  if(this.enemy_numbers[enemy_type] >= this.enemy_spawners[enemy_type].get_max_enemies()) {
    return
  }

  if(this_enemy.prototype.is_boss) {
    var temp_enemy = new this_enemy(this.impulse_game_state.world, constants.levelWidth/constants.drawFactor/2, (constants.levelHeight)/constants.drawFactor/2, this.enemy_counter, this.impulse_game_state)
    this.boss = temp_enemy
    this.boss_spawned = true
  }
  else if(this.spawn_points) {
    var r_p = this.spawn_points[spawn_point % this.spawn_points.length]
    var temp_enemy = new this_enemy(this.impulse_game_state.world, r_p[0]/constants.drawFactor, r_p[1]/constants.drawFactor, this.enemy_counter, this.impulse_game_state)
  }
  else {
    var r_p = utils.getRandomOutsideLocation(5, 2)
    var temp_enemy = new this_enemy(this.impulse_game_state.world, r_p.x, r_p.y, this.enemy_counter, this.impulse_game_state)
  }

  this.add_enemy(temp_enemy)
}

Level.prototype.add_enemy = function(enemy) {
  this.enemies.push(enemy)

  this.enemy_counter+=1

  this.enemy_numbers[enemy.type] += 1

  if(enemy.is_boss) this.boss = enemy

  if(enemy.has_bulk_draw && !this.bulk_draw_enemies.hasOwnProperty(enemy.type)) {
    this.bulk_draw_enemies[enemy.type] = enemy.bulk_draw_nums
  }
}

Level.prototype.generate_obstacles = function() {

  if(this.obstacle_num == null && this.obstacle_v.length) {
    this.obstacle_num = this.obstacle_v.length
  }

  for(var i = 0; i < this.obstacle_num; i++)
  {
    var temp_v = this.get_obstacle_vertices(i)
    if (this.is_level_zero) {
      this.obstacles.push(new BasicObstacle(temp_v,
        constants.colors["world "+this.world_num+" lite"],
        constants.colors["world "+this.world_num+" dark"]))
    } else {
      this.obstacles.push(new BasicObstacle(temp_v,
        constants.colors["world "+this.level_intro_state.world_num+" lite"],
        constants.colors["world "+this.level_intro_state.world_num+" dark"]))
    }
    this.obstacle_polygons.push(temp_v)
    for(var j = 0; j < temp_v.length; j++) {
      this.obstacle_vertices.push(temp_v[j])
    }
    this.boundary_polygons.push(utils.getBoundaryPolygon(temp_v, this.buffer_radius))
  }
  this.generate_obstacle_edges()
}

Level.prototype.generate_obstacle_edges = function() {

  for(var i = 0; i < this.obstacles.length; i++)
  {
    var obstacle = this.obstacles[i]
    var k = obstacle.verticeSet.length - 1
    for(var j = 0; j < obstacle.verticeSet.length; j++)
    {
      this.obstacle_edges.push({"p1": obstacle.verticeSet[k], "p2": obstacle.verticeSet[j]})
      k = j
    }
  }
}

Level.prototype.draw_gateway = function(ctx, draw_factor) {
  if(this.is_boss_level) {
    if (!this.impulse_game_state.boss_after_death_actions) {
      return;
    }
  }
  var world_num = this.level_intro_state.world_num;
  if (this.is_boss_level && this.boss && (this.boss.dying || this.boss.died)) {
    world_num = 0;
  }
  ctx.save()

  if(this.gateway_transition_duration != null && this.world_num <= 4) {
    var prog = Math.max(this.gateway_transition_duration / this.gateway_transition_interval, 0);
    ctx.globalAlpha *= 0.3 + 0.2 * (1-prog)
    ctx.strokeStyle = constants.colors["world "+world_num+" bright"]
    if (this.level_name != "HIVE 0-1" && this.level_name != "HIVE 0-2" && !this.is_level_zero) {
      ctx.save();
      if (prog > 0.5) {
        // go from 0.3 to 0.8
        ctx.globalAlpha = 0.3 + (1 - prog)
      } else {
        // go from 0.8 to 0
        ctx.globalAlpha = Math.max(0, 0 + 1.6 * (prog))
      }
      ctx.beginPath();
      ctx.arc(
        this.gateway_loc.x * draw_factor,
        this.gateway_loc.y * draw_factor,
        this.gateway_pulse_radius * (1 - prog),
        0,
        Math.PI * 2
      )
      ctx.lineWidth = 2 + 8 * prog;
      ctx.stroke();
      ctx.restore();
    }
  }
  else if(this.impulse_game_state && this.gateway_opened && this.world_num <= 4) {
    ctx.globalAlpha *= 0.7
  } else {
    ctx.globalAlpha *= 0.3
  }
  uiRenderUtils.drawTessellationSign(
    ctx,
    world_num,
    this.gateway_loc.x * draw_factor,
    this.gateway_loc.y * draw_factor,
    this.gateway_size * draw_factor,
    this.gateway_opened,
    0)//this.tessellation_angle)


  if (this.gateway_opened) {
    this.draw_gateway_particles(ctx, draw_factor);
  }
  ctx.restore()
}

Level.prototype.pre_draw = function(context, draw_factor) {
    if(this.gateway_loc) {
      this.draw_gateway(context, draw_factor)
    }
}

Level.prototype.flash_obstacles = function(color, prop) {
  this.flash_obstacle_prop = prop;
  this.flash_obstacle_color = color;
}

Level.prototype.draw = function(context, draw_factor) {
  context.save()

  if (this.flash_obstacle_prop > 0) {
    context.save();
    context.globalAlpha = this.flash_obstacle_prop;

    for(var i = 0; i < this.obstacles.length; i++) {
      var origColor = this.obstacles[i].color;
      this.obstacles[i].color = this.flash_obstacle_color;
      this.obstacles[i].draw(context, constants.drawFactor)
      this.obstacles[i].color = origColor;
    }
    context.restore();
  }

  if(this.multi_loc) {
    var prog = this.multi_duration/this.multi_life;
    context.save()
    context.globalAlpha *= Math.min(1, (1 - 2*Math.abs(prog-0.5))/.7)

    // if restarting level, force the multi to fade.
    if (this.restarting_level) {
      context.globalAlpha *= Math.max(0, this.restarting_timer / this.restarting_effects_duration)
    }

    objectRenderUtils.drawMultiPowerup(context, this.multi_loc.x, this.multi_loc.y, prog)
    context.restore()

  }

  if(this.redraw_bg) {
    layers.bgCtx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
    this.draw_bg(layers.bgCtx, true)
    layers.bgCtx.translate(-constants.sideBarWidth, 0)//allows us to have a topbar
    this.redraw_bg = false
  }

  if (this.enemy_visibility != 1) {
    context.save();
    context.globalAlpha *= this.enemy_visibility;
  }

  for(var i = 0; i < this.fragments.length; i++) {
    this.fragments[i].draw(context, draw_factor)
  }

  for(var i = 0; i < this.enemies.length; i++) {
    this.enemies[i].pre_draw(context, draw_factor)
  }

  for(var type in this.bulk_draw_enemies) {
    var num_bulks = this.bulk_draw_enemies[type]
    for(var num = 1; num <= num_bulks; num++) {
      var firstEnemy = null
      for(var i = 0; i < this.enemies.length; i++) {
        if(this.enemies[i].type == type) {
          if(firstEnemy == null) {
            firstEnemy = this.enemies[i]
            firstEnemy.bulk_draw_start(context, draw_factor, num)
          }
          this.enemies[i].bulk_draw(context, draw_factor, num)
        }

      }
      if(firstEnemy != null) {
        firstEnemy.bulk_draw_end(context, draw_factor, num)
      }
    }

  }
  for(var i = 0; i < this.enemies.length; i++) {
    this.enemies[i].draw(context, draw_factor)
  }


  for(var i = 0; i < this.enemies.length; i++) {
    this.enemies[i].final_draw(context, draw_factor)
  }

  if (this.enemy_visibility != 1) {
    context.restore();
  }

  if(this.boss_delay_timer >= 0) {

    context.beginPath()
    context.arc(constants.levelWidth/draw_factor/2 * draw_factor, (constants.levelHeight)/draw_factor/2 * draw_factor, (this.boss_radius * 2 *draw_factor), -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * (this.boss_delay_timer / this.boss_delay_interval), true)

    context.lineWidth = 2
    context.strokeStyle = "gray"
    context.stroke()

    context.globalAlpha = 1
  }

  context.restore()
}

Level.prototype.final_draw = function(context, draw_factor) {
};

Level.prototype.open_gateway = function() {
  this.gateway_transition_duration = this.gateway_transition_interval
  this.gateway_opened = true
}

Level.prototype.draw_bg = function(bg_ctx, omit_gateway) {
  bg_ctx.save()
  bg_ctx.beginPath();
  bg_ctx.rect(0, 0, constants.levelWidth, constants.levelHeight)
  if (this.world_num != null && this.is_boss_level && this.boss && (this.boss.dying || this.boss.died)) {
    bg_ctx.fillStyle = constants.colors['world 0 bg'];
  } else {
    bg_ctx.fillStyle = constants.colors['world ' + this.world_num + ' bg'];
  }
  bg_ctx.fill();
  bg_ctx.clip()
  bg_ctx.save();
  bg_ctx.globalAlpha *= uiRenderUtils.getLevelBgOpacity(this.world_num);

  if (this.world_num != null && this.is_boss_level && this.boss && (this.boss.dying || this.boss.died)) {
    bg_ctx.save();
    uiRenderUtils.tessellateBg(bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive 0")
    bg_ctx.restore();
  } else if(this.world_num != null && !this.is_level_zero) {
    bg_ctx.save();
    uiRenderUtils.tessellateBg(bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive "+this.world_num)
    bg_ctx.restore();
  } else if (this.world_num != null && this.is_level_zero) {
    bg_ctx.save();
    uiRenderUtils.tessellateBg(bg_ctx, 0, 0, constants.levelWidth, constants.levelHeight, "Hive 0");
    bg_ctx.restore();
  } else {
    bg_ctx.fillStyle = constants.colors["world 0 bright"]
    bg_ctx.fillRect(0, 0, constants.levelWidth, constants.levelHeight)
  }
  bg_ctx.restore();

  if (this.is_level_zero) {
    bg_ctx.save();
    var r = 0.15;
    var x = this.gateway_loc.x * constants.drawFactor;
    var y = this.gateway_loc.y * constants.drawFactor;
    uiRenderUtils.tessellateBg(bg_ctx, x - constants.levelWidth * r, y - constants.levelHeight * r,
      x + constants.levelWidth * r, y + constants.levelHeight * r,
      "Hive "+this.level_intro_state.world_num);
    bg_ctx.restore();
    bg_ctx.beginPath();
    bg_ctx.rect(x - constants.levelWidth * r, y - constants.levelHeight * r,
      2 * constants.levelWidth * r, 2 * constants.levelHeight * r);
    bg_ctx.lineWidth = 2;
    bg_ctx.strokeStyle = constants.colors["world " + this.level_intro_state.world_num + " dark"];
    bg_ctx.stroke();
  }


  for(var i = 0; i < this.obstacles.length; i++) {
    this.obstacles[i].draw(bg_ctx, constants.drawFactor)
  }

  // Draw any additional rectangles to hide obstacle seams.
  if ((this.is_boss_level || this.is_level_zero) && this.obstacle_polygons.length > 0) {
    bg_ctx.fillStyle = constants.colors["world " + this.world_num + " dark"]
    bg_ctx.fillRect(375, 0, 50, 22);
    bg_ctx.fillRect(375, 578, 50, 22);
    bg_ctx.fillRect(0, 275, 22, 50);
    bg_ctx.fillRect(778, 275, 22, 50);
  } else if (this.level_name == "HIVE 0-3") {
    bg_ctx.fillStyle = constants.colors["world " + this.world_num + " dark"]
    bg_ctx.fillRect(0, 0, 47, 600);
    bg_ctx.fillRect(753, 0, 47, 600);
  } else if (this.level_name == "HIVE 0-4") {
    bg_ctx.fillStyle = constants.colors["world " + this.world_num + " dark"]
    bg_ctx.fillRect(0, 0, 800, 47);
    bg_ctx.fillRect(0, 553, 800, 47);
  }

  if (this.is_level_zero) {
    bg_ctx.fillStyle = constants.colors["world " + this.level_intro_state.world_num + " bright"];
    bg_ctx.textAlign = "center";
    bg_ctx.font = "32px Open Sans";
    bg_ctx.fillText(levelData.hiveNames[this.level_intro_state.world_num], 400, 150);
    bg_ctx.font = "16px Open Sans";
    bg_ctx.fillText("8 LEVELS", 400, 170);
  }

  bg_ctx.restore()
}

Level.prototype.process_gateway_particles = function(dt) {
  for (var i = 0; i < this.gateway_particles.length; i++) {
    var particle = this.gateway_particles[i];
    particle.prop += dt / this.gateway_particle_duration;
  }
  for (var i = this.gateway_particles.length - 1; i >= 0; i--) {
    var particle = this.gateway_particles[i];
    if (particle.prop > 1) {
      this.gateway_particles.splice(i, 1);
    }
  }

  this.gateway_particle_gen_timer -= dt

  if (this.gateway_particle_gen_timer < 0) {
    this.gateway_particle_gen_timer += this.gateway_particle_gen_interval
    this.generate_gateway_particles(this.gateway_loc.x, this.gateway_loc.y, this.gateway_particles_per_round)
  }
}

Level.prototype.generate_gateway_particles = function(x, y, num_particles) {
  for (var i = 0; i < num_particles; i++) {
    var angle = Math.PI * 2 * i / num_particles + (Math.random() - 0.5) * Math.PI * 2 / num_particles
    this.gateway_particles.push({
      start_x: Math.cos(angle) * 1.5 * this.gateway_size + x,
      start_y: Math.sin(angle) * 1.4 * this.gateway_size + y,
      prop: 0
    });
  }
}

Level.prototype.draw_gateway_particles = function(ctx, draw_factor) {
  for(var i = 0; i < this.gateway_particles.length; i++) {
    var particle = this.gateway_particles[i];
    ctx.save()
    if (particle.prop < 0.25) {
      ctx.globalAlpha *= particle.prop * 4
    } else {
      var temp = (1 - particle.prop) / (0.75)
      ctx.globalAlpha *= temp
    }
    ctx.beginPath()
    ctx.rect(
      draw_factor * (particle.start_x * (1 - particle.prop) + this.gateway_loc.x * particle.prop) - 3,
      draw_factor * (particle.start_y * (1 - particle.prop) + this.gateway_loc.y * particle.prop) - 3,
      6,
      6)
    if (this.is_boss_level && this.boss && (this.boss.dying || this.boss.died)) {
      ctx.fillStyle = constants.colors["world 0 bright"];
    } else if (this.is_level_zero) {
      ctx.fillStyle = constants.colors["world " + this.level_intro_state.world_num + " bright"]
    } else {
      ctx.fillStyle = constants.colors["world " + this.world_num + " bright"]
    }
    ctx.fill()
    ctx.restore()
  }
}

Level.prototype.create_enemy_images = function(enemy) {

}

Level.prototype.clear_obstacles = function () {
  // Only really used for boss level.
  this.boundary_polygons = []; //the polygons that enemies use to calculate pathfinding
  this.obstacle_polygons = []; //the actual polygons that kill players and enemies
  this.obstacles = []
  this.obstacle_edges = []
  this.obstacle_vertices = []
}

Level.prototype.dispose = function() {
}

module.exports = Level;

},{"../core/layers.js":7,"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/enemy_data.js":15,"../data/level_data.js":16,"../enemy/enemy_factory.js":31,"../level/enemy_spawner.js":63,"../load/save_data.js":69,"../obstacle/basic_obstacle.js":71,"../render/fragment_group.js":76,"../render/object.js":79,"../render/ui.js":82,"../vendor/box2d.js":97}],65:[function(require,module,exports){
var constants = require('../data/constants.js');
var utils = require('../core/utils.js');

var VisibilityGraph = function(level, poly_edges, vertices, edges, edge_list, shortest_paths, visible_vertices ) {
  this.init(level, poly_edges, vertices, edges, edge_list, shortest_paths, visible_vertices)
}

VisibilityGraph.prototype.init = function(level, poly_edges, vertices, edges, edge_list, shortest_paths, visible_vertices) {
//buffer_polygons is an array of array of vertices
  this.level = level
  this.buffer_polygons = level.boundary_polygons
  this.obstacle_polygons = level.obstacle_polygons

  if(poly_edges) {
    this.poly_edges = poly_edges
    this.vertices = vertices
    this.edges = edges
    //edge_list stores the adjacencies from each vertex
    //edge_list uses the indices according to this.vertices
    this.edge_list = edge_list
    this.shortest_paths = shortest_paths
    this.visible_vertices = visible_vertices
  }
  this.last_time = (new Date()).getTime()
}

VisibilityGraph.prototype.is_valid_visible_vertice = function(point, vertex, polygonContainingPoint, passThroughPolygonContainingPoint) {
  if (passThroughPolygonContainingPoint) {
    return utils.isVisible(point, vertex, this.poly_edges, polygonContainingPoint/*ignore_polygon*/) && (vertex["p_n"] != polygonContainingPoint ||
         utils.isVisibleThroughPolygon(point, vertex, this.obstacle_polygons[vertex["p_n"]]))

  } else {
    if (polygonContainingPoint) {
      return (vertex["p_n"] == polygonContainingPoint &&
         utils.isVisibleThroughPolygon(point, vertex, this.obstacle_polygons[vertex["p_n"]]))
    } else {
      return utils.isVisible(point, vertex, this.poly_edges)
    }
  }
}

VisibilityGraph.prototype.query = function(point1, point2, pick_alt_path)
//start point, end point, whether to try to pick a different path so enemies don't all go to the same place
//returns the shortest path from point1 to VISIBILITY_GRAPH to point2
{

  //if it is possible to go from current location to player, always go there directly
  if(utils.isVisible(point1, point2, this.poly_edges) && utils.isVisible(point1, point2, this.level.obstacle_edges))//if visible, go there directly
  {
    return {path: [point2], dist: utils.pDist(point1, point2)}
  }

  // Detect whether point1 or point2 is inside a boundary polygon.
  // If so, make sure points on that boundary polygon are utils.isVisible through the obstacle polygon before considering.
  // This is necessary because we use obstacle polygon for most of our calculations.
  var point1polygon = null;
  var point2polygon = null;
  for(var i = 0; i < this.buffer_polygons.length; i++) {
    if (utils.pointInPolygon(this.buffer_polygons[i], point1)) {
      point1polygon = i;
    }
    if (utils.pointInPolygon(this.buffer_polygons[i], point2)) {
      point2polygon = i;
    }
  }

  var min_distance = null
  var min_path = null
  var split_size = 50
  var point1_adj = this.visible_vertices[Math.floor(point1.x*constants.drawFactor/split_size)*split_size+" "+Math.floor(point1.y*constants.drawFactor/split_size)*split_size]
  var point2_adj = this.visible_vertices[Math.floor(point2.x*constants.drawFactor/split_size)*split_size+" "+Math.floor(point2.y*constants.drawFactor/split_size)*split_size]

  var inPoly = false

  if(point1_adj) {
    var actual_point1_adj = []
    for(var i = 0; i < point1_adj.length; i++)
    {
      if(this.is_valid_visible_vertice(point1, this.vertices[point1_adj[i]], point1polygon, true /* passThroughPolygonContainingPoint*/))
      {
        actual_point1_adj.push(point1_adj[i])
      }
    }
    point1_adj = actual_point1_adj
  }

  if(!point1_adj || point1_adj.length == 0) {
    point1_adj = []
    for(var i = 0; i < this.vertices.length; i++)
    {
      if(this.is_valid_visible_vertice(point1, this.vertices[i], point1polygon, true))
      {
        point1_adj.push(i)
      }
    }
  }

  if(point2_adj) {
    var actual_point2_adj = []
    for(var i = 0; i < point2_adj.length; i++)
    {
      if(this.is_valid_visible_vertice(point2, this.vertices[point2_adj[i]], point2polygon, true))
      {
        actual_point2_adj.push(point2_adj[i])
      }
    }
    point2_adj = actual_point2_adj
  }

  if(!point2_adj || point2_adj.length == 0) {
    point2_adj = []
    for(var i = 0; i < this.vertices.length; i++)
    {
      if(this.is_valid_visible_vertice(point2, this.vertices[i], point2polygon, true))
      {
        point2_adj.push(i)
      }
    }
  }

  for(var i = 0; i < point1_adj.length; i++)
  {
    for(var j = 0; j < point2_adj.length; j++)
    {
      var v_dist;
      if(point1_adj[i] == point2_adj[j])//same point
      {
        v_dist = 0
      }
      else
      {
        v_dist = this.shortest_paths[point1_adj[i]][point2_adj[j]]["b"] // dist
      }
      if(v_dist == null) continue
      var dist = utils.pDist(point1, this.vertices[point1_adj[i]]) + v_dist
        + utils.pDist(this.vertices[point2_adj[j]], point2);
      if(!min_distance || dist < min_distance)
      {
        min_distance = dist
        if(point1_adj[i] == point2_adj[j])
        {
          min_path = [point1_adj[i]]
        }
        else
        {
          min_path = this.shortest_paths[point1_adj[i]][point2_adj[j]]["a"] // path
        }
      }
    }
  }
  if(!min_path) {
    return {path: null, dist: null}//it's possible that player is inside an open-space that is surrouded by triangle edges.
  }
  if(pick_alt_path) {
    var random_path_index = Math.floor(Math.random() * point1_adj.length * point2_adj.length)

    var i = Math.floor(random_path_index / point2_adj.length)
    var j = random_path_index % point2_adj.length


    if(utils.pDist(point1, this.vertices[min_path[0]] < 5)) {
      i = point1_adj.indexOf(min_path[0])
    }

    var v_dist;
    if(point1_adj.length * point2_adj.length != 0) {
      if(point1_adj[i] == point2_adj[j])//same point
      {
        v_dist = 0
      }
      else
      {
        v_dist = this.shortest_paths[point1_adj[i]][point2_adj[j]]["b"] // dist
      }
      if(v_dist != null) {
        var dist = utils.pDist(point1, this.vertices[point1_adj[i]]) + v_dist
        + utils.pDist(this.vertices[point2_adj[j]], point2);
        var orig_angle = utils.atan(point1, this.vertices[min_path[0]])
        var new_angle = utils.atan(point1, this.vertices[point1_adj[i]])

        // Choose an alternate path.
        // The path cannot be much worse.
        // The path cannot lead in the other direction.
        // The path must lead into another corridor.

        if(dist < 1.2 * min_distance && utils.smallAngleBetween(orig_angle, new_angle) < Math.PI*3/8 &&
          !utils.isVisible(this.vertices[min_path[0]], this.vertices[point1_adj[i]]))
        {
          min_distance = dist
          if(point1_adj[i] == point2_adj[j])
          {
            min_path = [point1_adj[i]]
          }
          else
          {
            min_path = this.shortest_paths[point1_adj[i]][point2_adj[j]]["a"] // path
          }
        }
      }
    }
  }

  //thus, no visible vertices
  //this is only if the player "tunnels" (cheats)
  var ans = []

  for (var i = 0; i < min_path.length; i++)
  {
    ans.push(this.vertices[min_path[i]])
  }
  ans.push(point2)

  // covers some edge cases. For example, if the player is inside a boundary polygon, this will prevent enemy from going through a boundary polygon vertex first.
  if (ans.length == 2 && utils.isVisible(point1, point2, this.level.obstacle_edges)) {
    return {path: [point2], dist: utils.pDist(point1, point2)}
  }

  return {path: ans, dist: min_distance}
}

module.exports = VisibilityGraph;

},{"../core/utils.js":11,"../data/constants.js":13}],66:[function(require,module,exports){
var levelData = require('../data/level_data.js');
var questData = require('../data/quest_data.js');

var HiveNumbers = function (world_num, main_game) {
  if(world_num === undefined)return

  this.hit = false;
  this.main_game = main_game
  if (world_num > 0) {
    this.speed_run_countdown = questData["blitz_hive" + world_num].time_cutoff * 1000// in ms
  }

  this.total_time = {};

  this.current_level = null

  this.game_numbers = {}
  this.world = world_num
  if (this.world == 0) {
    this.hive_name = "TUTORIAL"
  } else {
    this.hive_name = levelData.hiveNames[world_num]
  }

  this.boss_name = levelData.bossNames[world_num];
}

HiveNumbers.loadFromSaveObj = function (saveObj) {
  var hiveNumbers = new HiveNumbers();
  if (!saveObj) {
    return;
  }

  // Previously, saved games for easy and normal were saved separately.
  if (saveObj['easy'] && saveObj['easy']['current_level']) {
    saveObj = saveObj['easy'];
  } else if (saveObj['normal'] && saveObj['normal']['current_level']) {
    saveObj = saveObj['normal'];
  }
  hiveNumbers.hit = saveObj['hit'];
  hiveNumbers.main_game = saveObj['main_game'];
  hiveNumbers.speed_run_countdown = saveObj['speed_run_countdown'];
  hiveNumbers.total_time = saveObj['total_time'];
  hiveNumbers.current_level = saveObj['current_level'];
  hiveNumbers.game_numbers = saveObj['game_numbers'];
  hiveNumbers.world = saveObj['world'] || 1;
  hiveNumbers.hive_name = saveObj['hive_name'];
  hiveNumbers.boss_name = saveObj['boss_name'];

  return hiveNumbers;
};

HiveNumbers.prototype.createSaveObj = function () {
  return {
    'hit': this.hit,
    'main_game': this.main_game,
    'speed_run_countdown': this.speed_run_countdown,
    'total_time': this.total_time,
    'current_level': this.current_level,
    'game_numbers': this.game_numbers,
    'hive_name': this.hive_name,
    'boss_name': this.boss_name,
    'world': this.world
  };
};

module.exports = HiveNumbers;

},{"../data/level_data.js":16,"../data/quest_data.js":17}],67:[function(require,module,exports){
var levelData = require('../data/level_data.js');

var LevelSaveData = function () {
  this.data = {};
};

LevelSaveData.prototype.loadDataFromVersion0 = function (load_obj) {
  for (var level in load_obj['levels']) {
    for (var difficulty in load_obj['levels'][level]['save_state']) {
      if (load_obj['levels'][level]['save_state'][difficulty]['seen'] &&
          levelData.levels[level] &&
          !levelData.levels[level].no_save) {
        this.saveLevel(
          level,
          load_obj['levels'][level]['save_state'][difficulty]['best_time'],
          difficulty);
      }
    }
  }
};

LevelSaveData.prototype.saveLevel = function (level_name, best_time, difficulty_mode) {
  var keyName = difficulty_mode + ' ' + level_name;
  if (!this.data[keyName]) {
    this.data[keyName] = {};
  }
  this.data[keyName]['best_time'] = best_time;
}

LevelSaveData.prototype.loadData = function (load_obj) {
  this.data = load_obj['level_data'];
};

LevelSaveData.prototype.addLevelDataToSaveObj = function (save_obj) {
  save_obj['level_data'] = this.data;
};

LevelSaveData.prototype.getLevelData = function (level_name, difficulty_mode) {
  var keyName = difficulty_mode + ' ' + level_name;
  return this.data[keyName];
};

LevelSaveData.prototype.hasBeatenLevel = function (level_name, difficulty_mode) {
  var keyName = difficulty_mode + ' ' + level_name;
  return this.data[keyName] !== undefined;
};

LevelSaveData.prototype.getBestTimeForLevel = function(level_name, difficulty_mode) {
  if (!this.hasBeatenLevel(level_name, difficulty_mode)) {
    return false;
  }
  return this.getLevelData(level_name, difficulty_mode).best_time;
};

LevelSaveData.prototype.setBestTimeForLevel = function(level_name, best_time, difficulty_mode) {
  this.saveLevel(level_name, best_time, difficulty_mode);
};

module.exports = LevelSaveData;

},{"../data/level_data.js":16}],68:[function(require,module,exports){
// These need to be explicitly named because the values can change across minifications.
var defaultOptions = {
  'effects_mute': false,
  'bg_music_mute': false,
  'effects_volume': 100,
  'bg_music_volume': 100,
  'explosions': true,
  'score_labels': true,
  'progress_circle': false,
  'multiplier_display': false,
  'impulse_shadow': true,
  'speed_run_countdown': false,
  'control_hand': 'right',
  'control_scheme': 'mouse',
};

var OptionsData = function () {
  this.effects_volume = 100;
  this.effects_mute = false;
  this.bg_music_volume = 100;
  this.bg_music_mute = false;
  this.explosions = true;
  this.score_labels = true;
  this.progress_circle = false;
  this.multiplier_display = false;
  this.impulse_shadow = true;
  this.speed_run_countdown = false;
  this.control_hand = 'right';
  this.control_scheme = 'mouse';
};

OptionsData.prototype.loadOptionsFromObj = function (saveObj) {

  if (!saveObj) {
    saveObj = {};
  }

  if (this.isValidOptionValue(saveObj, 'effects_volume')) {
    this.effects_volume = saveObj['effects_volume'];
  }
  if (this.isValidOptionValue(saveObj, 'effects_mute')) {
    this.effects_mute = saveObj['effects_mute'];
  }
  if (this.isValidOptionValue(saveObj, 'bg_music_volume')) {
    this.bg_music_volume = saveObj['bg_music_volume'];
  }
  if (this.isValidOptionValue(saveObj, 'bg_music_mute')) {
    this.bg_music_mute = saveObj['bg_music_mute'];
  }
  if (this.isValidOptionValue(saveObj, 'explosions')) {
    this.explosions = saveObj['explosions'];
  }
  if (this.isValidOptionValue(saveObj, 'score_labels')) {
    this.score_labels = saveObj['score_labels'];
  }
  if (this.isValidOptionValue(saveObj, 'progress_circle')) {
    this.progress_circle = saveObj['progress_circle'];
  }
  if (this.isValidOptionValue(saveObj, 'multiplier_display')) {
    this.multiplier_display = saveObj['multiplier_display'];
  }
  if (this.isValidOptionValue(saveObj, 'impulse_shadow')) {
    this.impulse_shadow = saveObj['impulse_shadow'];
  }
  if (this.isValidOptionValue(saveObj, 'speed_run_countdown')) {
    this.speed_run_countdown = saveObj['speed_run_countdown'];
  }
  if (this.isValidOptionValue(saveObj, 'control_hand')) {
    this.control_hand = saveObj['control_hand'];
  }
  if (this.isValidOptionValue(saveObj, 'control_scheme')) {
    this.control_scheme = saveObj['control_scheme'];
  }
}

OptionsData.prototype.createSaveObj = function () {
  return {
    'effects_volume': this.effects_volume,
    'effects_mute': this.effects_mute,
    'bg_music_volume': this.bg_music_volume,
    'bg_music_mute': this.bg_music_mute,
    'explosions': this.explosions,
    'score_labels': this.score_labels,
    'progress_circle': this.progress_circle,
    'multiplier_display': this.multiplier_display,
    'impulse_shadow': this.impulse_shadow,
    'speed_run_countdown': this.speed_run_countdown,
    'control_hand': this.control_hand,
    'control_scheme': this.control_scheme
  };
}

OptionsData.prototype.isValidOptionValue = function (obj, optionName) {
  var optionValue = obj[optionName];
  if (optionValue === undefined) {
    return false;
  }
  if (['bg_music_volume', 'effects_volume'].indexOf(optionName) !== -1) {
    return typeof optionValue === 'number';
  } else if (['explosions', 'score_labels', 'progress_circle', 'multiplier_display',
    'impulse_shadow', 'speed_run_countdown', 'effects_mute', 'bg_music_mute'].indexOf(optionName) !== -1) {
    return typeof optionValue === 'boolean'
  } else if (optionName === 'control_hand') {
    return ['right', 'left'].indexOf(optionValue) !== -1;
  } else if (optionName === 'control_scheme') {
    return ['mouse', 'keyboard'].indexOf(optionValue) !== -1;
  } else {
    return false;
  }
}

module.exports = OptionsData;

},{}],69:[function(require,module,exports){
var logging = require('../core/logging.js');
var _ = require('lodash');

var HiveNumbers = require('../load/hive_numbers.js');
var LevelSaveData = require('../load/level_save_data.js');
var WorldSaveData = require('../load/world_save_data.js');
var OptionsData = require('../load/options_data.js');

var LOCAL_STORAGE_BUCKET_NAME = "impulse_save_data"

var SaveData = function() {
  this.resetData();
};

SaveData.prototype.version = "1.0.0";

SaveData.prototype.resetData = function () {
  this.difficultyMode = "easy";
  this.firstTime = true; // Used to change the player's experience the first time.
  this.levelData = new LevelSaveData();
  this.worldData = new WorldSaveData();
  this.enemiesSeen = [];
  this.tutorialsShown = [];
  this.optionsData = new OptionsData();
  this.quests = [];
  this.savedGame = null;
};

SaveData.prototype.versionIsLessThan = function (versionOne, versionTwo) {
  if (!versionOne) {
    return true;
  }

  var getVersionParts = function (versionString) {
    return _.map(versionString.split("."), function (token) {
      return parseInt(token);
    });
  };

  var verOne = getVersionParts(versionOne);
  var verTwo = getVersionParts(versionTwo);
  return (verOne[0] < verTwo[0]) ||
    (verOne[0] == verTwo[0] && verOne[1] < verTwo[1]) ||
    (verOne[0] == verTwo[0] && verOne[1] == verTwo[1] && verOne[2] < verTwo[2]);
};

SaveData.prototype.loadObjIsOldVersion = function (loadObj) {
  if (!loadObj['saveVersion']) {
    return true;
  }
  var loadObjVersion = loadObj['saveVersion'];
  return this.versionIsLessThan(loadObjVersion, this.version);
};

// Want to preserve player's progress
SaveData.prototype.loadFromOldVersion = function (loadObj) {
  var loadObjVersion = loadObj['saveVersion'];
  if (this.versionIsLessThan(loadObjVersion, '1.0.0')) {
    // Enemies seen used to be an object with times we've seen the enemy. Now it's an array.
    for (var enemy in loadObj['enemies_seen']) {
      this.enemiesSeen.push(enemy);
    }
    this.worldData.loadDataFromVersion0(loadObj);
    this.levelData.loadDataFromVersion0(loadObj);
  }
}

SaveData.prototype.loadGame = function() {
  var loadObj = localStorage[LOCAL_STORAGE_BUCKET_NAME];

  if (!loadObj) {
    logging.send_logging_to_server('STARTED GAME', {});
    return;
  } else {
    loadObj = JSON.parse(loadObj);
  }

  this.firstTime = loadObj['first_time'];

  // Take care of legacy formats.
  if (this.loadObjIsOldVersion(loadObj)) {
    this.loadFromOldVersion(loadObj);
    return;
  }

  if (loadObj['save_data']) {
    this.savedGame = HiveNumbers.loadFromSaveObj(loadObj['save_data']);
  }

  if (loadObj['difficulty_mode']) {
    this.difficultyMode = loadObj['difficulty_mode'];
  }

  if (loadObj['tutorial_shown']) {
    this.tutorialsShown = loadObj['tutorial_shown'];
  }

  this.optionsData.loadOptionsFromObj(loadObj['options']);

  if (loadObj['quests']) {
    this.quests = loadObj['quests'];
  }

  this.levelData.loadData(loadObj);
  this.worldData.loadData(loadObj);

  if (loadObj['enemies_seen']) {
    this.enemiesSeen = loadObj['enemies_seen'];
  }
};

SaveData.prototype.saveGame = function() {
  var saveObj = {}
  saveObj['saveVersion'] = this.version;
  this.levelData.addLevelDataToSaveObj(saveObj);
  this.worldData.addWorldDataToSaveObj(saveObj);
  saveObj['enemies_seen'] = this.enemiesSeen;

  saveObj['difficulty_mode'] = this.difficultyMode;
  if (this.savedGame) {
    saveObj['save_data'] = this.savedGame.createSaveObj();
  }
  saveObj['options'] = this.optionsData.createSaveObj();

  saveObj['first_time'] = this.firstTime;
  saveObj['tutorial_shown'] = this.tutorialsShown;
  saveObj['quests'] = this.quests;
  localStorage[LOCAL_STORAGE_BUCKET_NAME] = JSON.stringify(saveObj)
};

SaveData.prototype.clearData = function () {
  localStorage.removeItem(LOCAL_STORAGE_BUCKET_NAME);
  var oldPlayerOptions = this.optionsData;
  var oldTutorialShown = this.tutorialsShown;
  this.resetData();
  this.loadGame();
  this.optionsData = oldPlayerOptions
  this.tutorialsShown = oldTutorialShown;
  this.firstTime = false
  this.saveGame();
};

SaveData.prototype.savePlayerGame = function(hive_number) {
  this.savedGame = hive_number;
  this.saveGame();
};

SaveData.prototype.hasBeatenLevel = function(level_name) {
  return this.levelData.hasBeatenLevel(level_name, this.difficultyMode);
}

SaveData.prototype.getBestTimeForLevel = function(level_name) {
  return this.levelData.getBestTimeForLevel(level_name, this.difficultyMode);
}

SaveData.prototype.setBestTimeForLevel = function(level_name, best_time) {
  this.levelData.setBestTimeForLevel(level_name, best_time, this.difficultyMode);
}

SaveData.prototype.hasBeatenWorld = function(i) {
  return this.worldData.hasBeatenWorld('world ' + i, this.difficultyMode);
}

SaveData.prototype.hasBeatenWorldForDifficulty = function(i, difficulty) {
  return this.worldData.hasBeatenWorld('world ' + i, difficulty);
}

SaveData.prototype.latestWorld = function() {
  var i = 1;
  while(i < 4 && this.hasBeatenWorld(i)) {
    i += 1
  }
  return i;
}

SaveData.prototype.getBestTimeForWorld = function(i) {
  return this.worldData.getBestTimeForWorld('world ' + i, this.difficultyMode);
}

SaveData.prototype.setBestTimeForWorld = function(i, best_time) {
  this.worldData.setBestTimeForWorld('world ' + i, best_time, this.difficultyMode);
}

SaveData.prototype.isHardModeUnlocked = function () {
  return this.hasBeatenWorldForDifficulty(4, 'easy');
}

SaveData.prototype.clearSavedPlayerGame = function() {
  this.savedGame = null;
  this.saveGame();
};

SaveData.prototype.isQuestCompleted = function (name) {
  return this.quests.indexOf(name) != -1
}

SaveData.prototype.setQuestCompleted = function(name) {
  if (!this.isQuestCompleted(name)) {
    this.quests.push(name);
    this.saveGame();
  }
}

SaveData.prototype.shouldShowLevelZero = function (world_num) {
  // Easy difficulty, and we've never played this world before.
  return this.difficultyMode == "easy" && this.hasBeatenLevel("HIVE " + world_num + "-1");
};

module.exports = new SaveData();

},{"../core/logging.js":8,"../load/hive_numbers.js":66,"../load/level_save_data.js":67,"../load/options_data.js":68,"../load/world_save_data.js":70,"lodash":99}],70:[function(require,module,exports){
var WorldSaveData = function () {
  this.data = {};
};

WorldSaveData.prototype.loadDataFromVersion0 = function (load_obj) {
  for (var difficulty in load_obj['world_rankings']) {
    for (var world in load_obj['world_rankings'][difficulty]) {
      this.saveWorld(world, 10000, difficulty);
    }
  }
};

WorldSaveData.prototype.saveWorld = function (world_name, best_time, difficulty_mode) {
  var keyName = difficulty_mode + ' ' + world_name;
  if (!this.data[keyName]) {
    this.data[keyName] = {};
  }
  this.data[keyName]['best_time'] = best_time;
}

WorldSaveData.prototype.loadData = function (load_obj) {
  this.data = load_obj['world_data'];
};

WorldSaveData.prototype.hasBeatenWorld = function (world_name, difficulty_mode) {
  var keyName = difficulty_mode + ' ' + world_name;
  return this.data[keyName] !== undefined;
}

WorldSaveData.prototype.getWorldData = function (world_name, difficulty_mode) {
  var keyName = difficulty_mode + ' ' + world_name;
  return this.data[keyName];
};

WorldSaveData.prototype.addWorldDataToSaveObj = function (save_obj) {
  save_obj['world_data'] = this.data;
};

WorldSaveData.prototype.getBestTimeForWorld = function(world_name, difficulty_mode) {
  if (!this.hasBeatenWorld(world_name, difficulty_mode)) {
    return false;
  }
  return this.getWorldData(world_name, difficulty_mode).best_time;
};

WorldSaveData.prototype.setBestTimeForWorld = function(world_name, best_time, difficulty_mode) {
  this.saveWorld(world_name, best_time, difficulty_mode);
};

module.exports = WorldSaveData;

},{}],71:[function(require,module,exports){
var BasicObstacle = function(vertices, color, darkColor) {
  this.init(vertices, color, darkColor)
}

BasicObstacle.prototype.init = function(verticeSet, color, darkColor) {

  this.verticeSet = verticeSet
  this.color = color
  this.darkColor = darkColor
}

BasicObstacle.prototype.process = function() {

}

BasicObstacle.prototype.draw = function(context, draw_factor) {

  context.save();
  context.beginPath()

  context.moveTo(this.verticeSet[0].x*draw_factor, this.verticeSet[0].y*draw_factor)
  for(var i = 1; i < this.verticeSet.length; i++)
  {
    context.lineTo(this.verticeSet[i].x*draw_factor, this.verticeSet[i].y*draw_factor)
  }
  context.closePath()
  context.clip();
  context.fillStyle = this.darkColor;
  context.strokeStyle = this.color
  context.lineWidth = 6
  context.fill();
  context.stroke()
  context.restore();
  context.save();
  // The last clip doesn't seem to obey the parent clipping region.
  // This appears to be a bug.
  context.beginPath();
  context.clip();
  context.restore();
}

module.exports = BasicObstacle;

},{}],72:[function(require,module,exports){
//currently 15 by 15px
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var controls = require('../core/controls.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var Player = function(world, x, y, impulse_game_state) {
  this.init(world, x, y, impulse_game_state)
}

Player.prototype.lin_damp = 3.5//old = 3

Player.prototype.id = 9999

Player.prototype.true_force = 1.2//old = .5

Player.prototype.impulse_force = 50

Player.prototype.impulse_radius = 10

Player.prototype.impulse_width = 1/32

Player.prototype.impulse_target_color = constants.colors["impulse_target_blue"]
Player.prototype.impulse_color = constants.colors["impulse_blue"]

Player.prototype.density = 9/16

Player.prototype.radius = .66
Player.prototype.effective_radius = .66

Player.prototype.init = function(world, x, y, impulse_game_state) {
  if (world == null) return

  if(saveData.difficultyMode == "easy") {
    this.density *= 1.5;
    this.true_force *= 1.5;
  }
  var fixDef = new box_2d.b2FixtureDef;
  fixDef.density = this.density;
  fixDef.friction = 0;
  fixDef.restitution = 1.0;
  fixDef.filter.categoryBits = box_2d.PLAYER_BIT
  fixDef.filter.maskBits = box_2d.ENEMY_BIT | box_2d.WALL_BIT | box_2d.BOSS_BITS
  var bodyDef = new box_2d.b2BodyDef;
  bodyDef.type = box_2d.b2Body.b2_dynamicBody;
  fixDef.shape = new box_2d.b2CircleShape(Player.prototype.radius);
  this.r = Player.prototype.radius;
  this.level = impulse_game_state.level
  this.impulse_game_state = impulse_game_state
  bodyDef.position.x = x;
  bodyDef.position.y = y;
  bodyDef.linearDamping = this.lin_damp
  this.body = world.CreateBody(bodyDef)
  this.body.CreateFixture(fixDef).SetUserData({"owner": this, "body": this.body, "self": this});
  this.shape = fixDef.shape


  this.points_polar_form = []
  for(var i = 0; i < 4; i++) {
    this.points_polar_form.push({r: .5, ang: i * Math.PI/2})
  }

  this.left = false
  this.right = false
  this.down = false
  this.up = false
  this.ileft = null
  this.iright = null
  this.idown = null
  this.iup = null
  this.impulse_angle = 0

  this.has_lightened_properties = false

  this.enemies_hit = [] //stores ids of enemies hit

  this.attacking = false
  this.attack_start = 0
  this.attack_loc = {}
  this.attack_angle = 0
  this.attack_length = 500
  this.attack_duration = 0

  // used for status timers
  this.confuse_duration = 0
  this.confuse_interval = 0
  this.silence_duration = 0
  this.silence_interval = 0

  this.gooed_damping_factor = 5;
  this.gooed_force_boost = 1.7;

  this.mouse_pos = {x: 0, y: 0}//keeps track of last mouse position on player's part
  this.status = "normal"  //currently unused
  this.status_duration = [0, 0, 0, 0, 0, 0] //[locked, silenced, gooed, lighten, confuse, bulk], time left for each status

  this.slow_factor = .3
  this.dying = false
  this.dying_length = 1000
  this.dying_duration = 0
  this.color = constants.colors["player_color"]
  this.force = this.true_force
  this.bulk_factor = 5
  this.bulked = false

  this.lighten_factor = 1.5

  this.last_mouse_down = 0
  this.mouse_pressed = false
  this.last_right_mouse_down = 0
  this.right_mouse_pressed = false

  // When the player first appears.
  this.appear_duration = 250;
  this.appearing = true;
  this.appear_timer = this.appear_duration;
}

Player.prototype.keyDown = function(keyCode) {
  switch(keyCode)
  {
    case controls.keys.LEFT_KEY:
      this.left = true
      break;
    case controls.keys.RIGHT_KEY:
      this.right = true
      break;
    case controls.keys.DOWN_KEY:
      this.down = true
      break;
    case controls.keys.UP_KEY:
      this.up = true
      break;
    case controls.keys.PAUSE:
    case controls.keys.SECONDARY_PAUSE:
      this.up = false
      this.down = false
      this.left = false
      this.right = false
      this.ileft = null
      this.iright = null
      this.iup = null
      this.idown = null
      break
    case controls.keys.ILEFT_KEY:
      this.ileft = (new Date()).getTime()
      break;
    case controls.keys.IUP_KEY:
      this.iup = (new Date()).getTime()
      break;
    case controls.keys.IRIGHT_KEY:
      this.iright = (new Date()).getTime()
      break;
    case controls.keys.IDOWN_KEY:
      this.idown = (new Date()).getTime()
      break;
  }
}

Player.prototype.keyUp = function(keyCode) {
  switch(keyCode)
  {
    case controls.keys.LEFT_KEY:
      this.left = false
      break;
    case controls.keys.RIGHT_KEY:
      this.right = false
      break;
    case controls.keys.DOWN_KEY:
      this.down = false
      break;
    case controls.keys.UP_KEY:
      this.up = false
      break;
    case controls.keys.ILEFT_KEY:
      this.ileft = null
      break;
    case controls.keys.IUP_KEY:
      this.iup = null
      break;
    case controls.keys.IRIGHT_KEY:
      this.iright = null
      break;
    case controls.keys.IDOWN_KEY:
      this.idown = null
      break;
    case controls.keys.PAUSE:
    case controls.keys.SECONDARY_PAUSE:
      this.up = false
      this.down = false
      this.left = false
      this.right = false
      this.ileft = null
      this.iright = null
      this.iup = null
      this.idown = null
      break
  }
}

Player.prototype.mouseMove = function(pos) {
  this.mouse_pos = pos
}

Player.prototype.stun = function(dur) {
  this.status_duration[0] = Math.max(dur, this.status_duration[0]) //so that a short stun does not shorten a long stun
  this.status_duration[1] = Math.max(dur, this.status_duration[1])
}

Player.prototype.silence = function(dur, single_silence) {
  if (single_silence) {
    this.silence_duration = Math.max(dur, this.status_duration[1])
    this.silence_interval = Math.max(dur, this.status_duration[1])
  }
  this.status_duration[1] = Math.max(dur, this.status_duration[1])
}

Player.prototype.lock = function(dur) {
  this.status_duration[0] = Math.max(dur, this.status_duration[0])
}

Player.prototype.goo = function(dur) {
  this.status_duration[2] = Math.max(dur, this.status_duration[2])
}

Player.prototype.lighten = function(dur) {
  this.status_duration[3] = Math.max(dur, this.status_duration[3])
  this.last_lighten = this.status_duration[3]
  this.lighten_start = 1
  this.lighten_finish = 1/this.lighten_factor
}

Player.prototype.bulk = function(dur) {
  this.status_duration[5] = Math.max(dur, this.status_duration[5])
}

Player.prototype.confuse= function(dur) {
  this.confuse_duration = Math.max(dur, this.status_duration[4])
  this.confuse_interval = Math.max(dur, this.status_duration[4])
  this.status_duration[4] = Math.max(dur, this.status_duration[4])
}

Player.prototype.is_locked = function() {
  return this.status_duration[0] > 0;
};

Player.prototype.is_silenced = function() {
  return this.status_duration[1] > 0;
}

Player.prototype.is_gooed = function() {
  return this.status_duration[2] > 0;
}

Player.prototype.is_lightened = function() {
  return this.status_duration[3] > 0;
}

Player.prototype.is_confused = function() {
  return this.status_duration[4] > 0;
}

Player.prototype.is_bulked = function() {
  return this.status_duration[5] > 0;
}

Player.prototype.mouse_down= function(pos) {
  this.last_mouse_down = (new Date()).getTime()
  this.mouse_pressed = true
}

Player.prototype.mouse_up= function(pos) {
  this.mouse_pressed = false
}

Player.prototype.right_mouse_down= function(pos) {
  this.last_right_mouse_down = (new Date()).getTime()
  this.right_mouse_pressed = true
}

Player.prototype.right_mouse_up= function(pos) {
  this.right_mouse_pressed = false
}

Player.prototype.process = function(dt) {
  if(this.dying )
  {
    this.dying_duration -= dt
    return
  }

  if (this.appearing) {
    this.appear_timer -= dt;
    if (this.appear_timer < 0) {
      this.appearing = false;
    }
  }

  if (this.silence_duration > 0) {
    this.silence_duration -= dt
  }
  if (this.confuse_duration > 0) {
    this.confuse_duration -= dt
  }

  if(this.status_duration[0] > 0) {
    this.status_duration[0] -= dt
  }
  if(this.status_duration[1] > 0) {
    this.status_duration[1] -= dt
  }
  if(this.status_duration[2] > 0) {
    this.status_duration[2] -= dt
    this.body.SetLinearDamping(this.lin_damp * this.gooed_damping_factor)
    this.gooed = true
  } else if(this.gooed){
    this.body.SetLinearDamping(this.lin_damp)
  }
  if (this.status_duration[3] > 0){
    this.status_duration[3] -= dt
    if(!this.has_lightened_properties) {
      this.has_lightened_properties = true
      var fixtures = this.body.GetFixtureList()
      if (fixtures.length === undefined) {
        fixtures = [fixtures]
      }
      for(var i = 0; i < fixtures.length; i++) {
        fixtures[i].m_shape.m_radius /= this.lighten_factor
        //fixtures[i].SetDensity(this.density/3)
      }
      this.body.ResetMassData()
      this.readjust_force()
    }
  }
  else {
    if(this.has_lightened_properties) {
      this.has_lightened_properties = false
      var fixtures = this.body.GetFixtureList()
      if (fixtures.length === undefined) {
        fixtures = [fixtures]
      }
      for(var i = 0; i < fixtures.length; i++) {
        fixtures[i].m_shape.m_radius *= this.lighten_factor
        //fixtures[i].SetDensity(this.density)
      }
      this.body.ResetMassData()
      this.readjust_force()
    }
  }

  if(this.status_duration[4] > 0) {
    this.status_duration[4] -= dt
  }

  if (this.status_duration[5] > 0) {
    this.status_duration[5] -= dt;
  }

  if(this.status_duration[5] > 0 && !this.bulked) {
    var fixtures = this.body.GetFixtureList()
    if (fixtures.length === undefined) {
      fixtures = [fixtures]
    }
    for(var i = 0; i < fixtures.length; i++) {

      fixtures[i].SetDensity(this.density*this.bulk_factor)
    }
    this.readjust_force()
    this.body.ResetMassData()
    this.bulked = true
  } else if(this.status_duration[5] <= 0 && this.bulked){
    this.bulked = false
    var fixtures = this.body.GetFixtureList()
    if (fixtures.length === undefined) {
      fixtures = [fixtures]
    }
    for(var i = 0; i < fixtures.length; i++) {
      fixtures[i].SetDensity(this.density)
    }
    this.readjust_force()
    this.body.ResetMassData()
  }

  cur_time = (new Date()).getTime()

  this.maybe_start_impulse();

  this.body.SetAngle(this.impulse_angle)

  if (this.is_confused()) {
    this.impulse_angle += Math.PI
  }
  for(var k = 0; k < this.level.obstacle_polygons.length; k++)
  {
    if(utils.pointInPolygon(this.level.obstacle_polygons[k], this.body.GetPosition()))
    {
      this.start_death()
      break
    }
  }

  if(this.attacking)
  {

    if(this.attack_duration < 0)//attack lasts 500 ms
    {
      this.attacking = false
      this.enemies_hit = []
    }
    else
    {
      for(var i = 0; i < this.level.enemies.length; i++)
      {
        if(this.level.enemies[i].type === "mote" && !this.level.enemies[i].is_silenced()) continue

        if(this.level.enemies[i].type === "slingshot" && this.level.enemies[i].empowered) continue

        if(this.enemies_hit.indexOf(this.level.enemies[i].id)==-1 && !this.level.enemies[i].dying)//enemy has not been hit
        {
          var impulse_sensitive_points = this.level.enemies[i].get_impulse_sensitive_pts()

          for(var j = 0; j < impulse_sensitive_points.length; j++) {

            if(this.point_in_impulse_angle(impulse_sensitive_points[j]))
            {

              if (this.point_in_impulse_dist(impulse_sensitive_points[j], this.level.enemies[i].body.GetLinearVelocity().Length() > 20))
              {
                var angle = utils.atan(this.attack_loc, impulse_sensitive_points[j])//not sure if it should be this point
                this.enemies_hit.push(this.level.enemies[i].id)
                var force = this.impulse_force;
                // If it's a goo-ed Harpoon.
                if(this.level.enemies[i].type === "harpoon"  && this.level.enemies[i].is_gooed()) {
                  force *= 2;
                }
                if(this.level.enemies[i].type === "fighter" && this.level.enemies[i].is_disabled()) {
                  force *= 3;
                }
                if(this.level.enemies[i].is_lightened()) {
                  force *= 2.5;
                }
                this.level.enemies[i].process_impulse(this.attack_loc, force, angle)
                break
              }
              if(this.level.enemies[i].type === "harpoon" && this.level.enemies[i].harpoon_state == "engaged") {
                this.level.enemies[i].disengage_harpoon()
              }
            }
          }
        }

        // if Harpoon, also check the Head
        if(this.level.enemies[i].type === "harpoon" && this.level.enemies[i].harpoon_state != "inactive") {
          var this_harpoon_head = this.level.enemies[i].harpoon_head;
          if (this.enemies_hit.indexOf(this_harpoon_head.id) == -1) {
            var impulse_sensitive_points = this_harpoon_head.get_impulse_sensitive_pts()

            for(var j = 0; j < impulse_sensitive_points.length; j++) {

              if(this.point_in_impulse_angle(impulse_sensitive_points[j]))
              {
                if (this.point_in_impulse_dist(impulse_sensitive_points[j], true))
                {
                  var angle = utils.atan(this.attack_loc, impulse_sensitive_points[j])//not sure if it should be this point
                  // Impulse the harpoon head.
                  this_harpoon_head.process_impulse(this.attack_loc, this.impulse_force, angle)
                  this.enemies_hit.push(this_harpoon_head.id)
                }
              }
            }
          }
        }
      }
      this.attack_duration -= dt
    }
  }

  if(!this.is_locked())
  {
    var f = this.force
    var f_x = 0
    var f_y = 0
    if(this.left) f_x -= 1
    if(this.right) f_x += 1
    if(this.up) f_y -= 1
    if(this.down) f_y += 1


    var force = Math.abs(f_x)+Math.abs(f_y)==2 ? f/Math.sqrt(2) : f;

    if(this.is_confused()) {
      f_x *= -1
      f_y *= -1
    }

    if(this.is_gooed()) {
      f_x *= this.gooed_force_boost
      f_y *= this.gooed_force_boost
    }
    this.body.ApplyImpulse(new box_2d.b2Vec2(force*f_x, force*f_y), this.body.GetWorldCenter())
    if (this.impulse_game_state.show_tutorial && (f_x != 0 || f_y != 0)) {
      this.impulse_game_state.add_tutorial_signal("player_moved")
    }
  }
}

Player.prototype.maybe_start_impulse = function () {
  if (this.level.impulse_disabled) {
    return;
  }
  if(saveData.optionsData.control_scheme == "mouse") {
    if((this.mouse_pressed || cur_time - this.last_mouse_down < 100) && !this.attacking && !this.is_silenced())
    {
      this.attacking = true
      this.impulse_game_state.game_numbers.impulsed = true;
      this.attack_loc = this.body.GetPosition().Copy()
      this.attack_angle = this.impulse_angle
      this.attack_duration = this.attack_length
      music_player.play_sound("impulse")
      if (this.impulse_game_state.show_tutorial) {
        this.impulse_game_state.add_tutorial_signal("player_impulsed")
      }

    }
    this.impulse_angle = utils.atan({x: this.body.GetPosition().x*constants.drawFactor, y: this.body.GetPosition().y*constants.drawFactor}, this.mouse_pos)
  } else if(saveData.optionsData.control_scheme == "keyboard") {
    if(!this.attacking && !this.is_silenced()) {
      var earliest_key_press = 0
      if(this.ileft != null && this.ileft > earliest_key_press) earliest_key_press = this.ileft
      if(this.iright != null && this.iright > earliest_key_press) earliest_key_press = this.iright
      if(this.iup != null && this.iup > earliest_key_press) earliest_key_press = this.iup
      if(this.idown != null && this.idown > earliest_key_press) earliest_key_press = this.idown


      if(earliest_key_press != 0 && (new Date().getTime() - earliest_key_press > 40)) {
        if(this.ileft != null && this.iup != null) {
          this.attack_angle = Math.PI * 5/4
        }
        else if(this.ileft != null && this.idown != null) {
          this.attack_angle = Math.PI * 3/4
        }
        else if(this.iright != null && this.iup != null) {
          this.attack_angle = Math.PI * 7/4
        }
        else if(this.iright != null && this.idown != null) {
          this.attack_angle = Math.PI * 1/4
        }
        else if(this.ileft != null) {
          this.attack_angle = Math.PI
        }
        else if(this.iright != null) {
          this.attack_angle = 0
        }
        else if(this.iup != null) {
          this.attack_angle = Math.PI * 3/2
        }
        else if(this.idown != null) {
          this.attack_angle = Math.PI * 1/2
        }
        if (this.is_confused()) {
          this.attack_angle += Math.PI
        }
        this.attacking = true
        this.impulse_game_state.game_numbers.impulsed = true;
        this.attack_loc = this.body.GetPosition().Copy()
        this.attack_duration = this.attack_length
        music_player.play_sound("impulse")
      }
    }
  }
}

Player.prototype.readjust_force = function() {
  if(this.is_bulked()) {
    this.force = this.true_force * this.bulk_factor
  } else if (this.is_lightened()){
      this.force = this.true_force/this.lighten_factor/this.lighten_factor
  }
  else {
    this.force = this.true_force
  }
}

Player.prototype.get_current_position = function() {
  return this.body.GetPosition()
}

Player.prototype.point_in_impulse_angle = function(pt) {
  var angle = utils.atan(this.attack_loc, pt)

  var struck;

  if(this.attack_angle < -Math.PI * 2/3)
  {
    struck = angle <= this.attack_angle + Math.PI/3 || angle >= this.attack_angle + 5*Math.PI/3
  }
  else if(this.attack_angle > 2*Math.PI/3)
  {
    struck = angle <= this.attack_angle - 5*Math.PI/3 || angle >= this.attack_angle - Math.PI/3
  }
  else
    struck = angle>=this.attack_angle - Math.PI/3 && angle <= this.attack_angle + Math.PI/3

  return struck
}

Player.prototype.point_in_impulse_dist = function(pt, fast) {
  var lighten_factor = this.get_lighten_factor()
  var dist = this.attack_loc.Copy()
  dist.Subtract(pt)
  dist = dist.Normalize()
  var speedy_factor = fast ? this.impulse_width * 4: this.impulse_width * 2

  return dist >= this.impulse_radius * lighten_factor * (((this.attack_length - this.attack_duration)/this.attack_length) - speedy_factor)
   && dist <= this.impulse_radius * lighten_factor * (((this.attack_length - this.attack_duration)/this.attack_length) + speedy_factor)
}

Player.prototype.pre_draw = function(context) {}

Player.prototype.draw = function(context) {
  if(this.dying) {

  }
  else {

    context.save()
    if(this.confuse_duration > 0) {
      var prop = Math.max(((this.confuse_interval-this.confuse_duration) / this.confuse_interval), 0)
      uiRenderUtils.drawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.radius, prop, "#24ac40")
    } else if(this.silence_duration > 0) {
      var prop = Math.max(((this.silence_interval-this.silence_duration) / this.silence_interval), 0)
      uiRenderUtils.drawProgCircle(context, this.body.GetPosition().x, this.body.GetPosition().y, this.radius, prop, "gray")
    }

    if (!this.appearing) {
      if (this.is_locked())
      {
        this.draw_player_sprite(context, "player_red");
      }
      else if(this.is_confused())
      {
        this.draw_player_sprite(context, "player_green");
      }
      else if(this.is_silenced())
      {
        this.draw_player_sprite(context, "player_gray");
      }
      else if(this.is_gooed())
      {
        this.draw_player_sprite(context, "player_yellow");
      }
      else {
        this.draw_player_sprite(context, "player_normal");
      }
    } else {
      var prog = this.appear_timer / this.appear_duration;
      var factor = 1 + 8 * prog;
      context.save();
      context.globalAlpha *= 1 - prog
      context.beginPath();
      context.lineWidth = Math.ceil(4 - 4 * prog);
      context.strokeStyle = constants.colors["impulse_blue"];
      context.arc(this.body.GetPosition().x * constants.drawFactor, this.body.GetPosition().y * constants.drawFactor, this.shape.GetRadius() * factor * constants.drawFactor, 0, 2*Math.PI, true);
      context.stroke();
      context.restore();
    }


    var lighten_factor = this.get_lighten_factor()

    if(this.is_gooed()) {
      context.beginPath()
      context.arc(this.body.GetPosition().x*constants.drawFactor, this.body.GetPosition().y*constants.drawFactor,
       this.radius* lighten_factor * constants.drawFactor, 0, 2* Math.PI, false)
      context.strokeStyle = "black"
      context.stroke()

    }
    context.beginPath()

    if(saveData.optionsData.impulse_shadow && !this.level.impulse_disabled) {
      context.save();
      var prog = this.appear_timer / this.appear_duration;
      context.globalAlpha *= Math.max(0, 1 - prog);
      if (!this.is_silenced() && saveData.optionsData.control_scheme == "mouse") {
        context.fillStyle = this.impulse_target_color

        context.arc(this.body.GetPosition().x*constants.drawFactor, this.body.GetPosition().y*constants.drawFactor, this.impulse_radius * lighten_factor* constants.drawFactor, this.impulse_angle - Math.PI/3, this.impulse_angle + Math.PI/3)
        context.lineTo(this.body.GetPosition().x*constants.drawFactor + Math.cos(this.impulse_angle + Math.PI/3) * this.impulse_radius * lighten_factor * constants.drawFactor, this.body.GetPosition().y*constants.drawFactor + Math.sin(this.impulse_angle + Math.PI/3) * this.impulse_radius * lighten_factor*constants.drawFactor)
        context.lineTo(this.body.GetPosition().x*constants.drawFactor, this.body.GetPosition().y*constants.drawFactor)
        context.fill()
      } else if(!this.is_silenced() && saveData.optionsData.control_scheme == "keyboard") {
        context.beginPath()
        context.arc(this.body.GetPosition().x*constants.drawFactor, this.body.GetPosition().y*constants.drawFactor, this.impulse_radius * lighten_factor *constants.drawFactor, 0, 2 * Math.PI)
        context.globalAlpha /= 6
        context.lineWidth = 2
        context.strokeStyle = constants.colors["impulse_blue"]
        context.stroke()

      }
      context.restore();
    }
    if(this.attacking)
    {
      var cur_time = (new Date()).getTime()
      context.beginPath();
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 10;
      context.shadowColor = this.impulse_color;

      context.lineWidth = this.impulse_radius * this.impulse_width * constants.drawFactor * lighten_factor
      var prop = ((this.attack_length - this.attack_duration)/this.attack_length);
      context.save();
      if(prop > 0.5) {

        context.globalAlpha *= (1 - prop)/(0.5) < 0 ? 0 : (1-prop)/(0.5);
      }

      context.arc(this.attack_loc.x*constants.drawFactor, this.attack_loc.y*constants.drawFactor, this.impulse_radius * lighten_factor* prop * constants.drawFactor,  this.attack_angle - Math.PI/3, this.attack_angle + Math.PI/3);
      context.strokeStyle = this.impulse_color
      context.lineWidth = 5
      context.stroke();
      context.restore();
    }

    if(this.impulse_game_state.combo_enabled && saveData.optionsData.multiplier_display &&
       !this.impulse_game_state.is_boss_level) {
      context.font = "16px Open Sans"
      context.fillStyle = constants.colors["impulse_blue"]
      context.textAlign = "center"
      context.shadowBlur = 0
      context.fillText("x"+this.impulse_game_state.game_numbers.combo, this.body.GetPosition().x*constants.drawFactor, this.body.GetPosition().y*constants.drawFactor + 30)
    }
    context.restore()
  }
}

Player.prototype.draw_player_sprite = function(ctx, name) {
  var lighten_factor = this.get_lighten_factor()
  renderUtils.drawSprite(ctx, this.body.GetPosition().x*constants.drawFactor, this.body.GetPosition().y*constants.drawFactor, (this.body.GetAngle()), this.shape.GetRadius() * constants.drawFactor * 2.5 * lighten_factor, this.shape.GetRadius() * constants.drawFactor * 2.5 * lighten_factor, name)
}

Player.prototype.get_lighten_factor = function() {
  if(!this.is_lightened())
    return 1

  var prog = this.status_duration[3]/this.last_lighten
      if(prog < .1)
      {
        var transition = 1 - prog/.1
        lighten_factor = (this.lighten_start) * transition + (this.lighten_finish) * (1-transition)
      } else if(prog > .9) {
        var transition = (prog - .9)/.1
        lighten_factor = (this.lighten_start) * transition + (this.lighten_finish) * (1-transition)
      } else {
        lighten_factor = this.lighten_finish
      }
  return lighten_factor
}

Player.prototype.collide_with = function(other) {

}

Player.prototype.point_intersect = function(pt) {
  return utils.pDist(pt, this.body.GetPosition()) < this.r
}

Player.prototype.start_death = function(reason) {
  this.dying = true
  this.dying_duration = this.dying_length
  this.level.obstacles_visible = true
  if (reason != "absorbed")
  music_player.play_sound("pdeath")
  this.level.add_fragments("player", this.body.GetPosition(), this.body.GetLinearVelocity(), true)
}

Player.prototype.get_segment_intersection = function(seg_s, seg_f) {
  //checks if the segment intersects this enemy
  //returns the closest intersection to seg_s
  var j = this.points_polar_form.length - 1
  var ans = null
  var ans_d = null

  var cur_ang = 0

  for(var i = 0; i < this.points_polar_form.length; i++)
  {
    var loc_i = {x: this.body.GetPosition().x + this.points_polar_form[i].r * Math.cos(this.points_polar_form[i].ang + cur_ang),
     y: this.body.GetPosition().y + this.points_polar_form[i].r * Math.sin(this.points_polar_form[i].ang + cur_ang)}
    var loc_j = {x: this.body.GetPosition().x + this.points_polar_form[j].r * Math.cos(this.points_polar_form[j].ang + cur_ang),
     y: this.body.GetPosition().y + this.points_polar_form[j].r * Math.sin(this.points_polar_form[j].ang + cur_ang)}
    var temp_point = utils.getSegIntersection(loc_i, loc_j, seg_s, seg_f)
    if(temp_point == null) continue
    var temp_d = utils.pDist(temp_point, seg_s)
    if(ans_d == null || temp_d < ans_d)
    {
      ans = temp_point
      ans_d = temp_d
    }
    j = i
  }
  return {point: ans, dist: ans_d}

}

module.exports = Player;

},{"../core/controls.js":2,"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../load/save_data.js":69,"../render/ui.js":82,"../render/utils.js":83,"../vendor/box2d.js":97}],73:[function(require,module,exports){
var constants = require('../data/constants.js');
var uiRenderUtils = require('../render/ui.js');

var Background = function (backgroundColor, bgFile, alpha) {
  this.bgFile = bgFile;
  this.alpha = alpha;
  this.backgroundColor = backgroundColor;
  this.canvas = document.createElement('canvas');
  this.canvas.width = constants.levelWidth;
  this.canvas.height = constants.levelHeight;
  this.ctx = this.canvas.getContext('2d');
  this.render();
};

Background.prototype.render = function () {
  this.ctx.save();
  this.ctx.fillStyle = this.backgroundColor;
  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  this.ctx.globalAlpha = this.alpha;
  if (this.bgFile) {
    uiRenderUtils.tessellateBg(this.ctx, 0, 0, constants.levelWidth, constants.levelHeight, this.bgFile)
  }
  this.ctx.restore();
}

Background.prototype.getCanvas = function() {
  return this.canvas;
}

module.exports = Background;

},{"../data/constants.js":13,"../render/ui.js":82}],74:[function(require,module,exports){
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var renderUtils = require('../render/utils.js');

var enemyRenderUtils = {};

enemyRenderUtils.drawEnemyImage = function(context, state, draw_polygons, type, default_color, scale) {

  if (scale === undefined) {
    scale = 1
  }

  context.save()
  context.shadowBlur = 0

  for(var k = 0; k < draw_polygons.length; k++) {

    if(draw_polygons[k].visible === false) continue

    var cur_shape = draw_polygons[k]
    var cur_shape_points = draw_polygons[k].vertices
    var cur_color = draw_polygons[k].color ? draw_polygons[k].color : default_color

    // draw the shape
    context.beginPath()

    if(cur_shape.type == "polygon") {
      //draw polygon shape
      context.moveTo(scale*(cur_shape.x + cur_shape.r*cur_shape_points[0][0])*constants.drawFactor, scale*(cur_shape.y + cur_shape.r*cur_shape_points[0][1])*constants.drawFactor)
      for(var i = 1; i < cur_shape_points.length; i++)
      {
        context.lineTo(scale*(cur_shape.x + cur_shape.r*cur_shape_points[i][0])*constants.drawFactor, scale*(cur_shape.y + cur_shape.r*cur_shape_points[i][1])*constants.drawFactor)
      }
    }
    context.closePath()
    var interior_color = enemyData[type].interior_color

    context.fillStyle = cur_color

    if(state == "normal" && interior_color) {
      context.fillStyle = interior_color
    }

    context.fillStyle = "black"

    if(state != "lighten")
      context.fill()


    if(interior_color && state == "normal")
      context.strokeStyle = cur_color
    else
      context.strokeStyle = cur_color//context.fillStyle

    context.lineWidth = 2 * Math.sqrt(scale)

    if(state == "lighten") {
      context.strokeStyle = "black"
      context.lineWidth = 4 * Math.sqrt(scale)
    }
    context.stroke()

  }
  var erase_lines =  enemyData[type].erase_lines

  if(erase_lines) {
    context.beginPath()
    for(var i = 0; i < erase_lines.length; i++) {
      context.moveTo(scale*(erase_lines[i][0][0])*constants.drawFactor, scale*(erase_lines[i][0][1])*constants.drawFactor)
      context.lineTo(scale*(erase_lines[i][1][0])*constants.drawFactor, scale*(erase_lines[i][1][1])*constants.drawFactor)
    }
    context.strokeStyle = "black"
    context.lineWidth = 3
    context.globalAlpha = 1
    context.stroke()
  }

  var extra_lines =  enemyData[type].extra_rendering_lines
  var r =  enemyData[type].effective_radius

  if(!(typeof extra_lines === "undefined")) {
      for(var m = 0; m < extra_lines.length; m++) {
        context.beginPath()
        var line = extra_lines[m]
        context.moveTo(scale*(r * line["x1"]) * constants.drawFactor, scale*(r * line["y1"]) * constants.drawFactor)
        context.lineTo(scale*(r * line["x2"]) * constants.drawFactor, scale*(r * line["y2"]) * constants.drawFactor)
        context.lineWidth = 2
        context.strokeStyle = cur_color
        context.stroke()
      }
    }

  context.restore()
}

enemyRenderUtils.drawEnemy = function(context, enemy_name, x, y, d, rotate, status, enemy_color) {
  // if d == null, will draw at default size


  if(enemy_name.slice(enemy_name.length - 4) == "boss") return
  context.save()
  context.translate(x, y);
  if(rotate) {
    context.rotate(rotate);
  }
  if(status === undefined) status = "normal"
  var max_radius = 1.5
  var size = enemyData[enemy_name].effective_radius * constants.drawFactor * constants.enemyCanvasFactor
  if(d == null) {
    var draw_scale = size
  } else {
    //var draw_scale = Math.min(1/enemyData[enemy_name].effective_radius, 1) * d/2
    var draw_scale = d * Math.min(enemyData[enemy_name].effective_radius/max_radius, 1)
  }

  enemyRenderUtils.drawEnemyHelper(context, enemy_name, draw_scale, status, enemy_color)

  context.restore()
};

enemyRenderUtils.drawEnemyHelper = function(context, enemy_name, draw_scale, status, enemy_color) {

  if(!enemy_color) {
    enemy_color = enemyData[enemy_name].color
  }

  var draw_polygons = enemyData[enemy_name].draw_polygons

  if(!draw_polygons) {
    draw_polygons = enemyData[enemy_name].shape_polygons
  }

  var scale = draw_scale / (constants.enemyCanvasFactor * enemyData[enemy_name].effective_radius * constants.drawFactor)
  enemyRenderUtils.drawEnemyImage(context, status, draw_polygons, enemy_name, enemy_color, scale)

  if(!(typeof enemyData[enemy_name].extra_rendering_polygons === "undefined")) {
    for(var m = 0; m < enemyData[enemy_name].extra_rendering_polygons.length; m++) {
      var this_shape = enemyData[enemy_name].extra_rendering_polygons[m]
      if(!this_shape.colored) {
        renderUtils.drawShape(context, 0, 0, this_shape, draw_scale, enemy_color, 1, 0, "black")
      } else {
        renderUtils.drawShape(context, 0, 0, this_shape, draw_scale, enemy_color)
      }
    }
  }
}

enemyRenderUtils.drawEnemyColored = function(context, enemy_name, x, y, d, rotate, color) {

  context.save()
  if(rotate) {
    context.translate(x, y);
    context.rotate(rotate);
    context.translate(-x, -y);
  }

  var draw_scale = Math.min(1/enemyData[enemy_name].effective_radius, 1) * d/2
   if(enemy_name.slice(enemy_name.length - 4) == "boss") {
      draw_scale = 2/enemyData[enemy_name].effective_radius * d/2
   }
   for(var m = 0; m < enemyData[enemy_name].shape_polygons.length; m++) {
      var this_shape = enemyData[enemy_name].shape_polygons[m]
      renderUtils.drawShape(context, x, y, this_shape, draw_scale, color)

    }
    if(!(typeof enemyData[enemy_name].extra_rendering_polygons === "undefined")) {
      for(var m = 0; m < enemyData[enemy_name].extra_rendering_polygons.length; m++) {
        var this_shape = enemyData[enemy_name].extra_rendering_polygons[m]
        renderUtils.drawShape(context, x, y, this_shape, draw_scale, color)
      }
    }

    var extra_lines =  enemyData[enemy_name].extra_rendering_lines
    if(!(typeof extra_lines === "undefined")) {
      for(var m = 0; m < extra_lines.length; m++) {
        context.beginPath()
        var line = extra_lines[m]
        context.moveTo(x + draw_scale*line["x1"], y + draw_scale*line["y1"])
        context.lineTo(x + draw_scale*line["x2"], y + draw_scale*line["y2"])
        context.lineWidth = 2
        context.strokeStyle = color
        context.stroke()
      }
    }
  context.restore()
};

enemyRenderUtils.drawEnemyRealSize = function(context, enemy_name, x, y, factor, rotate) {

  context.save()
  context.translate(x, y);
  if(rotate) {
    context.rotate(rotate);
  }

  var size = enemyData[enemy_name].images["normal"].height

  enemyRenderUtils.drawEnemyHelper(context, enemy_name, size * factor/2, "normal", enemyData[enemy_name].color)
  context.restore()
};


module.exports = enemyRenderUtils;

},{"../data/constants.js":13,"../data/enemy_data.js":15,"../render/utils.js":83}],75:[function(require,module,exports){
var constants = require('../data/constants.js');
var objectRenderUtils = require('../render/object.js');
var renderUtils = require('../render/utils.js');
var utils = require('../core/utils.js');

var Fragment = function(shape, size, loc, velocity, color) {
  this.init(shape, size, loc, velocity, color)
}

Fragment.prototype.init = function(shape, size, loc, velocity, color) {
  this.loc = loc
  this.shape = shape
  this.size = size
  this.velocity = velocity
  this.color = color
  this.v_half_life = 500
}

Fragment.prototype.process = function(dt) {
  this.loc.x += this.velocity.x * dt/1000
  this.loc.y += this.velocity.y * dt/1000
  this.velocity.x *= Math.pow(.5, dt/this.v_half_life);
  this.velocity.y *= Math.pow(.5, dt/this.v_half_life);
}

Fragment.prototype.draw = function(context, prog) {
  if(this.shape == "multi") {
    context.save()
    context.globalAlpha *= prog
    var pointer_angle = utils.atan({x: 0, y: 0}, this.velocity)
    if(this.shape == "multi")
      objectRenderUtils.drawMultiFragment(context, this.loc.x/constants.drawFactor, this.loc.y/constants.drawFactor, pointer_angle)

    context.restore()

  } else if(this.shape == "shadow" ) {
    context.save()
    context.globalAlpha *= prog;
    renderUtils.drawSprite(context, this.loc.x,
      this.loc.y,
      0, 150 * prog,
      150 * prog, "dark_aura");
    context.restore();
  } else {
    context.save()
    var pointer_angle = utils.atan({x: 0, y: 0}, this.velocity)
    renderUtils.drawShape(context, this.loc.x, this.loc.y, this.shape, this.size, this.color, prog, pointer_angle)
    context.restore()
  }
}

module.exports = Fragment;

},{"../core/utils.js":11,"../data/constants.js":13,"../render/object.js":79,"../render/utils.js":83}],76:[function(require,module,exports){
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');

var Fragment = require('../render/fragment.js');
var Player = require('../player/player.js');

var FragmentGroup = function(enemy_type, loc, velocity, shadowed) {
  this.init(enemy_type, loc, velocity, shadowed)
}

FragmentGroup.prototype.init = function(enemy_type, loc, velocity, shadowed) {
  var BOSS_FRAGMENT_LIFESPAN = 5000;
  this.shadowed = shadowed ? true : false;
  this.fragments = []
  if(enemy_type == "multi") {
    velocity = {x: 0, y: 0}
  }
  this.waves = 1;

  var velocity_adjustment_factor = Math.min(1, 10/Math.sqrt(Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y+0.01)))

  //decrease the velocity some so that the explosion looks good
  velocity = {x: velocity.x * velocity_adjustment_factor, y: velocity.y * velocity_adjustment_factor}
  this.lifespan = 1000
  this.color = "black"

  if(enemy_type.slice(enemy_type.length - 4, enemy_type.length) == "boss") {
    this.shape = enemyData[enemy_type].death_polygons[0]
    this.color = enemyData[enemy_type].color
    this.original_v_damping = 0.5
    this.num_fragments = 50
    this.burst = 10;
    if (enemy_type == "boss_two") {
      this.burst = 20;
    }
    this.waves = 5;
    this.lifespan = BOSS_FRAGMENT_LIFESPAN;
  } else if(enemy_type=="player") {
    this.shape =
      {type: "circle", x: 0, y: 0, r: Player.prototype.radius}
    this.color = constants.colors["player_color"]
    this.original_v_damping = 0.5
    this.num_fragments = 12
    this.burst = 2
    this.waves = 2;
  } else if(enemy_type=="harpoon" || enemy_type=="harpoonhead") {
    this.shape = enemyData[enemy_type].shape_polygons[0]
    this.color = enemyData[enemy_type].color
    this.original_v_damping = 0.3
    this.num_fragments = 4
    this.burst = 2

  } else if(enemy_type == "multi") {
    this.num_fragments = 6
    this.burst = 20
    this.original_v_damping = 1
    this.shape = enemy_type

  } else {
    this.shape = enemyData[enemy_type].shape_polygons[0]
    this.color = enemyData[enemy_type].color
    if(enemy_type=="tanker") {
      this.color = "red"
    }
    this.original_v_damping = 0.3
    this.num_fragments = 4
    this.burst = 2
  }
  this.life_left = this.lifespan

  this.burst_force = this.burst * Math.max(3, Math.sqrt(Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y)))

  this.v_decay_per_second = .5
  this.center = {x: loc.x, y: loc.y}
  this.center_velocity = {x: this.original_v_damping * velocity.x, y: this.original_v_damping * velocity.y }

  for (var j = 0; j < this.waves; j++) {
    var num_frags_in_wave = this.num_fragments / this.waves;
    for(var i = 0; i < num_frags_in_wave; i++) {
      dir = 2*Math.PI * i / num_frags_in_wave + (Math.random() - 0.5) * 2 * Math.PI / num_frags_in_wave;
      new_v = {x: this.original_v_damping * velocity.x + Math.cos(dir) * (j + 1 ) / this.waves * this.burst_force,
        y: this.original_v_damping * velocity.y + Math.sin(dir) * (j + 1 ) / this.waves * this.burst_force}

      this.fragments.push(new Fragment(this.shape, constants.drawFactor/3, {x: loc.x * constants.drawFactor, y: loc.y * constants.drawFactor},
       {x: new_v.x * constants.drawFactor, y: new_v.y * constants.drawFactor}, this.color))
    }
    if(enemy_type.slice(enemy_type.length - 4, enemy_type.length) == "boss") {
      for(var i = 0; i < num_frags_in_wave; i++) {
        dir = 2*Math.PI * i / num_frags_in_wave + (Math.random() - 0.5) * 2 * Math.PI / num_frags_in_wave;
        new_v = {x: this.original_v_damping * velocity.x + Math.cos(dir) * (j + 1 ) / this.waves * this.burst_force,
          y: this.original_v_damping * velocity.y + Math.sin(dir) * (j + 1 ) / this.waves * this.burst_force}

        this.fragments.push(new Fragment("shadow", constants.drawFactor/3, {x: loc.x * constants.drawFactor, y: loc.y * constants.drawFactor},
         {x: new_v.x * constants.drawFactor, y: new_v.y * constants.drawFactor}, this.color))
      }
    }
  }
}

FragmentGroup.prototype.process = function(dt) {
  this.life_left -= dt
  this.center.x += this.center_velocity.x * dt/1000
  this.center.y += this.center_velocity.y * dt/1000
  this.center_velocity.x -= this.v_decay_per_second * this.center_velocity.x * dt/1000
  this.center_velocity.y -= this.v_decay_per_second * this.center_velocity.y * dt/1000

  for(var i = 0; i < this.fragments.length; i++) {
    this.fragments[i].process(dt)
  }
}

FragmentGroup.prototype.draw = function(context) {

  var prog = this.life_left/this.lifespan
  if(this.shadowed) {
    context.shadowColor = this.color;
    context.shadowBlur = 15;
  }
  for(var i = 0; i < this.fragments.length; i++) {

    this.fragments[i].draw(context, this.life_left/this.lifespan)

  }
  context.shadowBlur = 0;
}

FragmentGroup.prototype.isDone = function() {
  return this.life_left <= 0
}

module.exports = FragmentGroup;

},{"../data/constants.js":13,"../data/enemy_data.js":15,"../player/player.js":72,"../render/fragment.js":75}],77:[function(require,module,exports){
var saveData = require('../load/save_data.js');

var iconRenderUtils = {};

iconRenderUtils.drawPauseIcon = function(context, x, y, scale, color, key_display) {

  context.save()
  context.clearRect(x - scale, y - scale, 3 * scale, 3 * scale)
  context.beginPath()
  context.rect(x - scale * 3/8, y - scale/2, scale * 1/4, scale)
  context.rect(x + scale * 1/8, y - scale/2, scale * 1/4, scale)
  context.fillStyle = color
  context.fill()

  if(key_display) {
    context.font = "10px Open Sans"
    context.textAlign = "center"
    if(saveData.optionsData.control_hand == "left") {
      context.fillText("ENTER", x+scale, y+scale)
    } else {
      context.fillText("Q", x+scale, y+scale)
    }
  }

  context.restore()
}

iconRenderUtils.drawGearIcon = function(context, x, y, scale, color, center_color, center_glow) {
  context.save()
  //context.shadowBlur = 5
  var spokes = 6
  var unit = 2 * Math.PI / (spokes * 4)
  var offset = -0.4
  context.beginPath()
  for(var i = 0; i < spokes; i++) {

    if(i == 0) {
      context.moveTo(x - Math.cos(unit * (4 * i+ offset)) * scale, y - Math.sin(unit * (4 * i + offset)) * scale)
    } else {
      context.lineTo(x - Math.cos(unit * (4 * i+ offset)) * scale, y - Math.sin(unit * (4 * i+ offset)) * scale)
    }
    context.lineTo(x - Math.cos(unit * (4 * i + 1+ offset)) * scale, y - Math.sin(unit * (4 * i + 1+ offset)) * scale)
    context.lineTo(x - Math.cos(unit * (4 * i + 2+ offset)) * scale * 0.75, y - Math.sin(unit * (4 * i + 2+ offset)) * scale * 0.75)
    context.lineTo(x - Math.cos(unit * (4 * i + 3+ offset)) * scale * 0.75, y - Math.sin(unit * (4 * i + 3+ offset)) * scale * 0.75)
  }
  context.closePath()
  context.fillStyle = color
  context.fill()
  if(center_glow)
    context.globalAlpha /= 2
  context.beginPath()
  context.arc(x, y, scale * 0.5, 0, 2 * Math.PI * 0.999)
  context.fillStyle = center_color
  context.fill()
  context.restore()
}

iconRenderUtils.drawCreditsIcon = function(context, x, y, scale, color) {
  context.save()
  context.beginPath()
  context.arc(x, y - scale/3, scale/3, 0, 2 * Math.PI, true)
  context.moveTo(x, y + scale*5/6)
  context.arc(x, y + scale*5/6, scale * 2/3, 0, Math.PI, true)
  context.fillStyle = color
  context.fill()
  context.restore()
}

iconRenderUtils.drawTutorialIcon = function(context, x, y, scale, color) {
  context.save()
  context.beginPath()
  context.moveTo(x, y - scale * 1/3)
  context.lineTo(x - scale, y - scale * 2/3)
  context.lineTo(x - scale, y + scale * 2/3)
  context.lineTo(x, y + scale)
  context.moveTo(x, y + scale)
  context.lineTo(x, y - scale * 1/3)
  context.lineTo(x + scale, y - scale * 2/3)
  context.lineTo(x + scale, y + scale * 2/3)
  context.lineTo(x, y + scale)
  //context.rect(x - scale*2/3, y - scale*5/6, scale * 4/3, scale*5/3)
  context.lineWidth = 4
  context.strokeStyle = color
  context.stroke()
  //context.fillStyle = color
  //context.fill()
  context.restore()
}

iconRenderUtils.drawRetryIcon = function(context, x, y, scale, color) {
  context.save()
  context.beginPath()
  context.arc(x, y, scale * 3/4,  Math.PI * 2/5, Math.PI)
  context.lineWidth = 4
  context.strokeStyle = color
  context.stroke()
  context.beginPath()
  context.arc(x, y, scale * 3/4, Math.PI * 7/5, Math.PI * 2)
  context.lineWidth = 4
  context.strokeStyle = color
  context.stroke()

  context.beginPath()
  context.moveTo(x - scale * 3/16, y)
  context.lineTo(x - scale * 19/16, y)
  context.lineTo(x - scale * 11/16, y - scale/2)
  context.moveTo(x + scale * 3/16, y)
  context.lineTo(x + scale * 19/16, y)
  context.lineTo(x + scale * 11/16, y + scale/2)
  context.fillStyle = color
  context.fill()
  context.restore()
}

iconRenderUtils.drawBackIcon = function(context, x, y, scale, color) {
  context.save()
  context.beginPath()
  context.arc(x, y, scale * 3/4, 3*Math.PI/2, Math.PI * 3/4)
  context.lineWidth = 4
  context.strokeStyle = color
  context.stroke()
  context.beginPath()
  context.moveTo(x, y - scale * 3/16)
  context.lineTo(x, y - scale * 19/16)
  context.lineTo(x - scale/2, y - scale * 11/16)
  context.fillStyle = color
  context.fill()
  context.restore()
}

iconRenderUtils.drawStartIcon = function(context, x, y, scale, color) {
  context.save()
  iconRenderUtils.drawPlayerIcon(context, x, y, scale/2, color)
  context.beginPath()
  context.arc(x, y, scale, Math.PI * 7/6, Math.PI * 11/6)
  context.lineWidth = Math.ceil(scale / 6)
  context.strokeStyle = color
  context.stroke()
  context.restore()

}

iconRenderUtils.drawPlayerIcon = function(context, x, y, scale, color) {
  context.beginPath()
  context.arc(x, y, scale, Math.PI * 3/2, Math.PI * 3/2 + Math.PI * 1.999)
  context.fillStyle = color
  context.fill()
  context.beginPath()
  context.arc(x, y, scale * 4/5, Math.PI * 3/2, Math.PI * 3/2 + Math.PI * 1.999 )
  context.fillStyle = "black"
  context.fill()
  context.beginPath()
  context.arc(x, y, scale * 11/20, Math.PI * 3/2, Math.PI * 3/2 + Math.PI * 1.999)
  context.fillStyle = color
  context.fill()
}

iconRenderUtils.drawLoadingIcon = function(context, x, y, scale, color, prog) {
  context.save()
  iconRenderUtils.drawPlayerIcon(context, x, y, scale/2, color)
  context.beginPath()
  context.arc(x, y, scale * 3/4, Math.PI * 3/2, Math.PI * 3/2 + Math.PI * 1.999 * prog)
  context.lineWidth = 2
  context.strokeStyle = color
  context.stroke()
  context.restore()

}

iconRenderUtils.drawSaveIcon = function(context, x, y, scale, color) {
  context.save()
  context.shadowBlur = 0
  context.beginPath()
  context.fillStyle = color
  context.strokeStyle = color
  context.moveTo(x - scale * 0.6, y - scale * 0.6)
  context.lineTo(x - scale * 0.6, y + scale * 0.6)
  context.lineTo(x + scale * 0.6, y + scale * 0.6)
  context.lineTo(x + scale * 0.6, y - scale * 0.6)
  context.lineTo(x, y - scale * 0.6)
  context.lineTo(x, y)
  context.lineWidth = 5
  context.stroke()
  context.beginPath()
  context.moveTo(x - scale * 0.35, y - scale * 0.15)
  context.lineTo(x + scale * 0.35, y - scale * 0.15)
  context.lineTo(x, y + scale * 0.2)
  context.fill()
  context.restore()

}
iconRenderUtils.drawQuestIcon = function(context, x, y, scale, color) {
  context.save()
  context.shadowBlur = 0
  context.beginPath()
  context.fillStyle = color
  context.strokeStyle = color
  context.arc(x, y, scale * 0.7, 0, 2 * Math.PI, true)
  context.lineWidth = 3
  context.stroke()
  context.beginPath()
  context.lineWidth = 4
  context.moveTo(x, y - scale * 0.4)
  context.lineTo(x, y + scale * 0.2)
  context.moveTo(x, y + scale * 0.3)
  context.lineTo(x, y + scale * 0.4)
  context.stroke()
  context.restore()

}

iconRenderUtils.drawDeleteIcon = function(context, x, y, scale, color) {
  context.save()
  context.shadowBlur = 0
  context.beginPath()
  context.moveTo(x - scale * 3/8, y - scale/4)
  context.lineTo(x + scale * 3/8, y - scale/4)
  context.moveTo(x - scale/4, y - scale/4)
  context.lineTo(x - scale/4, y + scale/2)
  context.lineTo(x + scale/4, y + scale/2)
  context.lineTo(x + scale/4, y - scale/4)
  context.moveTo(x - scale/8, y - scale/8)
  context.lineTo(x - scale/8, y + 3 * scale/8)
  context.moveTo(x, y - scale/8)
  context.lineTo(x, y + 3 * scale/8)
  context.moveTo(x + scale/8, y - scale/8)
  context.lineTo(x + scale/8, y + 3 * scale/8)
  context.moveTo(x - scale/8, y - scale/4)
  context.lineTo(x - scale/8, y - 3 * scale/8)
  context.lineTo(x + scale/8, y - 3 * scale/8)
  context.lineTo(x + scale/8, y - scale/4)
  context.strokeStyle = color
  context.lineWidth = 2
  context.stroke()
  context.restore()
}

iconRenderUtils.drawQuitIcon = function(context, x, y, scale, color) {
  context.save()
  context.shadowBlur = 0
  context.beginPath()
  context.moveTo(x - scale/2, y - scale/2)
  context.lineTo(x + scale/2, y + scale/2)
  context.moveTo(x - scale/2, y + scale/2)
  context.lineTo(x + scale/2, y - scale/2)
  context.strokeStyle = color
  context.lineWidth = 5
  context.stroke()
  context.restore()
}

iconRenderUtils.drawTextureIcon = function(context, x, y, scale, color) {
  context.save()
  context.translate(x, y)
  context.transform(1,-0.35,0,1,0,0);
  context.translate(-x, -y)
  context.beginPath()
  context.moveTo(x - scale/2, y)
  context.lineTo(x + scale/2, y)
  context.moveTo(x - scale/2, y + scale/2)
  context.lineTo(x + scale/2, y + scale/2)
  context.lineWidth = 6
  context.strokeStyle = color
  context.stroke()
  context.restore()
}

iconRenderUtils.drawPhysicsIcon = function(context, x, y, scale, color) {
  context.save()
  context.beginPath()
  context.rect(x - scale/4, y - scale/2, scale/2, scale/2)
  context.rect(x - scale/2, y, scale/2, scale/2)
  context.rect(x, y, scale/2, scale/2)
  context.strokeStyle = color
  context.lineWidth = 4
  context.stroke()
  context.restore()
}

iconRenderUtils.drawNoteIcon = function(context, x, y, scale, color) {
  context.save()
  context.translate(scale/3, 0)
  context.beginPath()
  context.moveTo(x - scale/3, y + scale/2)
  context.lineTo(x - scale/3, y - scale * 1/6)
  context.lineTo(x + scale/3, y - scale * 2/6)
  context.lineTo(x + scale/3, y + scale * 2/6)
  context.lineWidth = 4
  context.strokeStyle = color
  context.stroke()

  var x1 = x - scale/2
  var y1 = y + scale/2
  context.save();
  context.translate(x1, y1)
  context.scale(1.3, 1);
  context.translate(-x1, -y1)
  context.beginPath()
  context.arc(x1, y1, scale/6, 0, 2 * Math.PI, true)
  context.fillStyle = color
  context.fill()

  context.restore()

  var x2 = x + scale/6
  var y2 = y + scale/3
  context.save();
  context.translate(x2, y2)
  context.scale(1.3, 1);
  context.translate(-x2, -y2)
  context.beginPath()
  context.arc(x2, y2, scale/6, 0, 2 * Math.PI, true)
  context.fillStyle = color
  context.fill()
  context.restore()
  context.restore()
}

iconRenderUtils.drawMusicIcon = function(context, x, y, scale, color, key_display, mute) {
  context.save()

  context.beginPath()
  context.moveTo(x - scale * 0.3- scale/2 * 0.75, y - scale/2 * 0.6)
  context.lineTo(x- scale * 0.3, y - scale/2 * 0.6)
  context.lineTo(x - scale * 0.3+ scale/2 * 0.75, y - scale * 0.6)
  context.lineTo(x- scale * 0.3 + scale/2  * 0.75, y + scale * 0.6)
  context.lineTo(x- scale * 0.3, y + scale/2* 0.6)
  context.lineTo(x- scale * 0.3 - scale/2 * 0.75, y + scale/2  * 0.6)
  context.fillStyle = color
  context.fill()
  if(mute) {
    context.beginPath()
    context.arc(x - scale * 0.3+ scale * 0.75, y, scale/2 * 0.45, 0, 2 * Math.PI, true)
    context.moveTo(x - scale * 0.3+ scale  * 0.75- Math.cos(Math.PI/4) * scale/2 * 0.45, y - Math.cos(Math.PI/4) * scale/2 * 0.45)
    context.lineTo(x - scale * 0.3+ scale* 0.75+ Math.cos(Math.PI/4) * scale/2 * 0.45, y + Math.cos(Math.PI/4) * scale/2 * 0.405)
    context.lineWidth = 2
    context.strokeStyle = color
    context.stroke()
  } else {
    context.beginPath()
    context.arc(x - scale * 0.3+ scale * 0.4, y, scale/2 * 0.6, -Math.PI/3,Math.PI/3, false)
    context.lineWidth = 2
    context.strokeStyle = color
    context.stroke()
    context.beginPath()
    context.arc(x- scale * 0.3 + scale * 0.4, y, scale/2, -Math.PI/3,Math.PI/3, false)
    context.stroke()
  }
  context.restore()
}

iconRenderUtils.drawFullscreenIcon = function(context, x, y, scale, color, key_display) {
  context.save()
  context.beginPath()
  context.globalAlpha /= 2
  context.rect(x - scale * 3/4, y - scale * 3/4, scale * 3/2, scale * 3/2)
  context.strokeStyle = color
  context.fillStyle = color
  context.lineWidth = 2
  context.stroke()
  context.globalAlpha *= 2
  context.beginPath()
  context.moveTo(x - scale * 1/2, y - scale * 1/2)
  context.lineTo(x - scale * 0/8, y - scale * 1/2)
  context.lineTo(x - scale * 1/2, y - scale * 0/8)
  context.closePath()
  context.fill()
  context.beginPath()
  context.moveTo(x + scale * 1/2, y + scale * 1/2)
  context.lineTo(x + scale * 0/8, y + scale * 1/2)
  context.lineTo(x + scale * 1/2, y + scale * 0/8)
  context.closePath()
  context.fill()
  context.beginPath()
  context.moveTo(x - scale * 1/2, y - scale * 1/2)
  context.lineTo(x + scale * 1/2, y + scale * 1/2)
  context.stroke()
  context.restore()
}

module.exports = iconRenderUtils;

},{"../load/save_data.js":69}],78:[function(require,module,exports){
var constants = require('../data/constants.js');
var levelData = require('../data/level_data.js');
var saveData = require('../load/save_data.js');

var levelPreviewRenderUtils = {};

levelPreviewRenderUtils.drawLevelObstaclesWithinRect = function(context, level_name, x, y, w, h, border_color) {

  context.save()
  context.shadowBlur = 0
  context.beginPath()
  context.rect(x - w/2, y - h/2, w, h)
  context.clip()
  context.beginPath()
  context.rect(x - w/2, y - h/2, w, h)
  context.save();
  context.globalAlpha *= 0.3
  context.fillStyle = border_color
  context.fill()
  context.restore();
  var polygons = null
  if (saveData.difficultyMode == "easy") {
    polygons = levelData.levels[level_name].obstacle_v_easy
  }
  if (!polygons) {
    polygons = levelData.levels[level_name].obstacle_v
  }

  if(!polygons) return
  for(var i = 0; i < polygons.length; i++) {
    context.beginPath()
    context.moveTo(x - w/2 + polygons[i][0][0]/constants.levelWidth * w, y - h/2 + polygons[i][0][1]/(constants.levelHeight) * h)
    for(var j = 1; j < polygons[i].length; j++) {
      context.lineTo(x - w/2 + polygons[i][j][0]/constants.levelWidth * w, y -h/2 +  polygons[i][j][1]/(constants.levelHeight) * h)
    }
    context.closePath()
    context.fillStyle = "black"
    context.strokeStyle = border_color
    context.lineWidth = 2
    context.stroke()
    context.fill()
  }

  context.restore()
  context.save()
  context.beginPath()
  context.shadowBlur = 0
  context.rect(x - w/2, y - h/2, w, h)
  context.lineWidth = 2
  context.strokeStyle = border_color
  context.stroke()
  context.restore()
};

module.exports = levelPreviewRenderUtils;

},{"../data/constants.js":13,"../data/level_data.js":16,"../load/save_data.js":69}],79:[function(require,module,exports){
var renderUtils = require('../render/utils.js');

var objectRenderUtils = {};

objectRenderUtils.drawMultiPowerup = function (context, x, y, prog) {
  renderUtils.drawSprite(context, x + 1, y, 0, 20, 20, "multi_powerup")
  context.strokeStyle = "white"
  context.lineWidth = 2;
  context.save();
  context.globalAlpha *= 0.5;
  context.beginPath();
  context.arc(x, y, 15, -.5* Math.PI, -.5 * Math.PI + 0.001, true)
  context.stroke();
  context.restore();
  context.beginPath();
  context.arc(x, y, 15, -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * 0.999 * (1 - prog), true)
  context.stroke();
};

objectRenderUtils.drawMultiFragment = function (context, x, y, angle) {
  renderUtils.drawSprite(context, x, y, angle, 12, 12, "multi")
};

module.exports = objectRenderUtils;

},{"../render/utils.js":83}],80:[function(require,module,exports){
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var renderUtils = require('../render/utils.js');
var sprites = require('../render/sprites.js');
var uiRenderUtils = require('../render/ui.js');

var questRenderUtils = {};

questRenderUtils.draw_quest_button = function(ctx, x, y, r, type) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI, false);
  ctx.fillStyle = "#000"
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x, y, r - 8, 0, 2 * Math.PI, false);
  ctx.lineWidth = 4;
  ctx.strokeStyle = "white";
  ctx.stroke();
  if (type == "beat_hive") {
    uiRenderUtils.drawTessellationSign(ctx, 1, x, y, r * 0.6, true, 0);
    ctx.beginPath()
    ctx.lineWidth = 6
    ctx.moveTo(x - r * 0.4, y - r * 0.4)
    ctx.lineTo(x + r * 0.4, y + r * 0.4)
    ctx.moveTo(x + r * 0.4, y - r * 0.4)
    ctx.lineTo(x - r * 0.4, y + r * 0.4)
    ctx.strokeStyle = constants.colors["impulse_blue"]
    ctx.stroke();
  }
  if (type == "final_boss") {
    uiRenderUtils.drawTessellationSign(ctx, 4, x, y, r * 0.6, true, 0);
    ctx.beginPath()
    ctx.lineWidth = 6
    ctx.moveTo(x - r * 0.4, y - r * 0.4)
    ctx.lineTo(x + r * 0.4, y + r * 0.4)
    ctx.moveTo(x + r * 0.4, y - r * 0.4)
    ctx.lineTo(x - r * 0.4, y + r * 0.4)
    ctx.strokeStyle = constants.colors["impulse_blue"]
    ctx.stroke();
  }
  if (type == "first_gold") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y, 0, r * 0.8, r * 0.8, "gold_trophy")
  }

  if (type == "combo") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()

    renderUtils.drawSprite(ctx, x, y - r/4, 0, r * 0.4, r * 0.4, "player_normal")


    ctx.beginPath()
    ctx.arc(x, y - r/2, r * 0.75, Math.PI/3, 2 * Math.PI/3, false);
    ctx.strokeStyle = constants.colors["impulse_blue"]
    ctx.stroke();
    var angles_to_draw = [Math.PI/2, Math.PI * 0.36, Math.PI * 0.64, Math.PI * 0.57, Math.PI * 0.43]
    for(var i = 0; i < angles_to_draw.length; i++) {
      var angle = angles_to_draw[i];
      renderUtils.drawImageWithRotation(ctx,
        x + r * 0.9 * Math.cos(angle),
        y - r / 2 + r * 0.9 * Math.sin(angle),
      angle, 10, 10, enemyData["stunner"].images["normal"]);
    }
  }

  if (type == "combo") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()

    renderUtils.drawSprite(ctx, x, y - r/4, 0, r * 0.4, r * 0.4, "player_normal")


    ctx.beginPath()
    ctx.arc(x, y - r/2, r * 0.75, Math.PI/3, 2 * Math.PI/3, false);
    ctx.strokeStyle = constants.colors["impulse_blue"]
    ctx.stroke();
    var angles_to_draw = [Math.PI/2, Math.PI * 0.36, Math.PI * 0.64, Math.PI * 0.57, Math.PI * 0.43]
    for(var i = 0; i < angles_to_draw.length; i++) {
      var angle = angles_to_draw[i];
      renderUtils.drawImageWithRotation(ctx,
        x + r * 0.9 * Math.cos(angle),
        y - r / 2 + r * 0.9 * Math.sin(angle),
      angle, 10, 10, enemyData["stunner"].images["normal"]);
    }
  }

  if (type == "high_roller") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()

    renderUtils.drawSprite(ctx, x, y - r/4, 0, r * 0.4, r * 0.4, "player_normal")

    ctx.beginPath()
    ctx.arc(x, y - r/2, r * 0.65, Math.PI/3, 2 * Math.PI/3, false);
    ctx.strokeStyle = constants.colors["impulse_blue"]
    ctx.stroke();
    var angles_to_draw = [Math.PI/2, Math.PI * 0.36, Math.PI * 0.64, Math.PI * 0.57, Math.PI * 0.43]
    ctx.fillStyle = constants.colors["gold"]
    ctx.textAlign = "center"
    ctx.font = "12px Open Sans"
    ctx.fillText("250K", x, y + r/2)

  }

  if (type.substring(0, 10) == "blitz_hive") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    var world = type.substring(10);
    if (world == "1") {
      renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "immunitas_glow", sprites.immunitasSprite)
    } else if (world == "2") {
      renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "consumendi_glow", sprites.consumendiSprite)
    } else if (world == "3") {
      renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "negligentia_glow", sprites.negligentiaSprite)
    } else if (world == "4") {
      renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "adrogantia_glow", sprites.adrogantiaSprite)
    }
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y, 0, r * 0.8, r * 0.8, "world"+type.substring(10)+"_timer")
  }

  if (type == "survivor") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y, 0, r * 0.4, r * 0.4, "player_normal")
    for(var i = 0; i < 8; i++) {
      var angle = Math.PI * 2 * i / 4 + Math.PI/4;
      renderUtils.drawImageWithRotation(ctx,
        x + r * 0.5 * Math.cos(angle),
        y + r * 0.5 * Math.sin(angle),
      Math.PI/2 + angle, 15, 15, enemyData["spear"].images["normal"]);
    }
  }

  if (type == "fast_time") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y, 0, r * 0.7, r * 0.7, "timer_icon")
  }

  if (type == "pacifist") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y + r * 0.2, 0, r * 0.4, r * 0.4, "player_normal")
    ctx.save();
    ctx.lineWidth = 3
    renderUtils.drawEllipse(ctx, x, y - r * 0.2, r/6, r/12, constants.colors["gold"])
    ctx.restore();
  }

  if (type == "beat_hard") {
    ctx.save()
    ctx.globalAlpha *= 0.1
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y, 0, r, r, "white_flower")
  }

  if (type == "untouchable") {
    ctx.save()
    ctx.globalAlpha *= 0.2
    renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
    ctx.restore()
    renderUtils.drawSprite(ctx, x, y, 0, r * 0.4, r * 0.4, "player_normal")
    ctx.save();
    ctx.lineWidth = 3
    renderUtils.drawEllipse(ctx, x, y, r * 0.45, r * 0.45, constants.colors["gold"])
    renderUtils.drawEllipse(ctx, x, y, r * 0.55, r * 0.55, constants.colors["gold"])
    ctx.restore();
  }
};

module.exports = questRenderUtils;

},{"../data/constants.js":13,"../data/enemy_data.js":15,"../render/sprites.js":81,"../render/ui.js":82,"../render/utils.js":83}],81:[function(require,module,exports){
var spriteData = require('../data/sprite_data.js');

var sprites = {};

function loadSprite(imageName)
{
    // create new image object
    var image = new Image();
    // load image
    image.src = imageName;
    // return image object
    return image;
}

sprites.playerSprite = loadSprite("art/sprites.png")
sprites.immunitasSprite = loadSprite("art/immunitas_sprite.png")
sprites.consumendiSprite = loadSprite("art/consumendi_sprite.png")
sprites.negligentiaSprite = loadSprite("art/negligentia_sprite.png")
sprites.adrogantiaSprite = loadSprite("art/adrogantia_sprite.png")
sprites.logoSprite = loadSprite("art/logo.png")
sprites.porcelainLogoSprite = loadSprite("art/porcelain_logo.png")

sprites.getTessellationSprite = function (world) {
  var spriteArray = [
    sprites.playerSprite,
    sprites.immunitasSprite,
    sprites.consumendiSprite,
    sprites.negligentiaSprite,
    sprites.adrogantiaSprite,
  ];
  if (world > spriteArray.length) {
    return null;
  }
  return spriteArray[world];
}

sprites.bgImages = {};

for(var bg in spriteData.bgFiles) {
  sprites.bgImages[bg] = loadSprite("art/"+spriteData.bgFiles[bg]+".png");
}

module.exports = sprites;

},{"../data/sprite_data.js":18}],82:[function(require,module,exports){
var constants = require('../data/constants.js');
var enemyRenderUtils = require('../render/enemy.js');
var renderUtils = require('../render/utils.js');
var sprites = require('../render/sprites.js');
var spriteData = require('../data/sprite_data.js');

var uiRenderUtils = {};

uiRenderUtils.drawEnemyButton = function(ctx, x, y, r, type) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI, false);
  ctx.fillStyle = "#000"
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x, y, r - 8, 0, 2 * Math.PI, false);
  ctx.lineWidth = 4;
  ctx.strokeStyle = "white";
  ctx.stroke();
  ctx.save();
  ctx.globalAlpha *= 0.2;
  renderUtils.drawSprite(ctx, x, y, 0, r * 1.2, r * 1.2, "white_glow")
  ctx.restore();
  enemyRenderUtils.drawEnemy(ctx, type, x, y, 30)
}

uiRenderUtils.getBgOpacity = function(world) {
  // Return opacity for the background in world menus.
  var opacity_array = [
    0.3,
    0.3,
    0.8,
    0.4,
    0.3
  ];
  return opacity_array[world];
}

uiRenderUtils.getLevelBgOpacity = function(world) {
  // Return opacity for the background in world menus.
  var opacity_array = [
    0.3,
    0.3,
    1,
    0.5,
    0.5
  ];
  return opacity_array[world];
};

uiRenderUtils.getWorldMapBgOpacity = function(world) {
  // Return opacity for the background in world-map state.
  var opacity_array = [
    spriteData.hive0_bg_opacity,
    0.05,
    0.1,
    0.1,
    0.1,
  ];
  return opacity_array[world];
}

uiRenderUtils.tessellateBg = function(ctx, xLow, yLow, xHigh, yHigh, spriteName) {
  var bg = sprites.bgImages[spriteName]
  var w = bg.width;
  var h = bg.height;
  ctx.save()
  ctx.beginPath();
  ctx.rect(xLow, yLow, xHigh - xLow, yHigh - yLow)
  if (spriteName.substring(0, 4) === "Hive" &&
      parseInt(spriteName.substring(5, 6)) !== 0) {
    ctx.fillStyle = "#111"//constants.colors['world ' + parseInt(spriteName.substring(5, 6))];
    ctx.fill();
    ctx.globalAlpha *= 0.5;
  }
  ctx.clip()
  var widthTiles = Math.ceil((xHigh - xLow) / w);
  var heightTiles = Math.ceil((yHigh - yLow) / h);
  for(var x = 0; x < widthTiles; x+=1) {
    for(var y = 0; y < heightTiles; y+=1) {
      var startX = (xHigh + xLow) / 2 - widthTiles * w / 2;
      var startY = (yHigh + yLow) / 2 - heightTiles * h / 2;
      ctx.drawImage(bg, 0, 0, w, h, startX + x * w, startY + y * h, w, h)
    }
  }
  ctx.restore()
}

uiRenderUtils.drawLogo = function(context, x, y, text, scale) {
  context.save()

  context.shadowColor = constants.colors["impulse_blue"]
  context.shadowBlur = 0
  context.fillStyle = "white"//constants.colors["impulse_blue"]

  var logoScale = scale ? scale : 1;
  context.drawImage(sprites.logoSprite, x - sprites.logoSprite.width/2 * logoScale, y - sprites.logoSprite.height * 0.75 * logoScale, sprites.logoSprite.width * logoScale, sprites.logoSprite.height * logoScale)

  if(text) {
    context.globalAlpha /= 2
    if (text === "BETA") {
      context.font = '18px Open Sans'
      context.textAlign = "right"
      context.fillText(text, x + sprites.logoSprite.width/2 * logoScale - 35, y + 40)
    } else {
      context.font = '20px Open Sans'
      context.textAlign = "center"
      context.fillText(text, x, y + 40)
    }
  }
  context.restore()
}

uiRenderUtils.drawPorcelainLogo = function(context, x, y, scale) {
  context.save()

  var logoScale = scale ? scale : 1;
  context.drawImage(sprites.porcelainLogoSprite, x - sprites.porcelainLogoSprite.width/2 * logoScale, y - sprites.porcelainLogoSprite.height * 0.75 * logoScale, sprites.porcelainLogoSprite.width * logoScale, sprites.porcelainLogoSprite.height * logoScale)

  context.restore()
}

uiRenderUtils.drawTessellationSign = function(context, tessellation, x, y, size, glow, rotate) {

  size *= spriteData.tessellationLogoFactor[tessellation]

  context.save()
  if(glow) {
    context.globalAlpha *= 0.5
    if(tessellation == 1) {
      renderUtils.drawSprite(context, x, y, (Math.PI/4), size * 2, size * 2,
        spriteData.tessellationGlowMap[tessellation], sprites.getTessellationSprite(parseInt(tessellation)))
    }
    renderUtils.drawSprite(context, x, y, (Math.PI/4), size * 1.5, size * 1.5,
      spriteData.tessellationGlowMap[tessellation], sprites.getTessellationSprite(parseInt(tessellation)))
  }

  context.restore()
  context.save()

  // set screen position
  context.translate(x, y);
  // set rotation
  var offset = (tessellation != 4 && tessellation != 2) ? Math.PI/4 : 0
  var angle = rotate ? rotate : 0
  context.rotate(angle + offset)
  renderUtils.drawSprite(context, 0, 0, 0, size, size, spriteData.tessellationLogoMap[tessellation], sprites.getTessellationSprite(parseInt(tessellation)))
  if(tessellation == 1) {
    context.beginPath()
    context.rect(-size/2*1.2, -size/2*1.2, size*1.2, size*1.2)
    context.lineWidth = Math.ceil(size/20)
    context.strokeStyle = constants.colors["boss "+tessellation]
    context.stroke()
  }
  context.restore()
}

uiRenderUtils.drawGrayTessellationSign = function(context, tessellation, x, y, size, glow, rotate) {

    size *= spriteData.tessellationLogoFactor[tessellation]

    context.save()

    // set screen position
    context.translate(x, y);
    // set rotation
    if(tessellation != 4 && tessellation != 2)
    context.rotate(Math.PI/4)
    renderUtils.drawSprite(context, 0, 0, 0, size, size, spriteData.tessellationGrayLogoMap[tessellation], sprites.getTessellationSprite(parseInt(tessellation)))
    if(tessellation == 1) {
      context.beginPath()
      context.rect(-size/2*1.2, -size/2*1.2, size*1.2, size*1.2)
      context.lineWidth = Math.ceil(size/20)
      context.strokeStyle = "gray"
      context.stroke()
    }
    context.restore()
}


uiRenderUtils.drawArrowKeys = function(context, x, y, size, color, keysArray) {
  context.save()

  context.shadowColor = color
  context.shadowBlur = 0
  renderUtils.drawRoundedRect(context, x, y-size, size * 0.9, size * 0.9, size * 0.2, color)
  renderUtils.drawRoundedRect(context, x - size, y, size * 0.9, size * 0.9, size * 0.2, color)
  renderUtils.drawRoundedRect(context, x, y, size * 0.9, size * 0.9, size * 0.2, color)
  renderUtils.drawRoundedRect(context, x + size, y, size * 0.9, size * 0.9, size * 0.2, color)

  context.fillStyle = color;
  context.font = (size * 0.4) + 'px Open Sans'
  context.textAlign = "center"
  if(keysArray) {
    context.fillText(keysArray[0], x, y - size * 1)
    context.fillText(keysArray[1], x - size, y + size * 0)
    context.fillText(keysArray[2], x, y + size * 0)
    context.fillText(keysArray[3], x + size, y + size * 0)
    uiRenderUtils.drawArrow(context, x, y - size * 0.8, size * 0.3, "up", color)
    uiRenderUtils.drawArrow(context, x - size, y + size * 0.2, size * 0.3, "left", color)
    uiRenderUtils.drawArrow(context, x, y + size * 0.2, size * 0.3, "down", color)
    uiRenderUtils.drawArrow(context, x + size, y + size * 0.2, size * 0.3, "right", color)
  } else {
    uiRenderUtils.drawArrow(context, x, y - size , size * 0.5, "up", color)
    uiRenderUtils.drawArrow(context, x - size, y , size * 0.5, "left", color)
    uiRenderUtils.drawArrow(context, x, y - 2, size * 0.5, "down", color)
    uiRenderUtils.drawArrow(context, x + size, y, size * 0.5, "right", color)
  }
  context.restore()
}

uiRenderUtils.drawBareMouse = function(context, x, y, w, h, color) {
  context.save()

  context.fillStyle = color
  renderUtils.drawRoundedRect(context, x, y, w, h, h*0.25, color)

  context.beginPath()
  context.moveTo(x - w/2, y - h/6)
  context.lineTo(x + w/2, y - h/6)
  context.moveTo(x, y - h/6)
  context.lineTo(x, y - h/2)

  context.lineWidth = 2
  context.strokeStyle = color
  context.stroke()
  context.restore()
}

uiRenderUtils.drawMouse = function(context, x, y, w, h, color) {
  context.save()
  context.shadowColor = color
  context.fillStyle = color
  /*context.font = "10px Open Sans"
  context.textAlign = "center"
  context.fillText("LEFT CLICK", x, y - w/2 - 30)*/
  context.shadowBlur = 0
  renderUtils.drawRoundedRect(context, x, y, w, h, h*0.2, color)
  context.clip()
  context.beginPath()
  context.rect(x - w/2, y - h/2, w/2, h/3)
  context.globalAlpha *= 0.5

  context.fill()
  context.restore()
  context.save()
  context.beginPath()
  context.moveTo(x - w/2, y - h/6)
  context.lineTo(x + w/2, y - h/6)
  context.moveTo(x, y - h/6)
  context.lineTo(x, y - h/2)

  context.lineWidth = 2
  context.strokeStyle = color
  context.stroke()
  context.restore()
}

uiRenderUtils.drawVProgressBar = function(context, x, y, w, h, prop, color, up) {


  context.save();
  context.shadowBlur = 0

  context.beginPath()
  context.rect(x - w * .5, y - h * .5, w, h)
  context.fillStyle ="black"
  context.fill()

  context.restore();
  context.save();
  context.beginPath()
  //context.shadowBlur = 20;
  //context.shadowColor = color
  context.rect(x - w * .5, y - h * .5, w , h)
  context.strokeStyle = color
  context.fillStyle = color
  context.lineWidth = 4
  context.save();
  context.globalAlpha /= 10
  context.fill()
  context.restore();
  context.stroke()
  context.beginPath()

  if(up) {
    context.rect(x - w * .5, y + h * .5 - prop * h, w, h * prop)
  } else {
    context.rect(x - w * .5, y - h * .5, w, h * prop)
  }

  context.fillStyle = color
  context.fill()
  context.restore()
}

uiRenderUtils.drawFullArrow = function(context, x, y, scale, color, dir) {
  context.save();
  context.translate(x, y);
  context.scale(scale, scale);
  if(dir == "left") {
    context.rotate(Math.PI/2);
  } else if(dir == "up") {
    context.rotate(2*Math.PI/2);
  } else if(dir == "right") {
    context.rotate(3*Math.PI/2);
  }
  context.beginPath();
  context.moveTo(-8, -12);
  context.lineTo(8, -12);
  context.lineTo(8, -2);
  context.lineTo(16, -2);
  context.lineTo(0, 13);
  context.lineTo(-16, -2);
  context.lineTo(-8, -2);
  context.closePath()

  context.fillStyle = color;
  context.fill();
  context.restore();
}

uiRenderUtils.drawArrow = function(context, x, y, size, dir, color, shadowed) {

  shadowed = shadowed == undefined ? false : shadowed
  context.save();
  context.translate(x, y);

  if(dir == "left") {
    context.rotate(Math.PI);
  } else if(dir == "up") {
    context.rotate(3*Math.PI/2);
  } else if(dir == "down") {
    context.rotate(Math.PI/2);
  }

  context.beginPath()
  context.moveTo( Math.cos(0) * size/2,  Math.sin(0) * size/2)
  context.lineTo( Math.cos(Math.PI*2/3) * size/2,  Math.sin(Math.PI*2/3) * size/2)
  context.lineTo( Math.cos(Math.PI*4/3) * size/2,  Math.sin(Math.PI*4/3) * size/2)
  context.closePath()
  context.fillStyle = color
  if(shadowed) {
    context.shadowBlur = 10
    context.shadowColor = color
  } else {
    context.shadowBlur = 0
  }
  context.fill()

  context.restore()
}

uiRenderUtils.drawProgressBar = function(context, x, y, w, h, prop, color, bcolor, noborder, alpha) {
  context.save()
  if (alpha) context.globalAlpha *= alpha
  context.beginPath()
  context.rect(x - w * .5, y - h * .5, w * prop, h)
  context.fillStyle = color
  context.fill()
  context.restore()

  if(!noborder) {
    context.beginPath()
    context.rect(x - w * .5, y - h * .5, w , h)
    context.strokeStyle = bcolor ? bcolor : "black"
    context.lineWidth = 2
    context.stroke()
  }
}


uiRenderUtils.drawProgCircle = function(context, x, y, r, prog, color, width) {
  context.beginPath()
  context.arc(x*constants.drawFactor, y*constants.drawFactor, (r*constants.drawFactor) * 2, -.5* Math.PI, -.5 * Math.PI + 1.999*Math.PI * prog, true)
  context.lineWidth = width ? width : 2
  context.strokeStyle = color
  context.stroke()
}

uiRenderUtils.bulkDrawProgCircle = function(context, x, y, r, prog) {
  context.moveTo(x*constants.drawFactor, y*constants.drawFactor - (r*constants.drawFactor) * 2)
  context.arc(x*constants.drawFactor,
              y*constants.drawFactor,
              (r*constants.drawFactor) * 2, -.5* Math.PI, -.5 * Math.PI + 2*Math.PI * 0.999 * (prog), true)
}

module.exports = uiRenderUtils;

},{"../data/constants.js":13,"../data/sprite_data.js":18,"../render/enemy.js":74,"../render/sprites.js":81,"../render/utils.js":83}],83:[function(require,module,exports){
var sprites = require('../render/sprites.js');
var spriteData = require('../data/sprite_data.js');

var renderUtils = {};

renderUtils.drawRoundedRect = function(context, x, y, w, h, r, color) {
  context.save()
  context.shadowColor = color
  context.shadowBlur = 0
  context.beginPath();
  context.moveTo(x - w/2 + r, y - h/2);
  context.arcTo(x+w/2, y - h/2,   x+w/2, y+h/2, r);
  context.arcTo(x+w/2, y + h/2, x - w/2,   y+h/2, r);
  context.arcTo(x - w/2,   y+h/2, x - w/2,   y - h/2,   r);
  context.arcTo(x - w/2,   y - h/2,   x+w/2, y - h/2,   r);
  context.closePath();
  context.strokeStyle = color
  context.lineWidth = 2
  context.stroke()
  context.restore()
}

// shape is {type: circle/ polygon, r: radius_factor, vertices: [[0-1, 0-1], [0-1, 0-1]]}
renderUtils.drawShape = function(context, x, y, shape, scale, color, alpha, rotate, interior_color) {

  alpha = typeof alpha !== 'undefined' ? alpha: 1;
  rotate = typeof rotate !== 'undefined' ? rotate: 0;

  context.beginPath()
  context.save()
  if (rotate != 0) {
    context.translate(x, y);
    context.rotate(rotate);
    context.translate(-x, -y);
  }
  if(shape.type == "circle") {
    context.arc(x + shape.x, y + shape.y, scale * shape.r, 0, 2 * Math.PI * 0.999)
  }

  if(shape.type == "polygon") {
    context.moveTo(x + (shape.x + shape.vertices[0][0] * shape.r) * scale,
      y + (shape.y + shape.vertices[0][1]  * shape.r) * scale)
    for(var n = 1; n < shape.vertices.length; n++)
    {
      context.lineTo(x + (shape.x + shape.vertices[n][0] * shape.r) * scale,
        y + (shape.y + shape.vertices[n][1]  * shape.r) * scale)
    }
    context.closePath()
  }
  context.globalAlpha *= alpha

  context.fillStyle = color
  if(interior_color && interior_color != "none") {
    context.fillStyle = interior_color
  } else {
    context.globalAlpha /= 3
  }
  if(interior_color != "none")
    context.fill()
  if(!interior_color || interior_color == "none")
    context.globalAlpha *= 3
  context.strokeStyle = color
  context.lineWidth = 2
  context.stroke()
  context.restore()
}

renderUtils.drawImageWithRotation = function(ctx, x, y, rotation, actualWidth, actualHeight, image) {
  var w = image.width;
  var h = image.height;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.drawImage(image, 0, 0, w, h, -actualWidth/2, -actualHeight/2, actualWidth, actualHeight);
  ctx.restore();
}

renderUtils.drawEllipse = function(ctx, cx, cy, rx, ry, style) {
  ctx.save(); // save state
  ctx.beginPath();
  ctx.translate(cx-rx, cy-ry);
  ctx.scale(rx, ry);
  ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);
  ctx.restore(); // restore to original state
  ctx.save();
  if(style)
    ctx.strokeStyle=style;
  ctx.stroke();
  ctx.restore();
}

renderUtils.convertCanvasToGrayscale = function(canvas, opacity) {
  var canvasContext = canvas.getContext('2d');
  var imgPixels = canvasContext.getImageData(0, 0, canvas.width, canvas.height);

  for(var y = 0; y < imgPixels.height; y++){
       for(var x = 0; x < imgPixels.width; x++){
            var i = (y * 4) * imgPixels.width + x * 4;
            var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
            imgPixels.data[i] = avg;
            imgPixels.data[i + 1] = avg;
            imgPixels.data[i + 2] = avg;
            imgPixels.data[i + 3] = imgPixels.data[i + 3] ? opacity : 0;
       }
  }
  var gray_canvas = document.createElement('canvas');
  gray_canvas.width = imgPixels.width
  gray_canvas.height = imgPixels.height
  var gray_canvas_ctx = gray_canvas.getContext('2d');
  gray_canvas_ctx.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);
  return gray_canvas;
}

renderUtils.drawSprite = function(ctx, x, y, rotation, actualWidth, actualHeight, spriteName, imageObject) {

    imageObject = typeof imageObject !== 'undefined' ? imageObject: sprites.playerSprite;
    var w = imageObject.width;
    var h = imageObject.height;

    ctx.save();
    // set screen position
    ctx.translate(x, y);
    // set rotation
    ctx.rotate(rotation);
    // set scale value

    // draw image to screen drawImage(imageObject, sourceX, sourceY, sourceWidth, sourceHeight,
    // destinationX, destinationY, destinationWidth, destinationHeight)
    ctx.drawImage(imageObject, spriteData.spriteSheetData[spriteName][0],
      spriteData.spriteSheetData[spriteName][1],
      spriteData.spriteSheetData[spriteName][2],
      spriteData.spriteSheetData[spriteName][3],
      -actualWidth/2, -actualHeight/2, actualWidth, actualHeight);
    ctx.restore();
}

module.exports = renderUtils;

},{"../data/sprite_data.js":18,"../render/sprites.js":81}],84:[function(require,module,exports){
var CheckBox = function(x, y, w, h, color, toggleFunction, checked) {
  this.x = x
  this.y = y
  this.w = w
  this.h = h
  this.color = color
  this.active = true
  this.checked = checked ? checked: false
  this.toggleFunction = toggleFunction
}

CheckBox.prototype.draw = function(context) {
  context.beginPath()
  context.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
  if(this.checked) {
    context.moveTo(this.x - this.w/2, this.y - this.h/2)
    context.lineTo(this.x + this.w/2, this.y + this.h/2)
    context.moveTo(this.x - this.w/2, this.y + this.h/2)
    context.lineTo(this.x + this.w/2, this.y - this.h/2)
  }
  context.strokeStyle = this.color
  context.lineWidth = 2
  context.stroke()
}

CheckBox.prototype.on_click = function(x, y) {
  if(x > this.x - this.w/2 && x < this.x + this.w/2 && y > this.y - this.h/2 && y < this.y + this.h/2) {
    this.checked = !this.checked
    this.toggleFunction(this.checked)
  }
}

module.exports = CheckBox;

},{}],85:[function(require,module,exports){
var CheckBox = require('../ui/checkbox.js');
var ImpulseButton = require('../ui/impulse_button.js');

CheckboxOptionButton.prototype = new ImpulseButton()

CheckboxOptionButton.prototype.constructor = CheckboxOptionButton

function CheckboxOptionButton(text, x, y, w, h, color, hcolor, action, check_verifier) {
  this.text = text;
  this.init(x, y, w, h, null, false, color)
  this.hcolor = hcolor
  this.checkbox = new CheckBox(this.x + this.w/2 - 20, this.y, 20, 20, this.color);
  this.checkbox.checked = check_verifier();
  this.change_checkbox_on_click = true;

  this.action = function() {
    action(this.checkbox.checked);
    if (this.change_checkbox_on_click) {
      this.checkbox.checked = !this.checkbox.checked;
    }
  }
}

CheckboxOptionButton.prototype.additional_draw = function(ctx) {
  ctx.save();

  ctx.textAlign = 'left'
  ctx.font = '18px Open Sans';
  ctx.fillStyle = this.mouseOver ? this.hcolor : this.color;
  ctx.fillText(this.text, this.x - this.w/2 + 10, this.y + 7);
  this.checkbox.color = this.mouseOver ? this.hcolor : this.color;
  this.checkbox.draw(ctx);
  ctx.restore();
}

module.exports = CheckboxOptionButton;

},{"../ui/checkbox.js":84,"../ui/impulse_button.js":88}],86:[function(require,module,exports){
var _ = require('lodash');
var box_2d = require('../vendor/box2d.js');
var constants = require('../data/constants.js');
var controls = require('../core/controls.js');
var debugVars = require('../data/debug.js');
var dom = require('../core/dom.js');
var enemyData = require('../data/enemy_data.js');
var enemyRenderUtils = require('../render/enemy.js');
var game_engine = require('../core/game_engine.js');
var gsKeys = constants.gsKeys;
var layers = require('../core/layers.js');
var levelData = require('../data/level_data.js');
var music_player = require('../core/music_player.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');
var utils = require('../core/utils.js');

var CheckboxOptionButton = require('../ui/checkbox_option_button.js');
var Fader = require('../game_states/fader_util.js');
var HiveNumbers = require('../load/hive_numbers.js');
var IconButton = require('../ui/icon_button.js');
var MessageBox = require('../ui/message_box.js');
var SliderOptionButton = require('../ui/slider_option_button.js');
var SmallButton = require('../ui/small_button.js');
var SmallEnemyButton = require('../ui/small_enemy_button.js');

var DialogBox = function() {

}

DialogBox.prototype.isDialogBox = true;

DialogBox.prototype.init = function(w, h) {
  this.w = w
  this.h = h
  this.x = constants.canvasWidth/2
  this.y = constants.canvasHeight/2
  this.buttons = []
  this.fader = new Fader({
    "fade_in": 500,
    "fade_out": 250
  });
  this.solid = false;
}

DialogBox.prototype.process = function(dt) {
  this.fader.process(dt);
}

DialogBox.prototype.draw = function(ctx) {
  if (debugVars.hide_pause_menu) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h);

  if (this.solid) {
    ctx.fillStyle = constants.colors['menuBg'];
  } else {
    ctx.globalAlpha *= 0.8;
    ctx.fillStyle = "#000000";
  }
  ctx.fill();
  ctx.restore();
  ctx.save();
  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  }

  this.additional_draw(ctx)

  ctx.restore();
}

DialogBox.prototype.additional_draw = function(ctx) {}

DialogBox.prototype.on_mouse_move = function(x, y) {}
DialogBox.prototype.on_mouse_down = function(x, y) {}
DialogBox.prototype.on_mouse_up = function(x, y) {}
DialogBox.prototype.on_click = function(x, y) {}
DialogBox.prototype.on_right_mouse_down = function(x, y) {}
DialogBox.prototype.on_right_mouse_up = function(x, y) {}
DialogBox.prototype.on_right_click = function(x, y) {}
DialogBox.prototype.on_key_down = function(x, y) {}
DialogBox.prototype.on_key_up = function(x, y) {}

PauseMenu.prototype = new DialogBox()

PauseMenu.prototype.constructor = PauseMenu

PauseMenu.prototype.isPauseMenu = true;

function PauseMenu(level, world_num, game_numbers, game_state, visibility_graph) {
  this.level = level
  this.game_numbers = game_numbers
  this.game_state = game_state
  this.world_num = world_num
  this.level_name = this.level.level_name
  this.is_boss_level = this.level_name.slice(0, 4) == "BOSS"
  this.visibility_graph = visibility_graph
  this.init(800, 600)
  this.button_color = "#999";
  this.hover_color = "#fff";
  this.buttons = []

  this.add_buttons()
}

PauseMenu.prototype.add_buttons = function() {
  var buttons_to_add = [];

  buttons_to_add.push({
    text: "OPTIONS",
    action: function () {
      _this.fader.set_animation("fade_out", function() {
        game_engine.set_dialog_box(new OptionsMenu(_this))
      });
    }
  });

  buttons_to_add.push({
    text: "CONTROLS",
    action: function () {
      _this.fader.set_animation("fade_out", function() {
        game_engine.set_dialog_box(new ControlsMenu(_this))
      });
    }
  });

  if(this.world_num != 0) {

    if(!this.level.main_game) {
      buttons_to_add.push({
        text: "RETRY",
        action: function () {
          _this.restart_practice();
        }
      });

      buttons_to_add.push({
        text: "QUIT",
        action: function () {
          _this.quit_practice()
        }
      });
    } else {
      buttons_to_add.push({
        text: "SAVE & QUIT",
        action: function () {
          _this.save_and_quit_main_game()
        }
      });

      buttons_to_add.push({
        text: "QUIT",
        action: function () {
          _this.quit_main_game()
        }
      });
    }
  } else {
    buttons_to_add.push({
      text: this.world_num == 0 && saveData.firstTime ? "SKIP TUTORIAL" : "QUIT",
      action: function () {
        _this.quit_tutorial()
      }
    });
  }

  var _this = this;
  _.forEach(buttons_to_add, function(button_data, i) {
    var height = 292 + 36 * i;
    _this.buttons.push(new SmallButton(button_data.text, 24,  _this.x, height, 200, 36, _this.button_color, _this.hover_color,
      button_data.action));
  });

  // resume button.
  this.resume_button = new IconButton("CLOSE", 18, this.x + this.w / 2 - 20, this.y - this.h/2 + 30,
    150, 100, this.button_color, this.hover_color, function(_this) { return function() {
    _this.game_state.toggle_pause()
  }}(this), "close")

  this.buttons.push(this.resume_button)
}

PauseMenu.prototype.additional_draw = function(ctx) {
  ctx.save()
  ctx.beginPath()
  ctx.textAlign = "center";

  ctx.font = '48px Open Sans Bold';
  ctx.shadowBlur = 0;
  ctx.shadowColor = this.button_color;
  ctx.fillStyle = this.button_color;
  ctx.fillText("PAUSED", this.x, this.y - this.h/2 + 130)

  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].draw(ctx)
  }
  ctx.restore()
}

PauseMenu.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_mouse_move(x,y)
  }
}

PauseMenu.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x,y)
  }
}

PauseMenu.prototype.quit_practice = function() {
  game_engine.switch_game_state(gsKeys.REWARD_GAME_STATE, {
    hive_numbers: this.game_state.hive_numbers,
    main_game: this.game_state.main_game,
    game_args: {
      game_numbers: this.game_state.game_numbers,
      level: this.game_state.level,
      world_num: this.game_state.world_num,
      visibility_graph: this.game_state.visibility_graph,
      victory: false
    }
  });
  game_engine.clear_dialog_box()
}
PauseMenu.prototype.restart_practice = function() {
  layers.bgCtx.translate(constants.sideBarWidth, 0)//allows us to have a topbar
  this.level.impulse_game_state= null
  this.level.draw_bg(layers.bgCtx)
  layers.bgCtx.translate(-constants.sideBarWidth, 0)
  var hive_numbers = new HiveNumbers(this.game_state.world_num, false)
  game_engine.switch_game_state(gsKeys.IMPULSE_GAME_STATE, {
    world: this.game_state.world_num,
    level: this.level,
    visibility_graph: this.visibility_graph,
    hive_numbers: hive_numbers,
    main_game: false
  });
  game_engine.clear_dialog_box()
}

PauseMenu.prototype.quit_main_game = function() {
  saveData.clearSavedPlayerGame();
  game_engine.switch_game_state(gsKeys.MAIN_GAME_SUMMARY_STATE, {
    world_num: this.game_state.world_num,
    victory: false,
    hive_numbers: this.game_state.hive_numbers,
    visibility_graph: null,
    save_screen: false,
    just_saved: false
  });
  game_engine.clear_dialog_box()
}

PauseMenu.prototype.quit_tutorial = function() {
  game_engine.switch_game_state(gsKeys.REWARD_GAME_STATE, {
    hive_numbers: this.game_state.hive_numbers,
    main_game: this.game_state.main_game,
    game_args: {
      game_numbers: this.game_state.game_numbers,
      level: this.game_state.level,
      world_num: this.game_state.world_num,
      visibility_graph: this.game_state.visibility_graph,
      is_tutorial: true,
      first_time_tutorial: saveData.firstTime,
      victory: true,
      skipped: true
    }
  });
  game_engine.clear_dialog_box()
}

PauseMenu.prototype.save_and_quit_main_game = function() {
  saveData.savePlayerGame(this.game_state.hive_numbers);
  game_engine.switch_game_state(gsKeys.MAIN_GAME_SUMMARY_STATE, {
    world_num: this.game_state.world_num,
    victory: false,
    hive_numbers: this.game_state.hive_numbers,
    visibility_graph: null,
    save_screen: true,
    just_saved: true
  });
  game_engine.clear_dialog_box()
}

PauseMenu.prototype.on_key_down = function(keyCode) {
  if(keyCode == controls.keys.PAUSE || keyCode == controls.keys.SECONDARY_PAUSE) {
    this.game_state.toggle_pause()
  }
}

OptionsMenu.prototype = new DialogBox()

OptionsMenu.prototype.constructor = OptionsMenu
OptionsMenu.prototype.isOptionsMenu = true;

function OptionsMenu(previous_menu) {
  this.init(800, 600)
  this.game_state = previous_menu.game_state
  this.world_num = previous_menu.world_num
  this.previous_menu = previous_menu;

  this.options_y_line_up = 153
  this.button_color = "#999";
  this.hover_color = "#fff";

  if (this.previous_menu.isTitleState) {
    this.solid = true;
  }

  this.back_button = new IconButton("BACK", 16, this.x, this.y - this.h/2 + 560, 60, 65, this.button_color, this.hover_color, function(_this) { return function() {
  _this.fader.set_animation("fade_out", function() {
    if(_this.previous_menu.isPauseMenu) {
      _this.previous_menu.add_buttons()
      game_engine.set_dialog_box(_this.previous_menu)
      _this.previous_menu.fader.set_animation("fade_in");
    } else {
      if (_this.previous_menu.isTitleState) {
        _this.previous_menu.fader.set_animation("fade_in");
      }
      game_engine.clear_dialog_box()
    }
  });

  }}(this), "back");

  var controls_x_value = this.x
  if (this.previous_menu.isTitleState) {
    this.delete_button= new IconButton("DELETE GAME DATA", 20, this.x + 150, this.y + 120, 200, 100, this.button_color, this.hover_color, function(_this) { return function() {
      _this.fader.set_animation("fade_out", function() {
        game_engine.set_dialog_box(new DeleteDataDialog(_this))
      });
    }}(this), "delete")
    this.buttons.push(this.delete_button)
    this.controls_button = new IconButton("CHANGE CONTROLS", 20, this.x - 150, this.y + 120, 200, 100, this.button_color, this.hover_color, function(_this) { return function() {
      _this.fader.set_animation("fade_out", function() {
        game_engine.set_dialog_box(new ControlsMenu(_this))
      });
    }}(this), "controls")
    this.buttons.push(this.controls_button)
  }
  this.buttons.push(this.back_button)

  this.current_help_text = ""

  var button_width = 300;

  this.music_button = new SliderOptionButton("GAME MUSIC", this.x, this.y - this.h/2 + this.options_y_line_up, button_width, 30, this.button_color, this.hover_color, function(value) {
    music_player.change_bg_volume(Math.ceil(Math.pow(value, 2) * 100), true) // sqrt it to get a better curve
  }, Math.pow(saveData.optionsData.bg_music_volume / 100, 0.5));
  this.music_button.special_mode = music_player.mute
  this.music_button.add_hover_overlay(new MessageBox("option_game_music", "white", this.world_num))
  this.buttons.push(this.music_button)

  this.effects_button = new SliderOptionButton("SOUND EFFECTS", this.x, this.y - this.h/2 + this.options_y_line_up + 30, button_width, 30, this.button_color, this.hover_color, function(value) {
    music_player.change_effects_volume(Math.ceil(Math.pow(value, 3) * 100)) // sqrt it to get a better curve
  }, Math.pow(saveData.optionsData.effects_volume / 100, 0.333));
  this.effects_button.special_mode = music_player.mute
  this.effects_button.add_hover_overlay(new MessageBox("option_sound_effects", "white", this.world_num))
  this.buttons.push(this.effects_button)

  this.fullscreen_button = new CheckboxOptionButton("FULLSCREEN", this.x, this.y - this.h/2 + this.options_y_line_up + 60, button_width, 30, this.button_color, this.hover_color, function(on) {
    game_engine.toggleFullScreen();
  }, function() {
    return dom.IsInFullScreen()
  });
  this.fullscreen_button.add_hover_overlay(new MessageBox("option_fullscreen", "white", this.world_num))
  this.fullscreen_button.change_checkbox_on_click = false;
  this.buttons.push(this.fullscreen_button)

  button = new CheckboxOptionButton("PARTICLE EFFECTS", this.x, this.y - this.h/2 + this.options_y_line_up + 90, button_width, 30, this.button_color, this.hover_color, function(on) {
    saveData.optionsData.explosions = !saveData.optionsData.explosions
    saveData.saveGame();
  }, function() {
    return saveData.optionsData.explosions;
  });
  button.add_hover_overlay(new MessageBox("option_particle_effects", "white", this.world_num))
  this.buttons.push(button)

  button = new CheckboxOptionButton("SCORE LABELS", this.x, this.y - this.h/2 + this.options_y_line_up + 120, button_width, 30, this.button_color, this.hover_color, function(on) {
    saveData.optionsData.score_labels = !saveData.optionsData.score_labels
    saveData.saveGame();
  }, function() {
    return saveData.optionsData.score_labels;
  });
  button.add_hover_overlay(new MessageBox("option_score_labels", "white", this.world_num))
  this.buttons.push(button)

  button = new CheckboxOptionButton("MULTIPLIER DISPLAY", this.x, this.y - this.h/2 + this.options_y_line_up + 150, button_width, 30, this.button_color, this.hover_color, function(on) {
    saveData.optionsData.multiplier_display = !saveData.optionsData.multiplier_display
    saveData.saveGame();
  }, function() {
    return saveData.optionsData.multiplier_display;
  });
  button.add_hover_overlay(new MessageBox("option_multiplier_display", "white", this.world_num))
  this.buttons.push(button)

  button = new CheckboxOptionButton("IMPULSE SHADOW", this.x, this.y - this.h/2 + this.options_y_line_up + 180, button_width, 30, this.button_color, this.hover_color, function(on) {
    saveData.optionsData.impulse_shadow = !saveData.optionsData.impulse_shadow
    saveData.saveGame();
  }, function() {
    return saveData.optionsData.impulse_shadow;
  });
  button.add_hover_overlay(new MessageBox("option_impulse_shadow", "white", this.world_num))
  this.buttons.push(button)
  var me = this;
  if(this.game_state && this.game_state.isImpulseGameState && this.game_state.level.main_game && this.world_num > 0 && saveData.difficultyMode == "normal") {
    button = new CheckboxOptionButton("SPEED RUN COUNTDOWN", this.x, this.y - this.h/2 + this.options_y_line_up + 210, button_width, 30, this.button_color, this.hover_color, function(on) {
      saveData.optionsData.speed_run_countdown = !saveData.optionsData.speed_run_countdown;
      saveData.saveGame();
    }, function() {
      return saveData.optionsData.speed_run_countdown;
    });
    button.add_hover_overlay(new MessageBox("option_speed_run", "white", this.world_num))
    this.buttons.push(button)
  }

  this.fader.set_animation("fade_in");
}

OptionsMenu.prototype.additional_draw = function(ctx) {

  ctx.save()
  ctx.textAlign = "center"
  ctx.font = '48px Open Sans Bold';
  ctx.shadowBlur = 0;
  ctx.shadowColor = this.button_color;
  ctx.fillStyle = this.button_color;
  ctx.fillText("OPTIONS", this.x, this.y - this.h/2 + 100)
  ctx.shadowBlur = 0
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].draw(ctx)
  }

  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].post_draw(ctx)
  }

  ctx.textAlign = 'center'
  if(this.current_help_text) {
    ctx.font = '14px Open Sans'
    if (this.game_state.isImpulseGameState && this.game_state.level.main_game ) {
      ctx.fillText(this.current_help_text, this.x, this.y - this.h/2 + this.options_y_line_up + 180)
    } else {
      ctx.fillText(this.current_help_text, this.x, this.y - this.h/2 + this.options_y_line_up + 150)
    }

  }

  //this.music_volume_slider.draw(ctx)
  //this.effects_volume_slider.draw(ctx)

  ctx.restore()
}

OptionsMenu.prototype.sendFullscreenSignal = function(isFullscreen) {
  this.fullscreen_button.checkbox.checked = isFullscreen;
}

OptionsMenu.prototype.sendMuteSignal = function(isMute) {
  this.effects_button.special_mode = isMute;
  this.music_button.special_mode = isMute;
}


OptionsMenu.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_mouse_move(x,y)
  }

  //this.music_volume_slider.on_mouse_move(x,y)
  //this.effects_volume_slider.on_mouse_move(x,y)
}

OptionsMenu.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x,y)
  }
  //this.music_volume_slider.on_click(x,y)
  //this.effects_volume_slider.on_click(x,y)
}

OptionsMenu.prototype.on_key_down = function(keyCode) {
  if(keyCode == controls.keys.PAUSE || keyCode == controls.keys.SECONDARY_PAUSE) {
    this.game_state.toggle_pause()
  }
};

OptionsMenu.prototype.on_mouse_down = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_mouse_down(x,y)
  }
  //this.music_volume_slider.on_mouse_down(x,y)
  //this.effects_volume_slider.on_mouse_down(x,y)
}
OptionsMenu.prototype.on_mouse_up = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_mouse_up(x,y)
  }
  //this.music_volume_slider.on_mouse_up(x,y)
  //this.effects_volume_slider.on_mouse_up(x,y)
  //music_player.change_bg_volume(this.convert_slider_value(this.music_volume_slider.value))
  //music_player.change_effects_volume(this.convert_slider_value(this.effects_volume_slider.value))
}

OptionsMenu.prototype.convert_slider_value = function(value) {
  return Math.pow(Math.E, value * Math.log(100))
}

ControlsMenu.prototype = new DialogBox()

ControlsMenu.prototype.constructor = ControlsMenu

function ControlsMenu(previous_menu) {
  this.init(800, 600)
  this.game_state = previous_menu.game_state
  this.previous_menu = previous_menu

  this.button_color = "#999";
  this.hover_color = "#fff";

  this.world_num = previous_menu.world_num

  var hover_color = "white";
  if (this.world_num == 0 || this.world_num == undefined) {
    hover_color = constants.colors["impulse_blue"];
  }

  if (this.previous_menu.solid) {
    this.solid = true;
  }

  this.current_hand = saveData.optionsData.control_hand
  this.current_scheme = saveData.optionsData.control_scheme
  var _this = this;
  this.back_button = new IconButton("BACK", 16, this.x, this.y - this.h/2 + 560, 60, 65, this.button_color, this.hover_color, function(_this) { return function() {
    _this.fader.set_animation("fade_out", function() {
      game_engine.set_dialog_box(_this.previous_menu)
      _this.previous_menu.fader.set_animation("fade_in");
    });
  }}(this), "back")


  this.control_buttons = {}

  this.control_buttons["left mouse"] = new IconButton("LEFT-HAND MOUSE", 16, this.x - 200, this.y - this.h/2 + 135, 200, 100, this.button_color, this.hover_color, function(_this) { return function() {
    saveData.optionsData.control_hand = "left"
    saveData.optionsData.control_scheme = "mouse"
    saveData.saveGame()
    controls.setKeyBindings()
  }}(this), "left_mouse")

  this.control_buttons["right keyboard"] = new IconButton("KEYBOARD-ONLY", 16, this.x, this.y - this.h/2 + 135, 200, 100, this.button_color, this.hover_color, function(_this) { return function() {
    saveData.optionsData.control_hand = "right"
    saveData.optionsData.control_scheme = "keyboard"
    saveData.saveGame()
    controls.setKeyBindings()
  }}(this), "keyboard")

  this.control_buttons["right mouse"] = new IconButton("RIGHT-HAND MOUSE", 16, this.x + 200, this.y - this.h/2 + 135, 200, 100, this.button_color, this.hover_color, function(_this) { return function() {
    saveData.optionsData.control_hand = "right"
    saveData.optionsData.control_scheme = "mouse"
    saveData.saveGame()
    controls.setKeyBindings()
  }}(this), "right_mouse")

  this.buttons.push(this.control_buttons["left mouse"])
  this.buttons.push(this.control_buttons["right mouse"])
  this.buttons.push(this.control_buttons["right keyboard"])

  this.buttons.push(this.back_button)

  this.adjust_colors()

  this.fader.set_animation("fade_in");
}


ControlsMenu.prototype.on_mouse_move = function(x, y) {
  this.current_hover = null
  for(var i in this.control_buttons) {
    this.control_buttons[i].on_mouse_move(x,y)
    if (this.control_buttons[i].mouseOver) {
      this.current_hover = i
    }
  }
  this.back_button.on_mouse_move(x, y)
  this.adjust_colors()
}

ControlsMenu.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x,y)
  }
}



ControlsMenu.prototype.adjust_colors = function() {
  for(var i in this.control_buttons) {
    this.control_buttons[i].color = this.button_color
    this.control_buttons[i].border = false
  }
  if (this.current_hover) {
    this.control_buttons[this.current_hover].color = this.button_color
  } else {
    this.control_buttons[saveData.optionsData.control_hand +" "+saveData.optionsData.control_scheme].color = this.button_color
  }
  this.control_buttons[saveData.optionsData.control_hand +" "+saveData.optionsData.control_scheme].border = true
}

ControlsMenu.prototype.additional_draw = function(ctx) {

  ctx.save()
  ctx.textAlign = "center"
  ctx.font = '32px Open Sans';
  //ctx.shadowBlur = 10;
  ctx.shadowColor = this.button_color;
  ctx.fillStyle = this.button_color;
  ctx.fillText("CONTROLS", this.x, this.y - this.h/2 + 50)

  ctx.font = '18px Open Sans';
  ctx.fillText("SELECT SCHEME", this.x, this.y - this.h/2 + 75)
  ctx.shadowBlur = 0
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].draw(ctx)
  }

  var currentControls = this.current_hover;

  if (currentControls == null) {
    if(saveData.optionsData.control_hand == "right" && saveData.optionsData.control_scheme == "mouse") {
      currentControls = "right mouse"
    }
    if(saveData.optionsData.control_hand == "left" && saveData.optionsData.control_scheme == "mouse") {
      currentControls = "left mouse"
    }
    if(saveData.optionsData.control_hand == "right" && saveData.optionsData.control_scheme == "keyboard") {
      currentControls = "right keyboard"
    }
  }
  ctx.globalAlpha *= 0.6
  if(currentControls == "right mouse") {
    uiRenderUtils.drawArrowKeys(ctx, this.x - 200, this.y - this.h/2 + 300, 50, this.button_color, ["W", "A", "S", "D"])
    ctx.fillText("MOVE", this.x - 200, this.y - this.h/2 + 360)
    uiRenderUtils.drawMouse(ctx, this.x + 200, this.y - this.h/2 + 270, 75, 100, this.button_color)
    ctx.fillText("IMPULSE", this.x + 200, this.y - this.h/2 + 360)

    renderUtils.drawRoundedRect(ctx, this.x, this.y - this.h/2 + 430, 300, 40, 10, this.button_color)
    ctx.fillText("SPACEBAR", this.x, this.y - this.h/2 + 436)
    ctx.shadowBlur = 0
    ctx.fillText("ENTER GATEWAY", this.x, this.y - this.h/2 + 490)
  }

  if(currentControls == "left mouse") {
    uiRenderUtils.drawMouse(ctx, this.x - 200, this.y - this.h/2 + 270,  75, 100, this.button_color)
    ctx.fillText("IMPULSE", this.x - 200, this.y - this.h/2 + 360)

    uiRenderUtils.drawArrowKeys(ctx, this.x + 200, this.y - this.h/2 + 300, 50, this.button_color)
    ctx.fillText("MOVE", this.x + 200, this.y - this.h/2 + 360)

    renderUtils.drawRoundedRect(ctx, this.x, this.y - this.h/2 + 430, 120, 40, 10, this.button_color)
    ctx.fillText("SHIFT", this.x, this.y - this.h/2 + 436)
    ctx.shadowBlur = 0
    ctx.fillText("ENTER GATEWAY", this.x, this.y - this.h/2 + 490)
  }

  if(currentControls == "right keyboard") {
    uiRenderUtils.drawArrowKeys(ctx, this.x - 200, this.y - this.h/2 + 300, 50, this.button_color, ["W", "A", "S", "D"])
    ctx.fillText("IMPULSE", this.x - 200, this.y - this.h/2 + 360)

    uiRenderUtils.drawArrowKeys(ctx, this.x + 200, this.y - this.h/2 + 300, 50, this.button_color)
    ctx.fillText("MOVE", this.x + 200, this.y - this.h/2 + 360)
    renderUtils.drawRoundedRect(ctx, this.x, this.y - this.h/2 + 430, 300, 40, 10, this.button_color)
    ctx.fillText("SPACEBAR", this.x, this.y - this.h/2 + 436)
    ctx.shadowBlur = 0
    ctx.fillText("ENTER GATEWAY", this.x, this.y - this.h/2 + 490)
  }

  ctx.restore()
}

ControlsMenu.prototype.on_key_down = function(keyCode) {
  if(keyCode == controls.keys.PAUSE || keyCode == controls.keys.SECONDARY_PAUSE) {
    this.game_state.toggle_pause()
  }
};


EnemyBox.prototype = new DialogBox()

EnemyBox.prototype.constructor = EnemyBox

function EnemyBox(enemy_name, previous_menu) {
  this.init(800, 600)

  this.button_color = "#999";
  this.hover_color = "#fff";
  if(previous_menu.isDialogBox){
    this.game_state = previous_menu.game_state
    this.world_num = this.game_state.world_num
  } else if(previous_menu.isGameState) {
    this.world_num = previous_menu.world_num
    this.game_state = previous_menu;
  }

  var hover_color = "white";
  if (this.world_num == 0 || this.world_num == undefined) {
    hover_color = constants.colors["impulse_blue"];
  }

  this.previous_menu = previous_menu

  this.enemy_name = enemy_name

  this.true_name = enemy_name

  if(enemyData[this.enemy_name].true_name) {
    this.true_name = enemyData[this.enemy_name].true_name
  }
  this.max_enemy_d = 50
  this.other_notes = null

  this.back_button = new IconButton("BACK", 16, this.x, this.y - this.h/2 + 560, 60, 65, this.button_color, this.hover_color, function(_this) { return function() {
    _this.fader.set_animation("fade_out", function() {
      if(_this.previous_menu.isDialogBox) {
        game_engine.set_dialog_box(_this.previous_menu)
        _this.previous_menu.fader.set_animation("fade_in");
      } else if(_this.previous_menu.isGameState) {
        game_engine.clear_dialog_box()
        _this.previous_menu.fader.set_animation("fade_in");
      }
    });
  }}(this), "back")

  this.buttons.push(this.back_button)


  this.color = constants.colors["world "+this.world_num]
  this.text_width = 500

  this.enemy_info = enemyData[this.enemy_name].enemy_info

  this.current_lines = null

  this.num_pages = this.enemy_info.length

  this.cur_page = 0

  if(this.enemy_name == "spear") this.spd_value = 1

  this.fader.set_animation("fade_in");
}

EnemyBox.prototype.additional_draw = function(ctx) {

  ctx.save()
  if(this.current_lines == null) {
    this.current_lines = utils.getLines(ctx, this.enemy_info[this.cur_page].toUpperCase(), this.text_width, '20px Open Sans')
  }

  ctx.beginPath()
  ctx.textAlign = "center"
  ctx.fillStyle = this.button_color
  ctx.font = '16px Open Sans'
  ctx.fillText("ENEMY INFO", this.x, this.y - this.h/2 + 70)
  ctx.font = '30px Open Sans'

  ctx.fillText(this.true_name.toUpperCase(), this.x, this.y - this.h/2 + 120)


  ctx.globalAlpha /= 3
  uiRenderUtils.drawTessellationSign(ctx, this.world_num, this.x, this.y - this.h/2 + 215, 80)
  ctx.globalAlpha *= 3
  enemyRenderUtils.drawEnemyRealSize(ctx, this.enemy_name, this.x, this.y - this.h/2 + 215, 1.5)

  ctx.font = '12px Open Sans'
  ctx.fillText("BASE POINTS", this.x, this.y - this.h/2 + 310)
  ctx.font = '24px Open Sans'
  ctx.fillText(enemyData[this.enemy_name].score_value, this.x, this.y - this.h/2 + 335)

  ctx.font = '20px Open Sans'

   for(var i = 0; i < this.current_lines.length; i++) {
    var offset = i - (this.current_lines.length-1)/2
    ctx.fillText(this.current_lines[i], this.x, this.y - this.h/2 + 427 + 25 * offset)
  }
  if (this.num_pages > 1) {
    uiRenderUtils.drawArrow(ctx, this.x - 300, this.y - this.h/2 + 420, 20, "left", this.button_color, false)
    ctx.font = '10px Open Sans'
    ctx.fillStyle = this.button_color
    ctx.fillText("NEXT", this.x + 302, this.y - this.h/2 + 450)
    ctx.fillText("PREV", this.x - 302, this.y - this.h/2 + 450)
    uiRenderUtils.drawArrow(ctx, this.x + 300, this.y - this.h/2 + 420, 20, "right", this.button_color, false)
    for(var i = 0; i < this.num_pages; i++) {
      var offset = (this.num_pages-1)/2 - i
      ctx.beginPath()
      ctx.shadowBlur = 5
      ctx.arc(this.x - 25 * offset, this.y - this.h/2 + 515, 4, 0, 2*Math.PI, true)

      if(this.cur_page == i) {
        ctx.fillStyle = this.button_color
        ctx.shadowColor = ctx.fillStyle
        ctx.fill()
      } else {
        ctx.save()
        ctx.globalAlpha *= 0.5
        ctx.fillStyle = this.color
        ctx.shadowColor = ctx.fillStyle
        ctx.fill()
        ctx.restore()
      }
    }
  }
  ctx.shadowBlur = 0

  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].draw(ctx)
  }
  ctx.restore()
}

EnemyBox.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_mouse_move(x, y)
  }
}

EnemyBox.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x, y)
  }

  if(x < this.x - this.text_width/2) {
    this.set_page(this.cur_page - 1)
  } else if(x > this.x + this.text_width/2) {
    this.set_page(this.cur_page + 1)
  }

  if(y > 500 && y < 530) {
    var index = Math.round((this.num_pages-1)/2 - (this.x - x)/25)

    if(index >= 0 && index < this.num_pages)
      this.set_page(index)
  }

}

EnemyBox.prototype.set_page = function(page) {
  this.cur_page = page
  if(this.cur_page < 0) {
    this.cur_page += this.num_pages
  }
  if(this.cur_page >= this.num_pages) {
    this.cur_page -= this.num_pages
  }
  this.current_lines = null
}

EnemyBox.prototype.on_key_down = function(keyCode) {
  if(keyCode == controls.keys.PAUSE || keyCode == controls.keys.SECONDARY_PAUSE) {
    this.game_state.toggle_pause()
  }
};

DeleteDataDialog.prototype = new DialogBox()

DeleteDataDialog.prototype.constructor = DeleteDataDialog

function DeleteDataDialog(previous_menu) {
  this.init(800, 600)
  this.previous_menu = previous_menu
  this.lite_color = previous_menu.lite_color
  this.button_color = previous_menu.button_color

  this.deleted = false

  this.solid = true;

  this.buttons = []
  this.delete_button= new IconButton("DELETE GAME DATA", 20, this.x, this.y + 90, 200, 100, "white", "red", function(_this) { return function() {
    _this.clear_data()
    _this.deleted = true
  }}(this), "delete")

  this.buttons.push(this.delete_button)

  this.back_button = new IconButton("BACK", 16, this.x, this.y - this.h/2 + 560, 60, 65, "white", "white" ,function(_this) { return function() {
    _this.fader.set_animation("fade_out", function() {
      game_engine.set_dialog_box(_this.previous_menu)
      _this.previous_menu.fader.set_animation("fade_in");
    });
  }}(this), "back")
  this.buttons.push(this.back_button)

  this.fader.set_animation("fade_in");
}

DeleteDataDialog.prototype.additional_draw = function(ctx) {

  if (!this.deleted) {
    ctx.fillStyle = "white"
    ctx.textAlign = "center"
    ctx.font = "32px Open Sans Bold"

    ctx.fillText("ARE YOU SURE", this.x, 190)
    ctx.font = "24px Open Sans"
    ctx.fillText(" YOU WANT TO DELETE ALL YOUR GAME DATA?", this.x, 230)
    ctx.font = "16px Open Sans"
    ctx.fillText("THIS ACTION CANNOT BE UNDONE.", this.x, 290)
    for(var i = 0; i < this.buttons.length; i++) {
      this.buttons[i].draw(ctx)
    }

  } else {
    ctx.fillStyle = "red"
    ctx.textAlign = "center"
    ctx.font = "24px Open Sans"
    ctx.fillText("ALL GAME DATA HAS BEEN DELETED", this.x, 210)
    this.back_button.draw(ctx)
  }
}

DeleteDataDialog.prototype.on_mouse_move = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_mouse_move(x,y)
  }
}

DeleteDataDialog.prototype.on_click = function(x, y) {
  for(var i = 0; i < this.buttons.length; i++) {
    this.buttons[i].on_click(x,y)
  }
}

DeleteDataDialog.prototype.clear_data = function() {
  saveData.clearData();
}

var dialogBoxes = {
  EnemyBox: EnemyBox,
  OptionsMenu: OptionsMenu,
  PauseMenu: PauseMenu
};

module.exports = dialogBoxes;

},{"../core/controls.js":2,"../core/dom.js":3,"../core/game_engine.js":4,"../core/layers.js":7,"../core/music_player.js":10,"../core/utils.js":11,"../data/constants.js":13,"../data/debug.js":14,"../data/enemy_data.js":15,"../data/level_data.js":16,"../game_states/fader_util.js":47,"../load/hive_numbers.js":66,"../load/save_data.js":69,"../render/enemy.js":74,"../render/ui.js":82,"../render/utils.js":83,"../ui/checkbox_option_button.js":85,"../ui/icon_button.js":87,"../ui/message_box.js":89,"../ui/slider_option_button.js":93,"../ui/small_button.js":94,"../ui/small_enemy_button.js":95,"../vendor/box2d.js":97,"lodash":99}],87:[function(require,module,exports){
// var constants = require('../data/constants.js');
var iconRenderUtils = require('../render/icons.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');

var ImpulseButton = require('../ui/impulse_button.js');

IconButton.prototype = new ImpulseButton()

IconButton.prototype.constructor = IconButton

function IconButton(text, size, x, y, w, h, color, hcolor, action, icon) {

  this.text = text
  this.size = size
  this.real_size = size
  this.init(x, y, w, h, action, false, color)

  this.hover_color = hcolor
  this.shadow = false;
  this.icon = icon
  this.active = true
  this.bg_color = null//"black"
  this.underline_on_hover = true

  if (this.icon.slice(0, 5) == "world" || this.icon == "close") {
    this.underline_on_hover = false;
  }
};

IconButton.prototype.additional_draw = function(context) {
  context.save()
  this.draw_icon(context)
  context.beginPath()
  context.textAlign = 'center'
  context.font = this.size+'px Open Sans';
  if (this.hover && this.underline_on_hover) {
    context.beginPath();
    var textWidth = context.measureText(this.text).width;
    context.moveTo(this.x - textWidth/2, this.y + this.h * 0.4);
    context.lineTo(this.x + textWidth/2, this.y + this.h * 0.4);
    context.strokeStyle = this.hover_color ? this.hover_color : this.color
    context.lineWidth = 2;
    context.stroke();
  }

  if(!this.active && (this.icon.slice(0, 8) == "practice")) {
    context.globalAlpha *= 0.4
  }
  context.fillStyle = this.hover ? this.hover_color : this.color
  if(this.shadow) {
    context.shadowBlur = 5
    context.shadowColor = context.fillStyle
  } else {
    context.shadowBlur = 0
  }

  if (this.icon.slice(0, 8) == "practice") {
    context.fillText(this.text, this.x - 1, this.y + this.h/6)
  } else if (this.icon == "close") {
    context.fillText(this.text, this.x, this.y)
  } else if (this.icon.slice(0, 5) != "world") {
    context.fillText(this.text, this.x, this.y + this.h/3)
  }

  if (this.extra_text) {
    context.font = this.extra_text_size ? this.extra_text_size : this.size * 0.7 +'px Open Sans';
    context.fillText(this.extra_text, this.x, this.y + this.h/3 + 1 * this.size)
  }

  context.fill()
  context.restore()
}

IconButton.prototype.draw_icon  = function(context) {
  if(!this.icon) return
	context.save()
  context.shadowBlur = 0
	if(this.icon == "player") {
		if(this.hover) {
		  renderUtils.drawSprite(context, this.x, this.y - this.h/8, 0, 40, 40, "player_normal")
		} else {
		  renderUtils.drawSprite(context, this.x, this.y - this.h/8, 0, 40, 40, "player_white")
		}
	} else if(this.icon == "gear") {

		if(this.hover) {
			iconRenderUtils.drawGearIcon(context, this.x, this.y - this.h/8, 15, constants.colors["impulse_blue"], "#080808", false)
		} else {
			iconRenderUtils.drawGearIcon(context, this.x, this.y - this.h/8, 15, "white", "#080808", false)
		}
	} else if(this.icon == "credit") {
    if(this.hover) {
      iconRenderUtils.drawCreditsIcon(context, this.x, this.y - this.h/8, 15, constants.colors["impulse_blue"], "#080808", false)
    } else {
      iconRenderUtils.drawCreditsIcon(context, this.x, this.y - this.h/8, 15, "white", "#080808", false)
    }
  } else if(this.icon == "tutorial") {
    if(this.hover) {
      iconRenderUtils.drawTutorialIcon(context, this.x, this.y - this.h/8, 13, constants.colors["impulse_blue"], "#080808", false)
    } else {
      iconRenderUtils.drawTutorialIcon(context, this.x, this.y - this.h/8, 13, "white", "#080808", false)
    }
  } else if(this.icon == "note") {
    if(this.hover) {
      iconRenderUtils.drawNoteIcon(context, this.x, this.y - this.h/6, 20, constants.colors["impulse_blue"], "#080808")
    } else {
      iconRenderUtils.drawNoteIcon(context, this.x, this.y - this.h/6, 20, "white", "#080808")
    }
  } else if(this.icon == "texture") {
    if(this.hover) {
      iconRenderUtils.drawTextureIcon(context, this.x, this.y - this.h/4, 20, constants.colors["impulse_blue"])
    } else {
      iconRenderUtils.drawTextureIcon(context, this.x, this.y - this.h/4, 20, "white")
    }
  } else if(this.icon == "physics_engine") {
    if(this.hover) {
      iconRenderUtils.drawPhysicsIcon(context, this.x, this.y - this.h/6, 20, constants.colors["impulse_blue"])
    } else {
      iconRenderUtils.drawPhysicsIcon(context, this.x, this.y - this.h/6, 20, "white")
    }
  } else if(this.icon == "audio") {
    if(this.hover) {
      iconRenderUtils.drawMusicIcon(context, this.x, this.y - this.h/6, 20, constants.colors["impulse_blue"], false, false)
    } else {
      iconRenderUtils.drawMusicIcon(context, this.x, this.y - this.h/6, 20, "white", false, false)
    }
  } else if(this.icon == "back") {
    if(this.hover) {
      iconRenderUtils.drawBackIcon(context, this.x, this.y - this.h/8, 13, this.hover_color, "#080808", false)
    } else {
      iconRenderUtils.drawBackIcon(context, this.x, this.y - this.h/8, 13, this.color, "#080808", false)
    }
  } else if(this.icon == "start") {
    if(this.hover) {
      iconRenderUtils.drawStartIcon(context, this.x, this.y - this.h/8, 20, this.hover_color)
    } else {
      iconRenderUtils.drawStartIcon(context, this.x, this.y - this.h/8, 20, this.color)
    }
  } else if(this.icon == "resume") {
    if(this.hover) {
      iconRenderUtils.drawStartIcon(context, this.x, this.y - this.h/8, 30, this.hover_color)
    } else {
      iconRenderUtils.drawStartIcon(context, this.x, this.y - this.h/8, 30, this.color)
    }
  } else if(this.icon == "retry") {
    if(this.hover) {
      iconRenderUtils.drawRetryIcon(context, this.x, this.y - this.h/8, 13, this.hover_color)
    } else {
      iconRenderUtils.drawRetryIcon(context, this.x, this.y - this.h/8, 13, this.color)
    }
  } else if(this.icon == "options") {
    if(this.hover) {
      iconRenderUtils.drawGearIcon(context, this.x, this.y - this.h/8, 15, this.hover_color, this.bg_color)
    } else {
      iconRenderUtils.drawGearIcon(context, this.x, this.y - this.h/8, 15, this.color, this.bg_color)
    }
  } else if(this.icon == "save") {
    if(this.hover) {
      iconRenderUtils.drawSaveIcon(context, this.x, this.y - this.h/8, 20, this.hover_color)
    } else {
      iconRenderUtils.drawSaveIcon(context, this.x, this.y - this.h/8, 20, this.color)
    }
  } else if (this.icon == "quest") {
    if(this.hover) {
      iconRenderUtils.drawQuestIcon(context, this.x, this.y - this.h/8, 18, this.hover_color)
    } else {
      iconRenderUtils.drawQuestIcon(context, this.x, this.y - this.h/8, 18, this.color)
    }
  } else if(this.icon == "quit") {
    if(this.hover) {
      iconRenderUtils.drawQuitIcon(context, this.x, this.y - this.h/6, 24, this.hover_color)
    } else {
      iconRenderUtils.drawQuitIcon(context, this.x, this.y - this.h/6, 24, this.color)
    }
  } else if(this.icon == "close") {
    if(this.hover) {
      iconRenderUtils.drawQuitIcon(context, this.x - 45, this.y - 6, 18, this.hover_color)
    } else {
      iconRenderUtils.drawQuitIcon(context, this.x - 45, this.y - 6, 18, this.color)
    }
  } else if(this.icon == "delete") {
    if(this.hover) {
      iconRenderUtils.drawDeleteIcon(context, this.x, this.y - this.h/8, 36, this.hover_color)
    } else {
      iconRenderUtils.drawDeleteIcon(context, this.x, this.y - this.h/8, 36, this.color)
    }
  } else if(this.icon == "delete_small") {
    if(this.hover) {
      iconRenderUtils.drawDeleteIcon(context, this.x, this.y - this.h/5, 30, this.hover_color)
    } else {
      iconRenderUtils.drawDeleteIcon(context, this.x, this.y - this.h/5, 30, this.color)
    }
  } else if(this.icon == "close_dialog") {
    if(this.hover) {
      iconRenderUtils.drawQuitIcon(context, this.x, this.y - this.h/6, 36, this.hover_color)
    } else {
      iconRenderUtils.drawQuitIcon(context, this.x, this.y - this.h/6, 36, this.color)
    }
  } else if (this.icon == "mute_in_game") {
    iconRenderUtils.drawMusicIcon(context, this.x, this.y, 15, this.hover ? this.hover_color : this.color, true, saveData.optionsData.bg_music_mute)
  } else if (this.icon == "pause_in_game") {
    iconRenderUtils.drawPauseIcon(context, this.x, this.y, 15, this.hover ? this.hover_color : this.color, true)
  } else if (this.icon == "fullscreen_in_game") {
    iconRenderUtils.drawFullscreenIcon(context, this.x, this.y, 15, this.hover ? this.hover_color : this.color, true)
  } else if (this.icon == "normal_mode") {
    renderUtils.drawSprite(context, this.x, this.y - this.h/8, 0, 40, 40, this.hover ? "blue_flower" : "white_flower")
  } else if(this.icon == "left_mouse") {
    uiRenderUtils.drawBareMouse(context, this.x - this.w * 0.23, this.y - this.h * 0.1, this.w * 0.17, this.h * 0.4, this.hover ? this.hover_color : this.color)
    uiRenderUtils.drawArrowKeys(context, this.x + this.w * 0.17, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
  } else if(this.icon == "keyboard") {
    uiRenderUtils.drawArrowKeys(context, this.x - this.w * 0.23, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
    uiRenderUtils.drawArrowKeys(context, this.x + this.w * 0.23, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
  } else if(this.icon == "right_mouse") {
    uiRenderUtils.drawArrowKeys(context, this.x - this.w * 0.17, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
    uiRenderUtils.drawBareMouse(context, this.x + this.w * 0.23, this.y - this.h * 0.1, this.w * 0.17, this.h * 0.4, this.hover ? this.hover_color : this.color)
  } else if(this.icon == "help_icon") {
    context.beginPath()
    context.arc(this.x, this.y, this.w / 2, -.5* Math.PI, -.5 * Math.PI + 1.999*Math.PI, false)
    context.strokeStyle = this.hover ? this.hover_color : this.color;
    context.lineWidth = 2;
    context.fillStyle = "black"
    context.stroke();
    context.fill();
    context.beginPath();
    context.arc(this.x, this.y - this.w / 8, this.w / 8, -Math.PI, 0, false);
    context.lineTo(this.x, this.y + this.w / 8);
    //context.lineTo(this.x, this.y + this.w * 3 / 8);
    context.stroke();
    context.beginPath();
    context.arc(this.x, this.y + this.w / 2 - 4, 1, 0, 2 * Math.PI);
    context.fillStyle = this.hover ? this.hover_color : this.color;
    context.fill();
  } else if(this.icon == "controls") {
    context.shadowBlur = 0
    if(saveData.optionsData.control_hand == "right" && saveData.optionsData.control_scheme == "mouse") {

      uiRenderUtils.drawArrowKeys(context, this.x - this.w * 0.15, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
      uiRenderUtils.drawBareMouse(context, this.x + this.w * 0.2, this.y - this.h * 0.1, this.w * 0.15, this.h * 0.4, this.hover ? this.hover_color : this.color)
    }
    if(saveData.optionsData.control_hand == "left" && saveData.optionsData.control_scheme == "mouse") {
      uiRenderUtils.drawBareMouse(context, this.x - this.w * 0.2, this.y - this.h * 0.1, this.w * 0.15, this.h * 0.4, this.hover ? this.hover_color : this.color)
      uiRenderUtils.drawArrowKeys(context, this.x + this.w * 0.15, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
    }
    if(saveData.optionsData.control_hand == "right" && saveData.optionsData.control_scheme == "keyboard") {
      uiRenderUtils.drawArrowKeys(context, this.x - this.w * 0.2, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
      uiRenderUtils.drawArrowKeys(context, this.x + this.w * 0.2, this.y, this.h * 0.2, this.hover ? this.hover_color : this.color)
    }
  } else if(this.icon.slice(0, 5) == "world") {
    var world_num = parseInt(this.icon.slice(5));
    context.save()
    if(this.hover && this.active) {
      context.globalAlpha *= 0.5
    } else if (this.active) {
      context.globalAlpha *= 0.3
    } else {
      context.globalAlpha *= 0.15
    }
    if(!this.active) {
      uiRenderUtils.drawGrayTessellationSign(context, world_num, this.x, this.y, this.size * 2, this.hover)
    } else {
      uiRenderUtils.drawTessellationSign(context, world_num, this.x, this.y, this.size * 2, this.hover)
    }
    context.restore()
    context.save()
    if (!this.active) {
      context.globalAlpha *= 0.3
    }
    context.textAlign = 'center'
    context.font = "32px Open Sans"
    context.fillStyle = this.active ? this.color : "gray";
    context.fillText(this.text, this.x, this.y + 10)
    context.restore()
  } else if(this.icon.slice(0, 8) == "practice") {
    var world_num = parseInt(this.icon.slice(8));
    if(!this.active) {
      context.globalAlpha *= 0.3
      uiRenderUtils.drawGrayTessellationSign(context, world_num, this.x, this.y, this.size * 1.4)
    } else {
      if(this.hover) {
        if(world_num == 3) {
          context.globalAlpha *= 0.6
        } else {
          context.globalAlpha *= 0.7
        }
      } else {
        context.globalAlpha *= 0.3
      }
     uiRenderUtils.drawTessellationSign(context, world_num, this.x, this.y, this.size * 1.4)
    }

  }
  context.restore()
}

module.exports = IconButton;

},{"../load/save_data.js":69,"../render/icons.js":77,"../render/ui.js":82,"../render/utils.js":83,"../ui/impulse_button.js":88}],88:[function(require,module,exports){
var ImpulseButton = function(x, y, w, h, action, border, color) {
  if(!action) return
    this.init(x, y, w, h, action, border, color)
}

ImpulseButton.prototype.init = function(x, y, w, h, action, border, color) {
  this.x = x
  this.y = y
  this.w = w
  this.h = h
  this.action = action
  this.active = true
  this.border = border
  this.color = color
  this.hover = false
  this.hover_color = null
  this.hover_overlay;
}

ImpulseButton.prototype.draw = function(context) {
  context.save()
  if(this.border) {
    context.beginPath()
    context.strokeStyle = this.active ? (this.hover && this.hover_color ? this.hover_color : this.color) : "gray"
    context.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
    context.lineWidth = 4 //this.w * 0.03
    context.stroke()
  }
  this.additional_draw(context)

  context.restore()
}

ImpulseButton.prototype.post_draw = function(context) {
  if (this.hover_overlay) {
    this.hover_overlay.draw(context)
  }
}
ImpulseButton.prototype.additional_draw = function(context) {}

ImpulseButton.prototype.on_mouse_move = function(x,y) {
    if(x >= this.x - this.w/2 && x <= this.x + this.w/2 && y >= this.y - this.h/2 && y <= this.y + this.h/2)
    {
      if(this.active)
      {
        this.hover = true

      }
      this.mouseOver = true
    }
    else
    {
      this.hover = false
      this.mouseOver = false
    }

    if (this.hover_overlay) {
      this.hover_overlay.set_visible(this.mouseOver);
      this.hover_overlay.set_position(x, y);
    }
}

ImpulseButton.prototype.on_click = function(x,y) {
  if(this.active)
  {
    if(x >= this.x -this.w/2 && x <= this.x + this.w/2 && y >= this.y - this.h/2 && y <= this.y + this.h/2)
    {
      this.action()
      return true
    }
  }
  return false
}

ImpulseButton.prototype.set_active = function(active) {
  this.active = active
  if(!this.active) this.color = "gray"
}

ImpulseButton.prototype.on_key_down = function(keyCode) {
  if (this.active && (this.keyCode && this.keyCode == keyCode) || (this.sKeyCode && this.sKeyCode == keyCode)) {
    this.action()
  }
}

ImpulseButton.prototype.add_hover_overlay = function(hover_overlay) {
  this.hover_overlay = hover_overlay;
}

ImpulseButton.prototype.on_mouse_down = function(x, y) {}
ImpulseButton.prototype.on_mouse_up = function(x, y) {}

module.exports = ImpulseButton;

},{}],89:[function(require,module,exports){
var constants = require('../data/constants.js');
var enemyData = require('../data/enemy_data.js');
var iconRenderUtils = require('../render/icons.js');
var questData = require('../data/quest_data.js');
var questRenderUtils = require('../render/quest.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');

var MessageBox = function(type, color, world_num, completed) {
  if(!color) return
  this.init(type, color, world_num, completed)
};

MessageBox.prototype.init = function(type, color, world_num, completed) {
	this.type = type;
	this.color = color;
	this.completed = completed;
	this.x = 0;
	this.y = 0;
	this.visible = false;
	this.message_only = false;
	this.show_box = true
	if (this.type == "fullscreen_msg") {
		this.w = 230;
		this.h = 40;
	} else if (this.type == "mute_msg") {
		this.w = 130;
		this.h = 40;
	} else if (this.type == "final_boss") {
		this.w = 220;
		this.h = 50;
	} else if (this.type.substring(0, 10) == "blitz_hive") {
		this.w = 250;
		this.h = 75;
	} else if (this.type.substring(0, 9) == "beat_hive") {
		this.w = 150;
		this.h = 50;
	} else if (this.type == "high_roller") {
		this.w = 250;
		this.h = 75;
	} else if (this.type == "untouchable") {
		this.w = 200;
		this.h = 75;
	} else if (this.type == "combo" || this.type == "pacifist" || this.type == "survivor") {
		this.w = 250;
		this.h = 75;
	} else if (this.type == "fast_time") {
		this.w = 220;
		this.h = 150;
	} else if (this.type == "0star") {
		this.w = 250;
		this.h = 75;
	} else if (this.type == "beat_hard") {
		this.w = 180;
		this.h = 75;
	} else if (this.type == "option_game_music") {
		this.w = 300;
		this.h = 40;
	} else if (this.type == "option_sound_effects") {
		this.w = 250;
		this.h = 40;
	} else if (this.type == "option_fullscreen") {
		this.w = 150;
		this.h = 40;
	} else if (this.type == "option_particle_effects") {
		this.w = 250;
		this.h = 40;
	} else if (this.type == "option_score_labels") {
		this.w = 350;
		this.h = 40;
	} else if (this.type == "option_multiplier_display") {
		this.w = 300;
		this.h = 40;
	} else if (this.type == "option_impulse_shadow") {
		this.w = 350;
		this.h = 40;
	} else if (this.type == "option_speed_run") {
		this.w = 500;
		this.h = 40;
	} else if (this.type == "tutorial_move") {
		this.w = 200;
		this.h = 150;
	} else if (this.type == "tutorial_impulse") {
		this.w = 180;
		this.h = 150;
	} else if (this.type == "tutorial_pause") {
		this.w = 220;
		this.h = 40;
	} else if (this.type == "tutorial_gateway_move") {
		this.w = 220;
		this.h = 80;
	} else if (this.type == "tutorial_score_points") {
		this.w = 450;
		this.h = 40;
	} else if (this.type == "tutorial_enemy_incr") {
		this.w = 420;
		this.h = 40;
	} else if (this.type == "tutorial_enemy_touch") {
		this.w = 350;
		this.h = 40;
	} else if (this.type == "tutorial_enter_gateway") {
		this.w = 200;
		this.h = 120;
	} else if (this.type == "tutorial_void") {
		this.w = 350;
		this.h = 40;
	} else if (this.type == "tutorial_kill_enemy") {
		this.w = 300;
		this.h = 40;
	} else if (this.type == "tutorial_incr_multiplier") {
		this.w = 400;
		this.h = 40;
	} else if (this.type == "tutorial_reset_multiplier") {
		this.w = 400;
		this.h = 40;
	} else if (this.type == "tutorial_one_up") {
		this.w = 250;
		this.h = 40;
	} else if (this.type == "tutorial_kill_boss") {
		this.w = 300;
		this.h = 40;
	} else if (this.type == "god_mode_alert") {
		this.w = 250;
		this.h = 40;
		this.message = "ALL LEVELS UNLOCKED"
		this.message_only = true
	} else if (this.type == "saved_alert") {
		this.w = 250;
		this.h = 75;
		this.show_box = false;
	} else if (this.type.substring(0, 6) == "quest_") {
		this.w = 420;
		this.h = 90;
		this.show_box = false;
	} else if (this.type.substring(0, 6) == "enemy_") {
		this.w = 420;
		this.h = 90;
		this.show_box = false;
	}

	this.opacity = 0;
	this.world_num = world_num
};

MessageBox.prototype.draw = function(ctx) {
	if(!this.visible) return;
	ctx.save()

	if (this.show_box) {
		ctx.beginPath();
		ctx.strokeStyle = this.color;
		if (this.type.substring(0, 8) == "tutorial") {
			ctx.fillStyle = "#111"
		} else {
			ctx.fillStyle = "black"
		}

		ctx.shadowBlur = 0;
		ctx.lineWidth = 2;
		ctx.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
		ctx.fill();
		ctx.stroke();
	}

	if (this.type == "option_game_music") {
		this.option_text = "BACKGROUND MUSIC VOLUME"
	}
	if (this.type == "option_sound_effects") {
		this.option_text = "SOUND EFFECTS VOLUME"
	}
	if (this.type == "option_fullscreen") {
		this.option_text = "GO FULLSCREEN"
	}
	if (this.type == "option_particle_effects") {
		this.option_text = "SHOW PARTICLE EFFECTS"
	}
	if (this.type == "option_score_labels") {
		this.option_text = "SHOW SCORE VALUE WHEN ENEMIES DIE"
	}
	if (this.type == "option_multiplier_display") {
		this.option_text = "SHOW MULTIPLIER BELOW PLAYER"
	}
	if (this.type == "option_impulse_shadow") {
		this.option_text = "SHOW AIMING SHADOW FOR IMPULSE"
	}
	if (this.type == "option_speed_run") {
		this.option_text = "SHOW COUNTDOWN FOR BEATING SPEED RUN CHALLENGE"
	}

	if (this.type == "tutorial_move") {
		if(saveData.optionsData.control_hand == "right" && saveData.optionsData.control_scheme == "mouse") {
          uiRenderUtils.drawArrowKeys(ctx, this.x, this.y, 40, "white", ["W", "A", "S", "D"])
        }
		if(saveData.optionsData.control_hand == "right" && saveData.optionsData.control_scheme == "keyboard") {
          uiRenderUtils.drawArrowKeys(ctx, this.x, this.y, 40, "white")
        }
        if(saveData.optionsData.control_hand == "left" && saveData.optionsData.control_scheme == "mouse") {
          uiRenderUtils.drawArrowKeys(ctx, this.x, this.y, 40, "white")
        }
		this.tutorial_text = "MOVE";
	}

	if (this.type == "tutorial_impulse") {
		if(saveData.optionsData.control_scheme == "mouse") {
			uiRenderUtils.drawMouse(ctx, this.x, this.y - 20, 56, 82, "white")
		} else {
            uiRenderUtils.drawArrowKeys(ctx, this.x, this.y, 40, "white", ["W", "A", "S", "D"])
		}
		this.tutorial_text = "IMPULSE";
	}

	if (this.type == "tutorial_pause") {
	  if(saveData.optionsData.control_hand == "right") {
	  	this.tutorial_text = "ESC TO PAUSE";
      } else if(saveData.optionsData.control_hand == "left") {
      	this.tutorial_text = "ENTER TO PAUSE";
      }
	}

	if (this.type == "tutorial_score_points") {
		this.tutorial_text = "GET THE GOAL SCORE TO OPEN THE GATEWAY"
	}

	if (this.type == "tutorial_incr_multiplier") {
		this.tutorial_text = "KILLING ENEMIES INCREASES YOUR MULTIPLIER"
	}

	if (this.type == "tutorial_reset_multiplier") {
		this.tutorial_text = "TOUCHING ENEMIES RESETS YOUR MULTIPLIER"
	}

	if (this.type == "tutorial_enemy_incr") {
		this.tutorial_text = "ENEMIES SPAWN FASTER OVER TIME"
	}

	if (this.type == "tutorial_enemy_touch") {
		this.tutorial_text = "TOUCHING THIS ENEMY WILL STUN YOU"
	}

	if (this.type == "tutorial_kill_boss") {
		this.tutorial_text = "PUSH THE BOSS INTO THE VOID"
	}

	if (this.type == "tutorial_void") {
		this.tutorial_text = "TOUCHING THE VOID WILL KILL YOU"
	}

	if (this.type == "tutorial_kill_enemy") {
		this.tutorial_text = "IMPULSE THE ENEMY INTO THE VOID"
	}

	if (this.type == "tutorial_enter_gateway") {
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = this.color;
		if(saveData.optionsData.control_hand == "right") {
	        renderUtils.drawRoundedRect(ctx, this.x, this.y - 10, 160, 34, 7, "white")
	        ctx.fillText("SPACEBAR", this.x, this.y - 4)
	    }

	    if(saveData.optionsData.control_hand == "left") {
	        renderUtils.drawRoundedRect(ctx, this.x, this.y - 10, 80, 34, 7, "white")
	        ctx.fillText("SHIFT", this.x, this.y - 4)
	    }
		this.tutorial_text = "ENTER GATEWAY";
	}

	if (this.type == "tutorial_gateway_move") {
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = this.color;
		ctx.fillText("MOVE TO THE GATEWAY", this.x, this.y - this.h / 2 + 25);
		uiRenderUtils.drawFullArrow(ctx, this.x, this.y + 12, 1, "white", "down");
	}

	if (this.type == "fullscreen_msg") {
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = this.color;
		ctx.fillText("TOGGLE FULLSCREEN (F)", this.x, this.y - this.h / 2 + 25);
	} else if (this.type == "mute_msg") {
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = this.color;
		ctx.fillText("MUTE (M)", this.x, this.y - this.h / 2 + 25);
	} else if (this.type.substring(0, 8) == "tutorial") {
		/*if(saveData.optionsData.control_hand == "right") {
	      uiRenderUtils.drawArrowKeys(ctx, this.x, this.y, 45, this.color, ["W", "A", "S", "D"])
	    }
	    if(saveData.optionsData.control_hand == "left" && saveData.optionsData.control_scheme == "mouse") {
	      uiRenderUtils.drawArrowKeys(ctx, this.x, this.y, 45, this.color)
	    }*/
	    if (this.tutorial_text) {
			ctx.textAlign = 'center';
			ctx.font = "16px Open Sans";
			ctx.fillStyle = this.color;
			ctx.fillText(this.tutorial_text, this.x, this.y + this.h / 2 - 15);
		}
	} else if (this.type.substring(0, 6) == "option") {
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = this.color;
		ctx.fillText(this.option_text, this.x, this.y - this.h / 2 + 25);
	} else if (this.message_only) {
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = this.color;
		ctx.fillText(this.message, this.x, this.y - this.h / 2 + 25);
	} else if (this.type == "saved_alert") {

		ctx.globalAlpha *= 0.5
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans"
		ctx.fillStyle = this.color;
		ctx.save()
		ctx.globalAlpha *= 0.5
	    iconRenderUtils.drawSaveIcon(ctx, this.x, this.y - this.h / 2 + 10, 20, this.color)
		ctx.restore()
		ctx.fillText("GAME SAVED", this.x, this.y + this.h / 2 - 33);
	} else if (this.type.substring(0, 6) == "quest_")  {
		ctx.beginPath();
		ctx.fillStyle = "black"
		ctx.shadowBlur = 0;
		ctx.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
		ctx.fill();
		ctx.beginPath();
		var x_left_edge = this.x - this.w/2 + 75;
		ctx.moveTo(this.x + this.w/2, this.y - this.h/2)
		ctx.lineTo(this.x + this.w/2, this.y + this.h/2)
		ctx.lineTo(x_left_edge, this.y + this.h/2)
		ctx.moveTo(this.x + this.w/2, this.y - this.h/2)
		ctx.lineTo(x_left_edge, this.y - this.h/2)
		ctx.strokeStyle = "white"
		ctx.lineWidth = 2;
		ctx.stroke()
		var x_shift = 50;

		var type = this.type.substring(6);
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans"
		ctx.fillStyle = "white";
		ctx.fillText("NEW ACHIEVEMENT", this.x + x_shift, this.y - this.h / 2 + 30);

		/*ctx.beginPath();
		ctx.strokeStyle = "white"
		ctx.moveTo(this.x - this.w/2 + 10, this.y - this.h / 2 + 25);
		ctx.lineTo(this.x + this.w/2 - 10, this.y - this.h / 2 + 25);
		ctx.lineWidth = 1;
		ctx.stroke();*/

		ctx.font = "12px Open Sans"
		var quest_text = ""
		if (questData[type]) {
			for (var i = 0; i < questData[type].text.length; i++) {
				quest_text += questData[type].text[i] + " ";
			}
		}

		ctx.fillText(quest_text, this.x + x_shift, this.y + this.h / 2 - 20);

		questRenderUtils.draw_quest_button(ctx, this.x - this.w / 2 + 40, this.y, 60, type)

		//questRenderUtils.draw_quest_button = function(ctx, x, y, r, type) {
	} else if (this.type.substring(0, 6) == "enemy_")  {
		ctx.beginPath();
		ctx.fillStyle = "black"
		ctx.shadowBlur = 0;
		ctx.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
		ctx.fill();
		ctx.beginPath();
		var x_left_edge = this.x - this.w/2 + 75;
		ctx.moveTo(this.x + this.w/2, this.y - this.h/2)
		ctx.lineTo(this.x + this.w/2, this.y + this.h/2)
		ctx.lineTo(x_left_edge, this.y + this.h/2)
		ctx.moveTo(this.x + this.w/2, this.y - this.h/2)
		ctx.lineTo(x_left_edge, this.y - this.h/2)
		ctx.strokeStyle = "white"
		ctx.lineWidth = 2;
		ctx.stroke()
		var x_shift = 50;


		var type = this.type.substring(6);
		var true_name = type;
	    if(enemyData[type].true_name) {
	      true_name = enemyData[type].true_name
		}
		ctx.textAlign = 'center';
		ctx.font = "12px Open Sans"
		ctx.fillStyle = "white";
		ctx.fillText("NEW ENEMY", this.x + x_shift, this.y - this.h / 2 + 20);
		ctx.fillStyle = enemyData[type].color
		ctx.font = "24px Open Sans"
		ctx.fillText(true_name.toUpperCase(), this.x + x_shift, this.y - this.h / 2 + 45);
		ctx.fillStyle = "white";;
		ctx.font = "16px Open Sans"
		ctx.fillText(enemyData[type].snippet.toUpperCase(), this.x + x_shift, this.y + this.h / 2 - 15);
		uiRenderUtils.drawEnemyButton(ctx, this.x - this.w / 2 + 40, this.y, 60, type)
	} else {
		// rewards
		ctx.textAlign = 'center';
		ctx.font = "16px Open Sans";
		ctx.fillStyle = "white";
		for (var i = 0; i < questData[this.type].text.length; i++) {
			var text = questData[this.type].text[i];
			ctx.fillText(text, this.x, this.y - this.h / 2 + 30 + i * 24);
		}
	}
	ctx.restore();
};

MessageBox.prototype.set_visible = function(visibility) {
	this.visible = visibility;
}

// Mouse x and y are passed in. The actual x, y position is also based on type, w, and h.
MessageBox.prototype.set_position = function(mx, my) {
	this.x = mx;
	this.y = my + this.h/2;

	if (this.type.substring(0, 6) == "option") {
		this.y += 20
	}

	if (this.type.substring(0, 8) == "tutorial") {
		this.x = mx;
		this.y = my - this.h/2 - 50;
	}
}

module.exports = MessageBox;

},{"../data/constants.js":13,"../data/enemy_data.js":15,"../data/quest_data.js":17,"../load/save_data.js":69,"../render/icons.js":77,"../render/quest.js":80,"../render/ui.js":82,"../render/utils.js":83}],90:[function(require,module,exports){
var questRenderUtils = require('../render/quest.js');
var renderUtils = require('../render/utils.js');
var saveData = require('../load/save_data.js');

var ImpulseButton = require('../ui/impulse_button.js');
var MessageBox = require('../ui/message_box.js');

QuestButton.prototype = new ImpulseButton()

QuestButton.prototype.constructor = QuestButton

function QuestButton(type, x, y, r) {
  this.type = type;
  this.x = x;
  this.y = y;
  this.r = r;
  this.w = 2 * r;
  this.h = 2 * r;
  this.normal_canvas = document.createElement('canvas');
  this.normal_canvas.width = this.w
  this.normal_canvas.height = this.h
  var normal_canvas_ctx = this.normal_canvas.getContext('2d');
  questRenderUtils.draw_quest_button(normal_canvas_ctx, this.r, this.r, this.r, this.type);
  this.gray_canvas = renderUtils.convertCanvasToGrayscale(this.normal_canvas, 255)

  this.quest_completed = saveData.quests.indexOf(type) != -1;
  this.add_hover_overlay(new MessageBox(this.type, "white", 0, this.quest_completed));
}

QuestButton.prototype.draw = function(ctx, bg_ctx) {
  if (!this.quest_completed) {
    ctx.save();
    ctx.globalAlpha *= 0.4;
    ctx.drawImage(this.gray_canvas, 0, 0, this.w, this.h, this.x - this.r, this.y - this.r, this.w, this.h);
    ctx.restore();
  } else {
    ctx.drawImage(this.normal_canvas, 0, 0, this.w, this.h, this.x - this.r, this.y - this.r, this.w, this.h);
  }

	if (this.mouseOver)	 {
		ctx.save();
		ctx.globalAlpha *= 0.2;
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
		ctx.fillStyle = "#fff"
		ctx.fill();
		ctx.beginPath();
		ctx.restore();
	}
}

QuestButton.prototype.process = function(dt) {

}

module.exports = QuestButton;

},{"../load/save_data.js":69,"../render/quest.js":80,"../render/utils.js":83,"../ui/impulse_button.js":88,"../ui/message_box.js":89}],91:[function(require,module,exports){
var saveData = require('../load/save_data.js');

var CheckBox = require('../ui/checkbox.js');
var ImpulseButton = require('../ui/impulse_button.js');

SelectDifficultyButton.prototype = new ImpulseButton()

SelectDifficultyButton.prototype.constructor = SelectDifficultyButton

function SelectDifficultyButton(size, x, y, w, h, color, hcolor, world_map_state) {

  this.size = size
  this.real_size = size
  this.init(x, y, w, h, this.on_adjust_difficulty, false, color)

  this.hover_color = hcolor
  this.shadow = false;
  this.active = true
  this.bg_color = null//"black"

  this.checkbox = new CheckBox(this.x, this.y - this.h/8, 20, 20, this.color);
  this.world_map_state = world_map_state;
  this.recalculate_state();
}

SelectDifficultyButton.prototype.on_adjust_difficulty = function() {
  saveData.difficultyMode = saveData.difficultyMode == "easy" ? "normal" : "easy";
  saveData.saveGame();
  this.world_map_state.update_on_difficulty_change(saveData.difficultyMode);
  this.recalculate_state();
}

SelectDifficultyButton.prototype.recalculate_state = function() {
  this.checkbox.checked = saveData.difficultyMode == "normal";
}

SelectDifficultyButton.prototype.additional_draw = function(ctx) {
  this.checkbox.draw(ctx);
  ctx.textAlign = 'center'
  ctx.font = this.size+'px Open Sans';
  ctx.fillStyle = this.color
  ctx.fillText("HARD MODE", this.x, this.y + this.h/3)
}

module.exports = SelectDifficultyButton;

},{"../load/save_data.js":69,"../ui/checkbox.js":84,"../ui/impulse_button.js":88}],92:[function(require,module,exports){
var Slider = function(x, y, w, h, color) {
  this.x = x
  this.y = y
  this.w = w
  this.h = h
  this.color = color
  this.active = true
  this.value = 0
  this.thumb_width = 20
  this.dragged = false
}

Slider.prototype.draw = function(context) {
  context.beginPath()
  context.strokeStyle = this.color
  context.fillStyle  = this.color
  context.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
  context.lineWidth = 1
  context.save();
  context.globalAlpha *= 0.75
  context.fill()
  context.restore();
  context.stroke()

  context.beginPath()

  context.rect(this.x - this.w/2 + this.w * this.value - this.thumb_width/2, this.y - this.thumb_width/2, this.thumb_width, this.thumb_width)
  context.fill()
}

Slider.prototype.on_mouse_down = function(x, y) {
  if(x > this.x - this.w/2 - this.thumb_width/2 && x < this.x + this.w/2 + this.thumb_width/2 && y > this.y - this.h/2 - this.thumb_width/2 && y < this.y + this.h/2 + this.thumb_width/2) {
    this.set_value((x - (this.x - this.w/2)) / this.w)
    this.drag = true
  }

}

Slider.prototype.set_value = function(value) {
  this.value = value
  if (this.value < 0) this.value = 0
  if (this.value > 1) this.value = 1
}


Slider.prototype.on_mouse_up = function(x,y) {
  this.onselect(this.value)
  this.drag = false
}

Slider.prototype.onselect = function(value) {
}

Slider.prototype.on_mouse_move = function(x,y) {
  if(this.drag) {
    this.set_value((x - (this.x - this.w/2)) / this.w)
  }
}


module.exports = Slider;

},{}],93:[function(require,module,exports){
var ImpulseButton = require('../ui/impulse_button.js');
var Slider = require('../ui/slider.js');

SliderOptionButton.prototype = new ImpulseButton()

SliderOptionButton.prototype.constructor = SliderOptionButton

function SliderOptionButton(text, x, y, w, h, color, hcolor, action, starting_value) {
  this.text = text;
  this.init(x, y, w + 90, h, function(){}, false, color)
  this.slider_x = this.x + this.w/2 - 65;
  this.slider = new Slider(this.slider_x, this.y, 100, 5, this.color)
  this.slider.value = starting_value
  this.slider.onselect = action
  this.hcolor = hcolor;
  this.special_mode = false;
  this.special_text = 'MUTED'
}

SliderOptionButton.prototype.additional_draw = function(ctx) {
  ctx.save();

  ctx.textAlign = 'left'
  ctx.font = '18px Open Sans';
  ctx.fillStyle = this.mouseOver ? this.hcolor : this.color;
  ctx.fillText(this.text, this.x - this.w/2 + 55, this.y + 7);
  if (this.special_mode) {
    ctx.textAlign = 'center'
    ctx.fillText(this.special_text, this.slider_x, this.y + 7);
  } else {
    this.slider.draw(ctx)
  }
  ctx.restore();
}

SliderOptionButton.prototype.on_mouse_down = function(x, y) {
  if (!this.special_mode) {
    this.slider.on_mouse_down(x, y)
  }
}

SliderOptionButton.prototype.on_mouse_up = function(x, y) {
  if (!this.special_mode) {
    this.slider.on_mouse_up(x, y)
  }
}

SliderOptionButton.prototype.on_mouse_move_super = ImpulseButton.prototype.on_mouse_move;

SliderOptionButton.prototype.on_mouse_move = function(x, y) {
  this.on_mouse_move_super(x, y);
  if (!this.special_mode) {
    this.slider.on_mouse_move(x, y);
  }
}

module.exports = SliderOptionButton;

},{"../ui/impulse_button.js":88,"../ui/slider.js":92}],94:[function(require,module,exports){
var ImpulseButton = require('../ui/impulse_button.js');

SmallButton.prototype = new ImpulseButton()

SmallButton.prototype.constructor = SmallButton

function SmallButton(text, size, x, y, w, h, color, hcolor, action) {

  this.text = text
  this.size = size
  this.real_size = size
  this.init(x, y, w, h, action, false, color)
  this.hover_color = hcolor
  this.underline = false
  this.underline_index = null
  this.extra_text = ""
  this.shadow = false
  this.shadowColor = this.color
  this.dim_extra_text = false
}

SmallButton.prototype.additional_draw = function(context) {
  context.save()
  context.beginPath()
  context.textAlign = 'center'

  context.font = this.size+'px Open Sans';
  context.fillStyle = this.hover ? this.hover_color : this.color
  if(this.shadow) {
    context.shadowBlur = 5
    context.shadowColor = this.shadowColor
  } else {
    context.shadowBlur = 0
  }
  context.fillText(this.text, this.x, this.y)
  context.fill()
  if(this.underline_index != null && this.underline_index < this.text.length) {

    context.globalAlpha *= 0.5
    context.beginPath();
    var textStart = context.measureText(this.text.slice(0, this.underline_index)).width;
    var textEnd = context.measureText(this.text.slice(0, this.underline_index+1)).width;
    var textWidth = context.measureText(this.text).width;
    context.moveTo(this.x - textWidth/2 + textStart, this.y + this.size/4);
    context.lineTo(this.x - textWidth/2 + textEnd, this.y + this.size/4);
    context.strokeStyle = this.color;
    context.lineWidth = 1;
    context.stroke();
    context.globalAlpha /= 0.5
    if(this.extra_text != "") {

      context.globalAlpha *= 0.5
      if(this.dim_extra_text) {
        context.globalAlpha *= 0.5
      }
      context.font = this.size/2 + 'px Open Sans'
      context.fillText(this.extra_text, this.x - textWidth/2 + (textStart + textEnd)/2, this.y + 3*this.size/4)
    }
  } else {
    if(this.extra_text != "") {
      context.globalAlpha *= 0.5
      if(this.dim_extra_text) {
        context.globalAlpha *= 0.5
      }
      context.font = this.size/2 + 'px Open Sans'
      var textWidth = context.measureText(this.text).width;
      context.fillText(this.extra_text, this.x, this.y + 3*this.size/4)
    }
  }

  context.restore()
  context.shadowBlur = 0
}

module.exports = SmallButton;

},{"../ui/impulse_button.js":88}],95:[function(require,module,exports){
var enemyRenderUtils = require('../render/enemy.js');

var ImpulseButton = require('../ui/impulse_button.js');

SmallEnemyButton.prototype = new ImpulseButton()

SmallEnemyButton.prototype.constructor = SmallEnemyButton

function SmallEnemyButton(enemy_name, size, x, y, w, h, color, action) {
  this.state = null
  this.enemy_name = enemy_name
  this.size = size
  this.init(x, y, w, h, action, true, color)
  this.enemy_image_size = 30
}

SmallEnemyButton.prototype.additional_draw = function(context) {
  context.save()

  context.save();
  context.beginPath()
  context.rect(this.x - this.w/2, this.y - this.h/2, this.w, this.h)
  context.globalAlpha *=  this.hover ? 1 : 0.5;
  context.fillStyle = this.color;
  context.fill();
  context.restore();
  if (this.bcolor) {
    context.strokeStyle = this.bcolor;
    context.lineWidth = 2;
    context.stroke();
  }

  var cur_x = this.x
  var cur_y = this.y
  enemyRenderUtils.drawEnemy(context, this.enemy_name, cur_x, cur_y, this.enemy_image_size)

  context.restore()
}

module.exports = SmallEnemyButton;

},{"../render/enemy.js":74,"../ui/impulse_button.js":88}],96:[function(require,module,exports){
var constants = require('../data/constants.js');
var saveData = require('../load/save_data.js');
var uiRenderUtils = require('../render/ui.js');

var Fader = require('../game_states/fader_util.js');
var MessageBox = require('../ui/message_box.js');

var TutorialOverlayManager = function(impulse_game_state) {
  this.overlays = [];
  this.impulse_game_state = impulse_game_state;
    this.initial_delay = 2000;
    if (impulse_game_state.level_name.substring(0, 6) == "HIVE 0")
      this.tutorial_level = parseInt(impulse_game_state.level_name.substring(7)) // Take the X of HIVE 0-X.
    this.add_overlays();
}

TutorialOverlayManager.prototype.on_demand_overlays = [
  {type: "reset_multiplier", class: ResetMultiplierTutorialOverlay}
]

TutorialOverlayManager.prototype.add_overlays = function() {
  if (this.impulse_game_state.is_boss_level && this.impulse_game_state.world_num == 1 && saveData.difficultyMode == "easy" &&
      saveData.hasBeatenLevel(this.impulse_game_state.level_name)) {
    this.overlays.push(new KillBossTutorialOverlay(this.impulse_game_state));
  }

  if (this.tutorial_level == 1) {
    this.overlays.push(new MoveTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new GatewayMoveTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new GatewayEnterTutorialOverlay(this.impulse_game_state));
  } else if (this.tutorial_level == 2) {
    this.overlays.push(new VoidTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new TouchEnemyTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new GatewayMoveTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new GatewayEnterTutorialOverlay(this.impulse_game_state));
  } else if (this.tutorial_level == 3) {
    this.overlays.push(new ImpulseTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new KillEnemyTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new ScorePointsTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new ScorePointsReminderTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new GatewayMoveTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new GatewayEnterTutorialOverlay(this.impulse_game_state));
  } else if (this.tutorial_level == 4) {
    this.overlays.push(new EnemyIncrTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new IncrMultiplierTutorialOverlay(this.impulse_game_state));
    this.overlays.push(new ResetMultiplierTutorialOverlay(this.impulse_game_state));
  } else {
    for (var i = 0; i < this.on_demand_overlays.length; i++) {
      if (saveData.tutorialsShown.indexOf(this.on_demand_overlays[i].type) == -1) {
        this.overlays.push(new this.on_demand_overlays[i].class(this.impulse_game_state));
      }
    }
  }
}

TutorialOverlayManager.prototype.draw = function(ctx) {
  if (this.overlays.length == 0) return;
  this.overlays[0].draw_internal(ctx);
}

TutorialOverlayManager.prototype.process = function(dt) {
  if (this.initial_delay > 0) {
    this.initial_delay -= dt
    return;
  }
  if (this.overlays.length == 0) return;
  this.overlays[0].process_internal(dt);

  // If there's an on-demand overlay that's ready, move it to the front.
  if (!this.overlays[0].is_ready()) {
    for (var i = 1; i < this.overlays.length; i++) {
      if (this.overlays[i].on_demand && this.overlays[i].is_ready()) {
        var on_demand_overlay = this.overlays.splice(i, 1)[0];
        this.overlays.unshift(on_demand_overlay);
        continue;
      }
    }
  }
  // Remove all expired overlays.
  if (this.overlays[0].is_expired()) {
    this.overlays.shift();
    while(this.overlays.length > 0 && this.overlays[0].is_satisfied()) {
      this.overlays.shift();
    }
  }
}

var TutorialOverlay = function() {
  // Should never be constructed.
}

TutorialOverlay.prototype.init = function(impulse_game_state) {
  this.impulse_game_state = impulse_game_state;
  this.fader = new Fader({
      "fade_in": 500,
      "fade_out": 500
  });
  this.expired = false;
  this.duration = null; //null means show until the overlay condition is satisfied.
  this.shown = false;
  this.delay_timer = 0
  this.on_demand = false; // show this out of order if it applies.
}

TutorialOverlay.prototype.draw_internal = function(ctx) {
  ctx.save();
  if (this.fader.get_current_animation() == "fade_in") {
    ctx.globalAlpha *= this.fader.get_animation_progress();
  } else if (this.fader.get_current_animation() == "fade_out") {
    ctx.globalAlpha *= 1 - this.fader.get_animation_progress();
  } else if (!this.shown) {
    ctx.globalAlpha = 0;
  }
  ctx.globalAlpha *= 0.8
  if (this.hover_overlay) {
    this.hover_overlay.draw(ctx);
  }
  this.draw(ctx);
  ctx.restore();
}

// Whether we need to wait for an event before showing this overlay.
TutorialOverlay.prototype.is_ready = function() {
  return true;
}

TutorialOverlay.prototype.draw = function(ctx) {}

TutorialOverlay.prototype.process_internal = function(dt) {
  if (!this.is_ready()) return;
  if (!this.shown) {
    if (this.is_satisfied()) {
      this.expired = true;
    } else if (this.delay_timer > 0) {
      this.delay_timer -= dt;
      return;
    } else {
      this.shown = true;
      this.fader.set_animation("fade_in");
      if (this.hover_overlay) {
        this.hover_overlay.set_visible(true);
      }
    }
  }
  if (this.duration > 0) {
    this.duration -= dt;
  }
  if (this.hover_overlay) {
    var pos_x = this.impulse_game_state.player.body.GetPosition().x * constants.drawFactor;
    var pos_y = this.impulse_game_state.player.body.GetPosition().y * constants.drawFactor;
    if (pos_x < this.hover_overlay.w / 2 + 5) {
      pos_x = this.hover_overlay.w / 2 + 5;
    } else if (pos_x > constants.levelWidth - this.hover_overlay.w / 2 - 5) {
      pos_x = constants.levelWidth - this.hover_overlay.w / 2 - 5;
    }

    if (pos_y < this.hover_overlay.h + 55) {
      pos_y += (this.hover_overlay.h + 100);
    }
    this.hover_overlay.set_position(pos_x, pos_y);
  }
  this.fader.process(dt);
  this.process(dt);
  var _this = this;
  if(this.is_satisfied()) {
    this.fader.set_animation("fade_out", function() {
      _this.expired = true;
      _this.on_expire();
    })
  }
}

// Called when the overlay expires.
TutorialOverlay.prototype.on_expire = function() {}

// Whether the player has completed the action to satisfy this overlay.
TutorialOverlay.prototype.satisfaction_criteria = function() {
  return false;
}

// Whether this overlay's condition is satisfied. Can be satisfied by player action, or the duration expiring.
TutorialOverlay.prototype.is_satisfied = function() {
  return this.satisfaction_criteria() || (this.duration != null && this.duration <= 0);
}

// Whether it's time to remove the overlay. This occurs after the fade-out has occurred.
TutorialOverlay.prototype.is_expired = function() {
  return this.expired;
}

TutorialOverlay.prototype.process = function(dt) {}

MoveTutorialOverlay.prototype = new TutorialOverlay;

MoveTutorialOverlay.prototype.constructor = MoveTutorialOverlay;

function MoveTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.hover_overlay = new MessageBox("tutorial_move", impulse_game_state.bright_color, impulse_game_state.world_num);
}

MoveTutorialOverlay.prototype.draw = function(ctx) {
}

MoveTutorialOverlay.prototype.process = function(dt) {

}

MoveTutorialOverlay.prototype.satisfaction_criteria = function() {
  return this.impulse_game_state.tutorial_signals["player_moved"];
}

VoidTutorialOverlay.prototype = new TutorialOverlay;

VoidTutorialOverlay.prototype.constructor = VoidTutorialOverlay;

function VoidTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.hover_overlay = new MessageBox("tutorial_void", impulse_game_state.bright_color, impulse_game_state.world_num);
  this.duration = 3000
}

VoidTutorialOverlay.prototype.draw = function(ctx) {
}

TouchEnemyTutorialOverlay.prototype = new TutorialOverlay;

TouchEnemyTutorialOverlay.prototype.constructor = TouchEnemyTutorialOverlay;

function TouchEnemyTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.hover_overlay = new MessageBox("tutorial_enemy_touch", impulse_game_state.bright_color, impulse_game_state.world_num);
  this.duration = 3000
}

TouchEnemyTutorialOverlay.prototype.draw = function(ctx) {
}

TouchEnemyTutorialOverlay.prototype.process = function(dt) {
}

TouchEnemyTutorialOverlay.prototype.is_ready = function() {
  return this.impulse_game_state.tutorial_signals["enemy_touched"] == "fresh" ||  this.shown;
}

ImpulseTutorialOverlay.prototype = new TutorialOverlay;

ImpulseTutorialOverlay.prototype.constructor = ImpulseTutorialOverlay;

function ImpulseTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.hover_overlay = new MessageBox("tutorial_impulse", impulse_game_state.bright_color, impulse_game_state.world_num);
}

ImpulseTutorialOverlay.prototype.draw = function(ctx) {
}

ImpulseTutorialOverlay.prototype.process = function(dt) {

}

ImpulseTutorialOverlay.prototype.satisfaction_criteria = function() {
  return this.impulse_game_state.tutorial_signals["player_impulsed"];
}

KillEnemyTutorialOverlay.prototype = new TutorialOverlay;

KillEnemyTutorialOverlay.prototype.constructor = KillEnemyTutorialOverlay;

function KillEnemyTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.hover_overlay = new MessageBox("tutorial_kill_enemy", impulse_game_state.bright_color, impulse_game_state.world_num);
  this.delay_timer = 4000
}

KillEnemyTutorialOverlay.prototype.draw = function(ctx) {
}

KillEnemyTutorialOverlay.prototype.process = function(dt) {

}

KillEnemyTutorialOverlay.prototype.satisfaction_criteria = function() {
  return this.impulse_game_state.tutorial_signals["enemy_killed"];
}

PauseTutorialOverlay.prototype = new TutorialOverlay;

PauseTutorialOverlay.prototype.constructor = PauseTutorialOverlay;

function PauseTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.duration = 3000;
  this.hover_overlay = new MessageBox("tutorial_pause", impulse_game_state.bright_color, impulse_game_state.world_num);
}

PauseTutorialOverlay.prototype.is_ready = function() {
  return this.impulse_game_state.tutorial_signals["enemy_killed"];
}

PauseTutorialOverlay.prototype.draw = function(ctx) {
}

PauseTutorialOverlay.prototype.process = function(dt) {

}



ScorePointsTutorialOverlay.prototype = new TutorialOverlay;

ScorePointsTutorialOverlay.prototype.constructor = ScorePointsTutorialOverlay;

function ScorePointsTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.duration = 5000;
  this.hover_overlay = new MessageBox("tutorial_score_points", impulse_game_state.bright_color, impulse_game_state.world_num);
}

ScorePointsTutorialOverlay.prototype.is_ready = function() {
  return this.impulse_game_state.tutorial_signals["enemy_killed"];
}

ScorePointsTutorialOverlay.prototype.draw = function(ctx) {
  ctx.fillStyle = "cyan";
  ctx.strokeStyle = "cyan";
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.textAlign = "center"
  var rw = 120;
  var rh = 80;
  ctx.rect(constants.levelWidth + constants.sideBarWidth/2 - rw/2, 75 - rh/2 - 20, rw, rh);
  ctx.stroke();
  ctx.font = '21px Open Sans'
    ctx.fillText("GOAL", constants.levelWidth + constants.sideBarWidth/2, 45)
    ctx.font = '42px Open Sans'
    ctx.fillText(this.impulse_game_state.level.cutoff_scores[0], constants.levelWidth + constants.sideBarWidth/2, 85)
}

ScorePointsReminderTutorialOverlay.prototype = new TutorialOverlay;

ScorePointsReminderTutorialOverlay.prototype.constructor = ScorePointsReminderTutorialOverlay;

function ScorePointsReminderTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.hover_overlay = new MessageBox("tutorial_score_points", impulse_game_state.bright_color, impulse_game_state.world_num);
  this.delay_timer = 5000
}

ScorePointsReminderTutorialOverlay.prototype.draw = function(ctx) {
  ctx.fillStyle = "cyan";
  ctx.strokeStyle = "cyan";
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.textAlign = "center"
  var rw = 120;
  var rh = 80;
  ctx.rect(constants.levelWidth + constants.sideBarWidth/2 - rw/2, 75 - rh/2 - 20, rw, rh);
  ctx.stroke();
  ctx.font = '21px Open Sans'
    ctx.fillText("GOAL", constants.levelWidth + constants.sideBarWidth/2, 45)
    ctx.font = '42px Open Sans'
    ctx.fillText(this.impulse_game_state.level.cutoff_scores[0], constants.levelWidth + constants.sideBarWidth/2, 85)
}

ScorePointsReminderTutorialOverlay.prototype.satisfaction_criteria = function() {
  return this.impulse_game_state.tutorial_signals["gateway_opened"];
}

EnemyIncrTutorialOverlay.prototype = new TutorialOverlay;

EnemyIncrTutorialOverlay.prototype.constructor = EnemyIncrTutorialOverlay;

function EnemyIncrTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.on_demand = true;
  this.duration = 3000;
  this.hover_overlay = new MessageBox("tutorial_enemy_incr", impulse_game_state.bright_color, impulse_game_state.world_num);
}

EnemyIncrTutorialOverlay.prototype.draw = function(ctx) {

  ctx.textAlign = "center"
  ctx.fillStyle = "cyan";
  ctx.strokeStyle = "cyan";
  ctx.lineWidth = 8;
  ctx.beginPath();
  var rw = 120;
  var rh = 70;
  ctx.rect(-constants.sideBarWidth / 2 - rw / 2, constants.canvasHeight/2 - 20 - rh / 2, rw, rh);
  ctx.stroke();
  ctx.font = '16px Open Sans';
  ctx.fillText("LEVEL TIME",  -constants.sideBarWidth/2, constants.canvasHeight/2 - 30);
  ctx.font = '32px Open Sans';
  ctx.fillText(this.impulse_game_state.game_numbers.last_time, -constants.sideBarWidth/2, constants.canvasHeight/2 + 2);
}

EnemyIncrTutorialOverlay.prototype.process = function(dt) {

}

IncrMultiplierTutorialOverlay.prototype = new TutorialOverlay;

IncrMultiplierTutorialOverlay.prototype.constructor = IncrMultiplierTutorialOverlay;

function IncrMultiplierTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.duration = 3000;
  this.hover_overlay = new MessageBox("tutorial_incr_multiplier", impulse_game_state.bright_color, impulse_game_state.world_num);
}

IncrMultiplierTutorialOverlay.prototype.is_ready = function() {
  return this.impulse_game_state.tutorial_signals["enemy_killed"] == "fresh" ||  this.shown;
}

IncrMultiplierTutorialOverlay.prototype.draw = function(ctx) {
  ctx.textAlign = "center"
  ctx.fillStyle = "cyan";
  ctx.strokeStyle = "cyan";
  ctx.lineWidth = 8;
  ctx.beginPath();
  var rw = 100;
  var rh = 100;
  ctx.rect(constants.levelWidth + constants.sideBarWidth/2 - rw/2, constants.canvasHeight/2 - rh/2 - 20, rw, rh);
  ctx.stroke();
    ctx.font = '72px Open Sans';
    ctx.fillText("x"+this.impulse_game_state.game_numbers.combo, constants.levelWidth + constants.sideBarWidth/2, constants.canvasHeight/2)
}

IncrMultiplierTutorialOverlay.prototype.process = function(dt) {
}

ResetMultiplierTutorialOverlay.prototype = new TutorialOverlay;

ResetMultiplierTutorialOverlay.prototype.constructor = ResetMultiplierTutorialOverlay;

function ResetMultiplierTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.duration = 3000;
  this.on_demand = true;
  this.hover_overlay = new MessageBox("tutorial_reset_multiplier", impulse_game_state.bright_color, impulse_game_state.world_num);
}

ResetMultiplierTutorialOverlay.prototype.is_ready = function() {
  return this.impulse_game_state.tutorial_signals["multiplier_reset"] == "fresh" ||  this.shown;
}

ResetMultiplierTutorialOverlay.prototype.draw = function(ctx) {
}

ResetMultiplierTutorialOverlay.prototype.process = function(dt) {
}

ResetMultiplierTutorialOverlay.prototype.on_expire = function() {
  if(saveData.tutorialsShown.indexOf("reset_multiplier") == -1) {
    saveData.tutorialsShown.push("reset_multiplier");
    saveData.saveGame();
  }
}

GatewayMoveTutorialOverlay.prototype = new TutorialOverlay;

GatewayMoveTutorialOverlay.prototype.constructor = GatewayMoveTutorialOverlay;

function GatewayMoveTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.gateway_loc = {
    x: this.impulse_game_state.level.gateway_loc.x * constants.drawFactor,
    y: this.impulse_game_state.level.gateway_loc.y * constants.drawFactor};
  this.message_box = new MessageBox("tutorial_gateway_move", impulse_game_state.bright_color, impulse_game_state.world_num);
  this.message_box.set_position(this.gateway_loc.x, this.gateway_loc.y - 30);
  this.message_box.set_visible(true);

}

GatewayMoveTutorialOverlay.prototype.draw = function(ctx) {

    this.message_box.draw(ctx);
  return;

  // draws an error but we no longer use it.
  ctx.globalAlpha *= 0.5
  var offset = (window.performance.now() % 1500) / 1500;
  var prog = 0;
  if (offset > 1/2) {
    prog = (1 - offset) * 2;
  } else {
    prog = offset * 2;
  }
    ctx.beginPath();
    ctx.moveTo(this.gateway_loc.x + 16, this.gateway_loc.y - 82 - prog * 50);
    ctx.lineTo(this.gateway_loc.x, this.gateway_loc.y - 50 - prog * 50);
    ctx.lineTo(this.gateway_loc.x - 16, this.gateway_loc.y - 82 - prog * 50);
    ctx.closePath()
    ctx.lineWidth = 4
    ctx.fillStyle = "black";
    ctx.fill();
    ctx.strokeStyle = "white"
    ctx.stroke();
}

GatewayMoveTutorialOverlay.prototype.process = function(dt) {

}

// Whether we need to wait for an event before showing this overlay.
GatewayMoveTutorialOverlay.prototype.is_ready = function() {
  return this.impulse_game_state.tutorial_signals["gateway_opened"];
}

GatewayMoveTutorialOverlay.prototype.satisfaction_criteria = function() {
  return this.impulse_game_state.tutorial_signals["moved_to_gateway"];
}

GatewayEnterTutorialOverlay.prototype = new TutorialOverlay;

GatewayEnterTutorialOverlay.prototype.constructor = GatewayEnterTutorialOverlay;

function GatewayEnterTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.duration = 3000;
  this.hover_overlay = new MessageBox("tutorial_enter_gateway", impulse_game_state.bright_color, impulse_game_state.world_num);
}

GatewayEnterTutorialOverlay.prototype.draw = function(ctx) {
}

GatewayEnterTutorialOverlay.prototype.process = function(dt) {
}

KillBossTutorialOverlay.prototype = new TutorialOverlay;

KillBossTutorialOverlay.prototype.constructor = KillBossTutorialOverlay;

function KillBossTutorialOverlay(impulse_game_state) {
  this.init(impulse_game_state);
  this.duration = 3000;
  this.hover_overlay = new MessageBox("tutorial_kill_boss", impulse_game_state.bright_color, impulse_game_state.world_num);
}

KillBossTutorialOverlay.prototype.draw = function(ctx) {
}

KillBossTutorialOverlay.prototype.process = function(dt) {
}

var tutorialOverlays = {
  Manager: TutorialOverlayManager,
};

module.exports = tutorialOverlays;

},{"../data/constants.js":13,"../game_states/fader_util.js":47,"../load/save_data.js":69,"../render/ui.js":82,"../ui/message_box.js":89}],97:[function(require,module,exports){
// Box2dWeb-2.1.a.3.min.js

var Box2D={};
(function(F,G){function K(){}if(!(Object.prototype.defineProperty instanceof Function)&&Object.prototype.__defineGetter__ instanceof Function&&Object.prototype.__defineSetter__ instanceof Function)Object.defineProperty=function(y,w,A){A.get instanceof Function&&y.__defineGetter__(w,A.get);A.set instanceof Function&&y.__defineSetter__(w,A.set)};F.inherit=function(y,w){K.prototype=w.prototype;y.prototype=new K;y.prototype.constructor=y};F.generateCallback=function(y,w){return function(){w.apply(y,arguments)}};
F.NVector=function(y){if(y===G)y=0;for(var w=Array(y||0),A=0;A<y;++A)w[A]=0;return w};F.is=function(y,w){if(y===null)return false;if(w instanceof Function&&y instanceof w)return true;if(y.constructor.__implements!=G&&y.constructor.__implements[w])return true;return false};F.parseUInt=function(y){return Math.abs(parseInt(y))}})(Box2D);var Vector=Array,Vector_a2j_Number=Box2D.NVector;if(typeof Box2D==="undefined")Box2D={};if(typeof Box2D.Collision==="undefined")Box2D.Collision={};
if(typeof Box2D.Collision.Shapes==="undefined")Box2D.Collision.Shapes={};if(typeof Box2D.Common==="undefined")Box2D.Common={};if(typeof Box2D.Common.Math==="undefined")Box2D.Common.Math={};if(typeof Box2D.Dynamics==="undefined")Box2D.Dynamics={};if(typeof Box2D.Dynamics.Contacts==="undefined")Box2D.Dynamics.Contacts={};if(typeof Box2D.Dynamics.Controllers==="undefined")Box2D.Dynamics.Controllers={};if(typeof Box2D.Dynamics.Joints==="undefined")Box2D.Dynamics.Joints={};
(function(){function F(){F.b2AABB.apply(this,arguments)}function G(){G.b2Bound.apply(this,arguments)}function K(){K.b2BoundValues.apply(this,arguments);this.constructor===K&&this.b2BoundValues.apply(this,arguments)}function y(){y.b2Collision.apply(this,arguments)}function w(){w.b2ContactID.apply(this,arguments);this.constructor===w&&this.b2ContactID.apply(this,arguments)}function A(){A.b2ContactPoint.apply(this,arguments)}function U(){U.b2Distance.apply(this,arguments)}function p(){p.b2DistanceInput.apply(this,
arguments)}function B(){B.b2DistanceOutput.apply(this,arguments)}function Q(){Q.b2DistanceProxy.apply(this,arguments)}function V(){V.b2DynamicTree.apply(this,arguments);this.constructor===V&&this.b2DynamicTree.apply(this,arguments)}function M(){M.b2DynamicTreeBroadPhase.apply(this,arguments)}function L(){L.b2DynamicTreeNode.apply(this,arguments)}function I(){I.b2DynamicTreePair.apply(this,arguments)}function W(){W.b2Manifold.apply(this,arguments);this.constructor===W&&this.b2Manifold.apply(this,arguments)}
function Y(){Y.b2ManifoldPoint.apply(this,arguments);this.constructor===Y&&this.b2ManifoldPoint.apply(this,arguments)}function k(){k.b2Point.apply(this,arguments)}function z(){z.b2RayCastInput.apply(this,arguments);this.constructor===z&&this.b2RayCastInput.apply(this,arguments)}function u(){u.b2RayCastOutput.apply(this,arguments)}function D(){D.b2Segment.apply(this,arguments)}function H(){H.b2SeparationFunction.apply(this,arguments)}function O(){O.b2Simplex.apply(this,arguments);this.constructor===
O&&this.b2Simplex.apply(this,arguments)}function E(){E.b2SimplexCache.apply(this,arguments)}function R(){R.b2SimplexVertex.apply(this,arguments)}function N(){N.b2TimeOfImpact.apply(this,arguments)}function S(){S.b2TOIInput.apply(this,arguments)}function aa(){aa.b2WorldManifold.apply(this,arguments);this.constructor===aa&&this.b2WorldManifold.apply(this,arguments)}function Z(){Z.ClipVertex.apply(this,arguments)}function d(){d.Features.apply(this,arguments)}function h(){h.b2CircleShape.apply(this,arguments);
this.constructor===h&&this.b2CircleShape.apply(this,arguments)}function l(){l.b2EdgeChainDef.apply(this,arguments);this.constructor===l&&this.b2EdgeChainDef.apply(this,arguments)}function j(){j.b2EdgeShape.apply(this,arguments);this.constructor===j&&this.b2EdgeShape.apply(this,arguments)}function o(){o.b2MassData.apply(this,arguments)}function q(){q.b2PolygonShape.apply(this,arguments);this.constructor===q&&this.b2PolygonShape.apply(this,arguments)}function n(){n.b2Shape.apply(this,arguments);this.constructor===
n&&this.b2Shape.apply(this,arguments)}function a(){a.b2Color.apply(this,arguments);this.constructor===a&&this.b2Color.apply(this,arguments)}function c(){c.b2Settings.apply(this,arguments)}function g(){g.b2Mat22.apply(this,arguments);this.constructor===g&&this.b2Mat22.apply(this,arguments)}function b(){b.b2Mat33.apply(this,arguments);this.constructor===b&&this.b2Mat33.apply(this,arguments)}function e(){e.b2Math.apply(this,arguments)}function f(){f.b2Sweep.apply(this,arguments)}function m(){m.b2Transform.apply(this,
arguments);this.constructor===m&&this.b2Transform.apply(this,arguments)}function r(){r.b2Vec2.apply(this,arguments);this.constructor===r&&this.b2Vec2.apply(this,arguments)}function s(){s.b2Vec3.apply(this,arguments);this.constructor===s&&this.b2Vec3.apply(this,arguments)}function v(){v.b2Body.apply(this,arguments);this.constructor===v&&this.b2Body.apply(this,arguments)}function t(){t.b2BodyDef.apply(this,arguments);this.constructor===t&&this.b2BodyDef.apply(this,arguments)}function x(){x.b2ContactFilter.apply(this,
arguments)}function C(){C.b2ContactImpulse.apply(this,arguments)}function J(){J.b2ContactListener.apply(this,arguments)}function T(){T.b2ContactManager.apply(this,arguments);this.constructor===T&&this.b2ContactManager.apply(this,arguments)}function P(){P.b2DebugDraw.apply(this,arguments);this.constructor===P&&this.b2DebugDraw.apply(this,arguments)}function X(){X.b2DestructionListener.apply(this,arguments)}function $(){$.b2FilterData.apply(this,arguments)}function ba(){ba.b2Fixture.apply(this,arguments);
this.constructor===ba&&this.b2Fixture.apply(this,arguments)}function ca(){ca.b2FixtureDef.apply(this,arguments);this.constructor===ca&&this.b2FixtureDef.apply(this,arguments)}function da(){da.b2Island.apply(this,arguments);this.constructor===da&&this.b2Island.apply(this,arguments)}function Fa(){Fa.b2TimeStep.apply(this,arguments)}function ea(){ea.b2World.apply(this,arguments);this.constructor===ea&&this.b2World.apply(this,arguments)}function Ga(){Ga.b2CircleContact.apply(this,arguments)}function fa(){fa.b2Contact.apply(this,
arguments);this.constructor===fa&&this.b2Contact.apply(this,arguments)}function ga(){ga.b2ContactConstraint.apply(this,arguments);this.constructor===ga&&this.b2ContactConstraint.apply(this,arguments)}function Ha(){Ha.b2ContactConstraintPoint.apply(this,arguments)}function Ia(){Ia.b2ContactEdge.apply(this,arguments)}function ha(){ha.b2ContactFactory.apply(this,arguments);this.constructor===ha&&this.b2ContactFactory.apply(this,arguments)}function Ja(){Ja.b2ContactRegister.apply(this,arguments)}function Ka(){Ka.b2ContactResult.apply(this,
arguments)}function ia(){ia.b2ContactSolver.apply(this,arguments);this.constructor===ia&&this.b2ContactSolver.apply(this,arguments)}function La(){La.b2EdgeAndCircleContact.apply(this,arguments)}function ja(){ja.b2NullContact.apply(this,arguments);this.constructor===ja&&this.b2NullContact.apply(this,arguments)}function Ma(){Ma.b2PolyAndCircleContact.apply(this,arguments)}function Na(){Na.b2PolyAndEdgeContact.apply(this,arguments)}function Oa(){Oa.b2PolygonContact.apply(this,arguments)}function ka(){ka.b2PositionSolverManifold.apply(this,
arguments);this.constructor===ka&&this.b2PositionSolverManifold.apply(this,arguments)}function Pa(){Pa.b2BuoyancyController.apply(this,arguments)}function Qa(){Qa.b2ConstantAccelController.apply(this,arguments)}function Ra(){Ra.b2ConstantForceController.apply(this,arguments)}function Sa(){Sa.b2Controller.apply(this,arguments)}function Ta(){Ta.b2ControllerEdge.apply(this,arguments)}function Ua(){Ua.b2GravityController.apply(this,arguments)}function Va(){Va.b2TensorDampingController.apply(this,arguments)}
function la(){la.b2DistanceJoint.apply(this,arguments);this.constructor===la&&this.b2DistanceJoint.apply(this,arguments)}function ma(){ma.b2DistanceJointDef.apply(this,arguments);this.constructor===ma&&this.b2DistanceJointDef.apply(this,arguments)}function na(){na.b2FrictionJoint.apply(this,arguments);this.constructor===na&&this.b2FrictionJoint.apply(this,arguments)}function oa(){oa.b2FrictionJointDef.apply(this,arguments);this.constructor===oa&&this.b2FrictionJointDef.apply(this,arguments)}function pa(){pa.b2GearJoint.apply(this,
arguments);this.constructor===pa&&this.b2GearJoint.apply(this,arguments)}function qa(){qa.b2GearJointDef.apply(this,arguments);this.constructor===qa&&this.b2GearJointDef.apply(this,arguments)}function Wa(){Wa.b2Jacobian.apply(this,arguments)}function ra(){ra.b2Joint.apply(this,arguments);this.constructor===ra&&this.b2Joint.apply(this,arguments)}function sa(){sa.b2JointDef.apply(this,arguments);this.constructor===sa&&this.b2JointDef.apply(this,arguments)}function Xa(){Xa.b2JointEdge.apply(this,arguments)}
function ta(){ta.b2LineJoint.apply(this,arguments);this.constructor===ta&&this.b2LineJoint.apply(this,arguments)}function ua(){ua.b2LineJointDef.apply(this,arguments);this.constructor===ua&&this.b2LineJointDef.apply(this,arguments)}function va(){va.b2MouseJoint.apply(this,arguments);this.constructor===va&&this.b2MouseJoint.apply(this,arguments)}function wa(){wa.b2MouseJointDef.apply(this,arguments);this.constructor===wa&&this.b2MouseJointDef.apply(this,arguments)}function xa(){xa.b2PrismaticJoint.apply(this,
arguments);this.constructor===xa&&this.b2PrismaticJoint.apply(this,arguments)}function ya(){ya.b2PrismaticJointDef.apply(this,arguments);this.constructor===ya&&this.b2PrismaticJointDef.apply(this,arguments)}function za(){za.b2PulleyJoint.apply(this,arguments);this.constructor===za&&this.b2PulleyJoint.apply(this,arguments)}function Aa(){Aa.b2PulleyJointDef.apply(this,arguments);this.constructor===Aa&&this.b2PulleyJointDef.apply(this,arguments)}function Ba(){Ba.b2RevoluteJoint.apply(this,arguments);
this.constructor===Ba&&this.b2RevoluteJoint.apply(this,arguments)}function Ca(){Ca.b2RevoluteJointDef.apply(this,arguments);this.constructor===Ca&&this.b2RevoluteJointDef.apply(this,arguments)}function Da(){Da.b2WeldJoint.apply(this,arguments);this.constructor===Da&&this.b2WeldJoint.apply(this,arguments)}function Ea(){Ea.b2WeldJointDef.apply(this,arguments);this.constructor===Ea&&this.b2WeldJointDef.apply(this,arguments)}Box2D.Collision.IBroadPhase="Box2D.Collision.IBroadPhase";Box2D.Collision.b2AABB=
F;Box2D.Collision.b2Bound=G;Box2D.Collision.b2BoundValues=K;Box2D.Collision.b2Collision=y;Box2D.Collision.b2ContactID=w;Box2D.Collision.b2ContactPoint=A;Box2D.Collision.b2Distance=U;Box2D.Collision.b2DistanceInput=p;Box2D.Collision.b2DistanceOutput=B;Box2D.Collision.b2DistanceProxy=Q;Box2D.Collision.b2DynamicTree=V;Box2D.Collision.b2DynamicTreeBroadPhase=M;Box2D.Collision.b2DynamicTreeNode=L;Box2D.Collision.b2DynamicTreePair=I;Box2D.Collision.b2Manifold=W;Box2D.Collision.b2ManifoldPoint=Y;Box2D.Collision.b2Point=
k;Box2D.Collision.b2RayCastInput=z;Box2D.Collision.b2RayCastOutput=u;Box2D.Collision.b2Segment=D;Box2D.Collision.b2SeparationFunction=H;Box2D.Collision.b2Simplex=O;Box2D.Collision.b2SimplexCache=E;Box2D.Collision.b2SimplexVertex=R;Box2D.Collision.b2TimeOfImpact=N;Box2D.Collision.b2TOIInput=S;Box2D.Collision.b2WorldManifold=aa;Box2D.Collision.ClipVertex=Z;Box2D.Collision.Features=d;Box2D.Collision.Shapes.b2CircleShape=h;Box2D.Collision.Shapes.b2EdgeChainDef=l;Box2D.Collision.Shapes.b2EdgeShape=j;Box2D.Collision.Shapes.b2MassData=
o;Box2D.Collision.Shapes.b2PolygonShape=q;Box2D.Collision.Shapes.b2Shape=n;Box2D.Common.b2internal="Box2D.Common.b2internal";Box2D.Common.b2Color=a;Box2D.Common.b2Settings=c;Box2D.Common.Math.b2Mat22=g;Box2D.Common.Math.b2Mat33=b;Box2D.Common.Math.b2Math=e;Box2D.Common.Math.b2Sweep=f;Box2D.Common.Math.b2Transform=m;Box2D.Common.Math.b2Vec2=r;Box2D.Common.Math.b2Vec3=s;Box2D.Dynamics.b2Body=v;Box2D.Dynamics.b2BodyDef=t;Box2D.Dynamics.b2ContactFilter=x;Box2D.Dynamics.b2ContactImpulse=C;Box2D.Dynamics.b2ContactListener=
J;Box2D.Dynamics.b2ContactManager=T;Box2D.Dynamics.b2DebugDraw=P;Box2D.Dynamics.b2DestructionListener=X;Box2D.Dynamics.b2FilterData=$;Box2D.Dynamics.b2Fixture=ba;Box2D.Dynamics.b2FixtureDef=ca;Box2D.Dynamics.b2Island=da;Box2D.Dynamics.b2TimeStep=Fa;Box2D.Dynamics.b2World=ea;Box2D.Dynamics.Contacts.b2CircleContact=Ga;Box2D.Dynamics.Contacts.b2Contact=fa;Box2D.Dynamics.Contacts.b2ContactConstraint=ga;Box2D.Dynamics.Contacts.b2ContactConstraintPoint=Ha;Box2D.Dynamics.Contacts.b2ContactEdge=Ia;Box2D.Dynamics.Contacts.b2ContactFactory=
ha;Box2D.Dynamics.Contacts.b2ContactRegister=Ja;Box2D.Dynamics.Contacts.b2ContactResult=Ka;Box2D.Dynamics.Contacts.b2ContactSolver=ia;Box2D.Dynamics.Contacts.b2EdgeAndCircleContact=La;Box2D.Dynamics.Contacts.b2NullContact=ja;Box2D.Dynamics.Contacts.b2PolyAndCircleContact=Ma;Box2D.Dynamics.Contacts.b2PolyAndEdgeContact=Na;Box2D.Dynamics.Contacts.b2PolygonContact=Oa;Box2D.Dynamics.Contacts.b2PositionSolverManifold=ka;Box2D.Dynamics.Controllers.b2BuoyancyController=Pa;Box2D.Dynamics.Controllers.b2ConstantAccelController=
Qa;Box2D.Dynamics.Controllers.b2ConstantForceController=Ra;Box2D.Dynamics.Controllers.b2Controller=Sa;Box2D.Dynamics.Controllers.b2ControllerEdge=Ta;Box2D.Dynamics.Controllers.b2GravityController=Ua;Box2D.Dynamics.Controllers.b2TensorDampingController=Va;Box2D.Dynamics.Joints.b2DistanceJoint=la;Box2D.Dynamics.Joints.b2DistanceJointDef=ma;Box2D.Dynamics.Joints.b2FrictionJoint=na;Box2D.Dynamics.Joints.b2FrictionJointDef=oa;Box2D.Dynamics.Joints.b2GearJoint=pa;Box2D.Dynamics.Joints.b2GearJointDef=qa;
Box2D.Dynamics.Joints.b2Jacobian=Wa;Box2D.Dynamics.Joints.b2Joint=ra;Box2D.Dynamics.Joints.b2JointDef=sa;Box2D.Dynamics.Joints.b2JointEdge=Xa;Box2D.Dynamics.Joints.b2LineJoint=ta;Box2D.Dynamics.Joints.b2LineJointDef=ua;Box2D.Dynamics.Joints.b2MouseJoint=va;Box2D.Dynamics.Joints.b2MouseJointDef=wa;Box2D.Dynamics.Joints.b2PrismaticJoint=xa;Box2D.Dynamics.Joints.b2PrismaticJointDef=ya;Box2D.Dynamics.Joints.b2PulleyJoint=za;Box2D.Dynamics.Joints.b2PulleyJointDef=Aa;Box2D.Dynamics.Joints.b2RevoluteJoint=
Ba;Box2D.Dynamics.Joints.b2RevoluteJointDef=Ca;Box2D.Dynamics.Joints.b2WeldJoint=Da;Box2D.Dynamics.Joints.b2WeldJointDef=Ea})();Box2D.postDefs=[];
(function(){var F=Box2D.Collision.Shapes.b2CircleShape,G=Box2D.Collision.Shapes.b2PolygonShape,K=Box2D.Collision.Shapes.b2Shape,y=Box2D.Common.b2Settings,w=Box2D.Common.Math.b2Math,A=Box2D.Common.Math.b2Sweep,U=Box2D.Common.Math.b2Transform,p=Box2D.Common.Math.b2Vec2,B=Box2D.Collision.b2AABB,Q=Box2D.Collision.b2Bound,V=Box2D.Collision.b2BoundValues,M=Box2D.Collision.b2Collision,L=Box2D.Collision.b2ContactID,I=Box2D.Collision.b2ContactPoint,W=Box2D.Collision.b2Distance,Y=Box2D.Collision.b2DistanceInput,
k=Box2D.Collision.b2DistanceOutput,z=Box2D.Collision.b2DistanceProxy,u=Box2D.Collision.b2DynamicTree,D=Box2D.Collision.b2DynamicTreeBroadPhase,H=Box2D.Collision.b2DynamicTreeNode,O=Box2D.Collision.b2DynamicTreePair,E=Box2D.Collision.b2Manifold,R=Box2D.Collision.b2ManifoldPoint,N=Box2D.Collision.b2Point,S=Box2D.Collision.b2RayCastInput,aa=Box2D.Collision.b2RayCastOutput,Z=Box2D.Collision.b2Segment,d=Box2D.Collision.b2SeparationFunction,h=Box2D.Collision.b2Simplex,l=Box2D.Collision.b2SimplexCache,j=
Box2D.Collision.b2SimplexVertex,o=Box2D.Collision.b2TimeOfImpact,q=Box2D.Collision.b2TOIInput,n=Box2D.Collision.b2WorldManifold,a=Box2D.Collision.ClipVertex,c=Box2D.Collision.Features,g=Box2D.Collision.IBroadPhase;B.b2AABB=function(){this.lowerBound=new p;this.upperBound=new p};B.prototype.IsValid=function(){var b=this.upperBound.y-this.lowerBound.y;return b=(b=this.upperBound.x-this.lowerBound.x>=0&&b>=0)&&this.lowerBound.IsValid()&&this.upperBound.IsValid()};B.prototype.GetCenter=function(){return new p((this.lowerBound.x+
this.upperBound.x)/2,(this.lowerBound.y+this.upperBound.y)/2)};B.prototype.GetExtents=function(){return new p((this.upperBound.x-this.lowerBound.x)/2,(this.upperBound.y-this.lowerBound.y)/2)};B.prototype.Contains=function(b){var e=true;return e=(e=(e=(e=e&&this.lowerBound.x<=b.lowerBound.x)&&this.lowerBound.y<=b.lowerBound.y)&&b.upperBound.x<=this.upperBound.x)&&b.upperBound.y<=this.upperBound.y};B.prototype.RayCast=function(b,e){var f=-Number.MAX_VALUE,m=Number.MAX_VALUE,r=e.p1.x,s=e.p1.y,v=e.p2.x-
e.p1.x,t=e.p2.y-e.p1.y,x=Math.abs(t),C=b.normal,J=0,T=0,P=J=0;P=0;if(Math.abs(v)<Number.MIN_VALUE){if(r<this.lowerBound.x||this.upperBound.x<r)return false}else{J=1/v;T=(this.lowerBound.x-r)*J;J=(this.upperBound.x-r)*J;P=-1;if(T>J){P=T;T=J;J=P;P=1}if(T>f){C.x=P;C.y=0;f=T}m=Math.min(m,J);if(f>m)return false}if(x<Number.MIN_VALUE){if(s<this.lowerBound.y||this.upperBound.y<s)return false}else{J=1/t;T=(this.lowerBound.y-s)*J;J=(this.upperBound.y-s)*J;P=-1;if(T>J){P=T;T=J;J=P;P=1}if(T>f){C.y=P;C.x=0;f=
T}m=Math.min(m,J);if(f>m)return false}b.fraction=f;return true};B.prototype.TestOverlap=function(b){var e=b.lowerBound.y-this.upperBound.y,f=this.lowerBound.y-b.upperBound.y;if(b.lowerBound.x-this.upperBound.x>0||e>0)return false;if(this.lowerBound.x-b.upperBound.x>0||f>0)return false;return true};B.Combine=function(b,e){var f=new B;f.Combine(b,e);return f};B.prototype.Combine=function(b,e){this.lowerBound.x=Math.min(b.lowerBound.x,e.lowerBound.x);this.lowerBound.y=Math.min(b.lowerBound.y,e.lowerBound.y);
this.upperBound.x=Math.max(b.upperBound.x,e.upperBound.x);this.upperBound.y=Math.max(b.upperBound.y,e.upperBound.y)};Q.b2Bound=function(){};Q.prototype.IsLower=function(){return(this.value&1)==0};Q.prototype.IsUpper=function(){return(this.value&1)==1};Q.prototype.Swap=function(b){var e=this.value,f=this.proxy,m=this.stabbingCount;this.value=b.value;this.proxy=b.proxy;this.stabbingCount=b.stabbingCount;b.value=e;b.proxy=f;b.stabbingCount=m};V.b2BoundValues=function(){};V.prototype.b2BoundValues=function(){this.lowerValues=
new Vector_a2j_Number;this.lowerValues[0]=0;this.lowerValues[1]=0;this.upperValues=new Vector_a2j_Number;this.upperValues[0]=0;this.upperValues[1]=0};M.b2Collision=function(){};M.ClipSegmentToLine=function(b,e,f,m){if(m===undefined)m=0;var r,s=0;r=e[0];var v=r.v;r=e[1];var t=r.v,x=f.x*v.x+f.y*v.y-m;r=f.x*t.x+f.y*t.y-m;x<=0&&b[s++].Set(e[0]);r<=0&&b[s++].Set(e[1]);if(x*r<0){f=x/(x-r);r=b[s];r=r.v;r.x=v.x+f*(t.x-v.x);r.y=v.y+f*(t.y-v.y);r=b[s];r.id=(x>0?e[0]:e[1]).id;++s}return s};M.EdgeSeparation=
function(b,e,f,m,r){if(f===undefined)f=0;parseInt(b.m_vertexCount);var s=b.m_vertices;b=b.m_normals;var v=parseInt(m.m_vertexCount),t=m.m_vertices,x,C;x=e.R;C=b[f];b=x.col1.x*C.x+x.col2.x*C.y;m=x.col1.y*C.x+x.col2.y*C.y;x=r.R;var J=x.col1.x*b+x.col1.y*m;x=x.col2.x*b+x.col2.y*m;for(var T=0,P=Number.MAX_VALUE,X=0;X<v;++X){C=t[X];C=C.x*J+C.y*x;if(C<P){P=C;T=X}}C=s[f];x=e.R;f=e.position.x+(x.col1.x*C.x+x.col2.x*C.y);e=e.position.y+(x.col1.y*C.x+x.col2.y*C.y);C=t[T];x=r.R;s=r.position.x+(x.col1.x*C.x+
x.col2.x*C.y);r=r.position.y+(x.col1.y*C.x+x.col2.y*C.y);s-=f;r-=e;return s*b+r*m};M.FindMaxSeparation=function(b,e,f,m,r){var s=parseInt(e.m_vertexCount),v=e.m_normals,t,x;x=r.R;t=m.m_centroid;var C=r.position.x+(x.col1.x*t.x+x.col2.x*t.y),J=r.position.y+(x.col1.y*t.x+x.col2.y*t.y);x=f.R;t=e.m_centroid;C-=f.position.x+(x.col1.x*t.x+x.col2.x*t.y);J-=f.position.y+(x.col1.y*t.x+x.col2.y*t.y);x=C*f.R.col1.x+J*f.R.col1.y;J=C*f.R.col2.x+J*f.R.col2.y;C=0;for(var T=-Number.MAX_VALUE,P=0;P<s;++P){t=v[P];
t=t.x*x+t.y*J;if(t>T){T=t;C=P}}v=M.EdgeSeparation(e,f,C,m,r);t=parseInt(C-1>=0?C-1:s-1);x=M.EdgeSeparation(e,f,t,m,r);J=parseInt(C+1<s?C+1:0);T=M.EdgeSeparation(e,f,J,m,r);var X=P=0,$=0;if(x>v&&x>T){$=-1;P=t;X=x}else if(T>v){$=1;P=J;X=T}else{b[0]=C;return v}for(;;){C=$==-1?P-1>=0?P-1:s-1:P+1<s?P+1:0;v=M.EdgeSeparation(e,f,C,m,r);if(v>X){P=C;X=v}else break}b[0]=P;return X};M.FindIncidentEdge=function(b,e,f,m,r,s){if(m===undefined)m=0;parseInt(e.m_vertexCount);var v=e.m_normals,t=parseInt(r.m_vertexCount);
e=r.m_vertices;r=r.m_normals;var x;x=f.R;f=v[m];v=x.col1.x*f.x+x.col2.x*f.y;var C=x.col1.y*f.x+x.col2.y*f.y;x=s.R;f=x.col1.x*v+x.col1.y*C;C=x.col2.x*v+x.col2.y*C;v=f;x=0;for(var J=Number.MAX_VALUE,T=0;T<t;++T){f=r[T];f=v*f.x+C*f.y;if(f<J){J=f;x=T}}r=parseInt(x);v=parseInt(r+1<t?r+1:0);t=b[0];f=e[r];x=s.R;t.v.x=s.position.x+(x.col1.x*f.x+x.col2.x*f.y);t.v.y=s.position.y+(x.col1.y*f.x+x.col2.y*f.y);t.id.features.referenceEdge=m;t.id.features.incidentEdge=r;t.id.features.incidentVertex=0;t=b[1];f=e[v];
x=s.R;t.v.x=s.position.x+(x.col1.x*f.x+x.col2.x*f.y);t.v.y=s.position.y+(x.col1.y*f.x+x.col2.y*f.y);t.id.features.referenceEdge=m;t.id.features.incidentEdge=v;t.id.features.incidentVertex=1};M.MakeClipPointVector=function(){var b=new Vector(2);b[0]=new a;b[1]=new a;return b};M.CollidePolygons=function(b,e,f,m,r){var s;b.m_pointCount=0;var v=e.m_radius+m.m_radius;s=0;M.s_edgeAO[0]=s;var t=M.FindMaxSeparation(M.s_edgeAO,e,f,m,r);s=M.s_edgeAO[0];if(!(t>v)){var x=0;M.s_edgeBO[0]=x;var C=M.FindMaxSeparation(M.s_edgeBO,
m,r,e,f);x=M.s_edgeBO[0];if(!(C>v)){var J=0,T=0;if(C>0.98*t+0.0010){t=m;m=e;e=r;f=f;J=x;b.m_type=E.e_faceB;T=1}else{t=e;m=m;e=f;f=r;J=s;b.m_type=E.e_faceA;T=0}s=M.s_incidentEdge;M.FindIncidentEdge(s,t,e,J,m,f);x=parseInt(t.m_vertexCount);r=t.m_vertices;t=r[J];var P;P=J+1<x?r[parseInt(J+1)]:r[0];J=M.s_localTangent;J.Set(P.x-t.x,P.y-t.y);J.Normalize();r=M.s_localNormal;r.x=J.y;r.y=-J.x;m=M.s_planePoint;m.Set(0.5*(t.x+P.x),0.5*(t.y+P.y));C=M.s_tangent;x=e.R;C.x=x.col1.x*J.x+x.col2.x*J.y;C.y=x.col1.y*
J.x+x.col2.y*J.y;var X=M.s_tangent2;X.x=-C.x;X.y=-C.y;J=M.s_normal;J.x=C.y;J.y=-C.x;var $=M.s_v11,ba=M.s_v12;$.x=e.position.x+(x.col1.x*t.x+x.col2.x*t.y);$.y=e.position.y+(x.col1.y*t.x+x.col2.y*t.y);ba.x=e.position.x+(x.col1.x*P.x+x.col2.x*P.y);ba.y=e.position.y+(x.col1.y*P.x+x.col2.y*P.y);e=J.x*$.x+J.y*$.y;x=C.x*ba.x+C.y*ba.y+v;P=M.s_clipPoints1;t=M.s_clipPoints2;ba=0;ba=M.ClipSegmentToLine(P,s,X,-C.x*$.x-C.y*$.y+v);if(!(ba<2)){ba=M.ClipSegmentToLine(t,P,C,x);if(!(ba<2)){b.m_localPlaneNormal.SetV(r);
b.m_localPoint.SetV(m);for(m=r=0;m<y.b2_maxManifoldPoints;++m){s=t[m];if(J.x*s.v.x+J.y*s.v.y-e<=v){C=b.m_points[r];x=f.R;X=s.v.x-f.position.x;$=s.v.y-f.position.y;C.m_localPoint.x=X*x.col1.x+$*x.col1.y;C.m_localPoint.y=X*x.col2.x+$*x.col2.y;C.m_id.Set(s.id);C.m_id.features.flip=T;++r}}b.m_pointCount=r}}}}};M.CollideCircles=function(b,e,f,m,r){b.m_pointCount=0;var s,v;s=f.R;v=e.m_p;var t=f.position.x+(s.col1.x*v.x+s.col2.x*v.y);f=f.position.y+(s.col1.y*v.x+s.col2.y*v.y);s=r.R;v=m.m_p;t=r.position.x+
(s.col1.x*v.x+s.col2.x*v.y)-t;r=r.position.y+(s.col1.y*v.x+s.col2.y*v.y)-f;s=e.m_radius+m.m_radius;if(!(t*t+r*r>s*s)){b.m_type=E.e_circles;b.m_localPoint.SetV(e.m_p);b.m_localPlaneNormal.SetZero();b.m_pointCount=1;b.m_points[0].m_localPoint.SetV(m.m_p);b.m_points[0].m_id.key=0}};M.CollidePolygonAndCircle=function(b,e,f,m,r){var s=b.m_pointCount=0,v=0,t,x;x=r.R;t=m.m_p;var C=r.position.y+(x.col1.y*t.x+x.col2.y*t.y);s=r.position.x+(x.col1.x*t.x+x.col2.x*t.y)-f.position.x;v=C-f.position.y;x=f.R;f=s*
x.col1.x+v*x.col1.y;x=s*x.col2.x+v*x.col2.y;var J=0;C=-Number.MAX_VALUE;r=e.m_radius+m.m_radius;var T=parseInt(e.m_vertexCount),P=e.m_vertices;e=e.m_normals;for(var X=0;X<T;++X){t=P[X];s=f-t.x;v=x-t.y;t=e[X];s=t.x*s+t.y*v;if(s>r)return;if(s>C){C=s;J=X}}s=parseInt(J);v=parseInt(s+1<T?s+1:0);t=P[s];P=P[v];if(C<Number.MIN_VALUE){b.m_pointCount=1;b.m_type=E.e_faceA;b.m_localPlaneNormal.SetV(e[J]);b.m_localPoint.x=0.5*(t.x+P.x);b.m_localPoint.y=0.5*(t.y+P.y)}else{C=(f-P.x)*(t.x-P.x)+(x-P.y)*(t.y-P.y);
if((f-t.x)*(P.x-t.x)+(x-t.y)*(P.y-t.y)<=0){if((f-t.x)*(f-t.x)+(x-t.y)*(x-t.y)>r*r)return;b.m_pointCount=1;b.m_type=E.e_faceA;b.m_localPlaneNormal.x=f-t.x;b.m_localPlaneNormal.y=x-t.y;b.m_localPlaneNormal.Normalize();b.m_localPoint.SetV(t)}else if(C<=0){if((f-P.x)*(f-P.x)+(x-P.y)*(x-P.y)>r*r)return;b.m_pointCount=1;b.m_type=E.e_faceA;b.m_localPlaneNormal.x=f-P.x;b.m_localPlaneNormal.y=x-P.y;b.m_localPlaneNormal.Normalize();b.m_localPoint.SetV(P)}else{J=0.5*(t.x+P.x);t=0.5*(t.y+P.y);C=(f-J)*e[s].x+
(x-t)*e[s].y;if(C>r)return;b.m_pointCount=1;b.m_type=E.e_faceA;b.m_localPlaneNormal.x=e[s].x;b.m_localPlaneNormal.y=e[s].y;b.m_localPlaneNormal.Normalize();b.m_localPoint.Set(J,t)}}b.m_points[0].m_localPoint.SetV(m.m_p);b.m_points[0].m_id.key=0};M.TestOverlap=function(b,e){var f=e.lowerBound,m=b.upperBound,r=f.x-m.x,s=f.y-m.y;f=b.lowerBound;m=e.upperBound;var v=f.y-m.y;if(r>0||s>0)return false;if(f.x-m.x>0||v>0)return false;return true};Box2D.postDefs.push(function(){Box2D.Collision.b2Collision.s_incidentEdge=
M.MakeClipPointVector();Box2D.Collision.b2Collision.s_clipPoints1=M.MakeClipPointVector();Box2D.Collision.b2Collision.s_clipPoints2=M.MakeClipPointVector();Box2D.Collision.b2Collision.s_edgeAO=new Vector_a2j_Number(1);Box2D.Collision.b2Collision.s_edgeBO=new Vector_a2j_Number(1);Box2D.Collision.b2Collision.s_localTangent=new p;Box2D.Collision.b2Collision.s_localNormal=new p;Box2D.Collision.b2Collision.s_planePoint=new p;Box2D.Collision.b2Collision.s_normal=new p;Box2D.Collision.b2Collision.s_tangent=
new p;Box2D.Collision.b2Collision.s_tangent2=new p;Box2D.Collision.b2Collision.s_v11=new p;Box2D.Collision.b2Collision.s_v12=new p;Box2D.Collision.b2Collision.b2CollidePolyTempVec=new p;Box2D.Collision.b2Collision.b2_nullFeature=255});L.b2ContactID=function(){this.features=new c};L.prototype.b2ContactID=function(){this.features._m_id=this};L.prototype.Set=function(b){this.key=b._key};L.prototype.Copy=function(){var b=new L;b.key=this.key;return b};Object.defineProperty(L.prototype,"key",{enumerable:false,
configurable:true,get:function(){return this._key}});Object.defineProperty(L.prototype,"key",{enumerable:false,configurable:true,set:function(b){if(b===undefined)b=0;this._key=b;this.features._referenceEdge=this._key&255;this.features._incidentEdge=(this._key&65280)>>8&255;this.features._incidentVertex=(this._key&16711680)>>16&255;this.features._flip=(this._key&4278190080)>>24&255}});I.b2ContactPoint=function(){this.position=new p;this.velocity=new p;this.normal=new p;this.id=new L};W.b2Distance=
function(){};W.Distance=function(b,e,f){++W.b2_gjkCalls;var m=f.proxyA,r=f.proxyB,s=f.transformA,v=f.transformB,t=W.s_simplex;t.ReadCache(e,m,s,r,v);var x=t.m_vertices,C=W.s_saveA,J=W.s_saveB,T=0;t.GetClosestPoint().LengthSquared();for(var P=0,X,$=0;$<20;){T=t.m_count;for(P=0;P<T;P++){C[P]=x[P].indexA;J[P]=x[P].indexB}switch(t.m_count){case 1:break;case 2:t.Solve2();break;case 3:t.Solve3();break;default:y.b2Assert(false)}if(t.m_count==3)break;X=t.GetClosestPoint();X.LengthSquared();P=t.GetSearchDirection();
if(P.LengthSquared()<Number.MIN_VALUE*Number.MIN_VALUE)break;X=x[t.m_count];X.indexA=m.GetSupport(w.MulTMV(s.R,P.GetNegative()));X.wA=w.MulX(s,m.GetVertex(X.indexA));X.indexB=r.GetSupport(w.MulTMV(v.R,P));X.wB=w.MulX(v,r.GetVertex(X.indexB));X.w=w.SubtractVV(X.wB,X.wA);++$;++W.b2_gjkIters;var ba=false;for(P=0;P<T;P++)if(X.indexA==C[P]&&X.indexB==J[P]){ba=true;break}if(ba)break;++t.m_count}W.b2_gjkMaxIters=w.Max(W.b2_gjkMaxIters,$);t.GetWitnessPoints(b.pointA,b.pointB);b.distance=w.SubtractVV(b.pointA,
b.pointB).Length();b.iterations=$;t.WriteCache(e);if(f.useRadii){e=m.m_radius;r=r.m_radius;if(b.distance>e+r&&b.distance>Number.MIN_VALUE){b.distance-=e+r;f=w.SubtractVV(b.pointB,b.pointA);f.Normalize();b.pointA.x+=e*f.x;b.pointA.y+=e*f.y;b.pointB.x-=r*f.x;b.pointB.y-=r*f.y}else{X=new p;X.x=0.5*(b.pointA.x+b.pointB.x);X.y=0.5*(b.pointA.y+b.pointB.y);b.pointA.x=b.pointB.x=X.x;b.pointA.y=b.pointB.y=X.y;b.distance=0}}};Box2D.postDefs.push(function(){Box2D.Collision.b2Distance.s_simplex=new h;Box2D.Collision.b2Distance.s_saveA=
new Vector_a2j_Number(3);Box2D.Collision.b2Distance.s_saveB=new Vector_a2j_Number(3)});Y.b2DistanceInput=function(){};k.b2DistanceOutput=function(){this.pointA=new p;this.pointB=new p};z.b2DistanceProxy=function(){};z.prototype.Set=function(b){switch(b.GetType()){case K.e_circleShape:b=b instanceof F?b:null;this.m_vertices=new Vector(1,true);this.m_vertices[0]=b.m_p;this.m_count=1;this.m_radius=b.m_radius;break;case K.e_polygonShape:b=b instanceof G?b:null;this.m_vertices=b.m_vertices;this.m_count=
b.m_vertexCount;this.m_radius=b.m_radius;break;default:y.b2Assert(false)}};z.prototype.GetSupport=function(b){for(var e=0,f=this.m_vertices[0].x*b.x+this.m_vertices[0].y*b.y,m=1;m<this.m_count;++m){var r=this.m_vertices[m].x*b.x+this.m_vertices[m].y*b.y;if(r>f){e=m;f=r}}return e};z.prototype.GetSupportVertex=function(b){for(var e=0,f=this.m_vertices[0].x*b.x+this.m_vertices[0].y*b.y,m=1;m<this.m_count;++m){var r=this.m_vertices[m].x*b.x+this.m_vertices[m].y*b.y;if(r>f){e=m;f=r}}return this.m_vertices[e]};
z.prototype.GetVertexCount=function(){return this.m_count};z.prototype.GetVertex=function(b){if(b===undefined)b=0;y.b2Assert(0<=b&&b<this.m_count);return this.m_vertices[b]};u.b2DynamicTree=function(){};u.prototype.b2DynamicTree=function(){this.m_freeList=this.m_root=null;this.m_insertionCount=this.m_path=0};u.prototype.CreateProxy=function(b,e){var f=this.AllocateNode(),m=y.b2_aabbExtension,r=y.b2_aabbExtension;f.aabb.lowerBound.x=b.lowerBound.x-m;f.aabb.lowerBound.y=b.lowerBound.y-r;f.aabb.upperBound.x=
b.upperBound.x+m;f.aabb.upperBound.y=b.upperBound.y+r;f.userData=e;this.InsertLeaf(f);return f};u.prototype.DestroyProxy=function(b){this.RemoveLeaf(b);this.FreeNode(b)};u.prototype.MoveProxy=function(b,e,f){y.b2Assert(b.IsLeaf());if(b.aabb.Contains(e))return false;this.RemoveLeaf(b);var m=y.b2_aabbExtension+y.b2_aabbMultiplier*(f.x>0?f.x:-f.x);f=y.b2_aabbExtension+y.b2_aabbMultiplier*(f.y>0?f.y:-f.y);b.aabb.lowerBound.x=e.lowerBound.x-m;b.aabb.lowerBound.y=e.lowerBound.y-f;b.aabb.upperBound.x=e.upperBound.x+
m;b.aabb.upperBound.y=e.upperBound.y+f;this.InsertLeaf(b);return true};u.prototype.Rebalance=function(b){if(b===undefined)b=0;if(this.m_root!=null)for(var e=0;e<b;e++){for(var f=this.m_root,m=0;f.IsLeaf()==false;){f=this.m_path>>m&1?f.child2:f.child1;m=m+1&31}++this.m_path;this.RemoveLeaf(f);this.InsertLeaf(f)}};u.prototype.GetFatAABB=function(b){return b.aabb};u.prototype.GetUserData=function(b){return b.userData};u.prototype.Query=function(b,e){if(this.m_root!=null){var f=new Vector,m=0;for(f[m++]=
this.m_root;m>0;){var r=f[--m];if(r.aabb.TestOverlap(e))if(r.IsLeaf()){if(!b(r))break}else{f[m++]=r.child1;f[m++]=r.child2}}}};u.prototype.RayCast=function(b,e){if(this.m_root!=null){var f=e.p1,m=e.p2,r=w.SubtractVV(f,m);r.Normalize();r=w.CrossFV(1,r);var s=w.AbsV(r),v=e.maxFraction,t=new B,x=0,C=0;x=f.x+v*(m.x-f.x);C=f.y+v*(m.y-f.y);t.lowerBound.x=Math.min(f.x,x);t.lowerBound.y=Math.min(f.y,C);t.upperBound.x=Math.max(f.x,x);t.upperBound.y=Math.max(f.y,C);var J=new Vector,T=0;for(J[T++]=this.m_root;T>
0;){v=J[--T];if(v.aabb.TestOverlap(t)!=false){x=v.aabb.GetCenter();C=v.aabb.GetExtents();if(!(Math.abs(r.x*(f.x-x.x)+r.y*(f.y-x.y))-s.x*C.x-s.y*C.y>0))if(v.IsLeaf()){x=new S;x.p1=e.p1;x.p2=e.p2;x.maxFraction=e.maxFraction;v=b(x,v);if(v==0)break;if(v>0){x=f.x+v*(m.x-f.x);C=f.y+v*(m.y-f.y);t.lowerBound.x=Math.min(f.x,x);t.lowerBound.y=Math.min(f.y,C);t.upperBound.x=Math.max(f.x,x);t.upperBound.y=Math.max(f.y,C)}}else{J[T++]=v.child1;J[T++]=v.child2}}}}};u.prototype.AllocateNode=function(){if(this.m_freeList){var b=
this.m_freeList;this.m_freeList=b.parent;b.parent=null;b.child1=null;b.child2=null;return b}return new H};u.prototype.FreeNode=function(b){b.parent=this.m_freeList;this.m_freeList=b};u.prototype.InsertLeaf=function(b){++this.m_insertionCount;if(this.m_root==null){this.m_root=b;this.m_root.parent=null}else{var e=b.aabb.GetCenter(),f=this.m_root;if(f.IsLeaf()==false){do{var m=f.child1;f=f.child2;f=Math.abs((m.aabb.lowerBound.x+m.aabb.upperBound.x)/2-e.x)+Math.abs((m.aabb.lowerBound.y+m.aabb.upperBound.y)/
2-e.y)<Math.abs((f.aabb.lowerBound.x+f.aabb.upperBound.x)/2-e.x)+Math.abs((f.aabb.lowerBound.y+f.aabb.upperBound.y)/2-e.y)?m:f}while(f.IsLeaf()==false)}e=f.parent;m=this.AllocateNode();m.parent=e;m.userData=null;m.aabb.Combine(b.aabb,f.aabb);if(e){if(f.parent.child1==f)e.child1=m;else e.child2=m;m.child1=f;m.child2=b;f.parent=m;b.parent=m;do{if(e.aabb.Contains(m.aabb))break;e.aabb.Combine(e.child1.aabb,e.child2.aabb);m=e;e=e.parent}while(e)}else{m.child1=f;m.child2=b;f.parent=m;this.m_root=b.parent=
m}}};u.prototype.RemoveLeaf=function(b){if(b==this.m_root)this.m_root=null;else{var e=b.parent,f=e.parent;b=e.child1==b?e.child2:e.child1;if(f){if(f.child1==e)f.child1=b;else f.child2=b;b.parent=f;for(this.FreeNode(e);f;){e=f.aabb;f.aabb=B.Combine(f.child1.aabb,f.child2.aabb);if(e.Contains(f.aabb))break;f=f.parent}}else{this.m_root=b;b.parent=null;this.FreeNode(e)}}};D.b2DynamicTreeBroadPhase=function(){this.m_tree=new u;this.m_moveBuffer=new Vector;this.m_pairBuffer=new Vector;this.m_pairCount=0};
D.prototype.CreateProxy=function(b,e){var f=this.m_tree.CreateProxy(b,e);++this.m_proxyCount;this.BufferMove(f);return f};D.prototype.DestroyProxy=function(b){this.UnBufferMove(b);--this.m_proxyCount;this.m_tree.DestroyProxy(b)};D.prototype.MoveProxy=function(b,e,f){this.m_tree.MoveProxy(b,e,f)&&this.BufferMove(b)};D.prototype.TestOverlap=function(b,e){var f=this.m_tree.GetFatAABB(b),m=this.m_tree.GetFatAABB(e);return f.TestOverlap(m)};D.prototype.GetUserData=function(b){return this.m_tree.GetUserData(b)};
D.prototype.GetFatAABB=function(b){return this.m_tree.GetFatAABB(b)};D.prototype.GetProxyCount=function(){return this.m_proxyCount};D.prototype.UpdatePairs=function(b){var e=this;var f=e.m_pairCount=0,m;for(f=0;f<e.m_moveBuffer.length;++f){m=e.m_moveBuffer[f];var r=e.m_tree.GetFatAABB(m);e.m_tree.Query(function(t){if(t==m)return true;if(e.m_pairCount==e.m_pairBuffer.length)e.m_pairBuffer[e.m_pairCount]=new O;var x=e.m_pairBuffer[e.m_pairCount];x.proxyA=t<m?t:m;x.proxyB=t>=m?t:m;++e.m_pairCount;return true},
r)}for(f=e.m_moveBuffer.length=0;f<e.m_pairCount;){r=e.m_pairBuffer[f];var s=e.m_tree.GetUserData(r.proxyA),v=e.m_tree.GetUserData(r.proxyB);b(s,v);for(++f;f<e.m_pairCount;){s=e.m_pairBuffer[f];if(s.proxyA!=r.proxyA||s.proxyB!=r.proxyB)break;++f}}};D.prototype.Query=function(b,e){this.m_tree.Query(b,e)};D.prototype.RayCast=function(b,e){this.m_tree.RayCast(b,e)};D.prototype.Validate=function(){};D.prototype.Rebalance=function(b){if(b===undefined)b=0;this.m_tree.Rebalance(b)};D.prototype.BufferMove=
function(b){this.m_moveBuffer[this.m_moveBuffer.length]=b};D.prototype.UnBufferMove=function(b){this.m_moveBuffer.splice(parseInt(this.m_moveBuffer.indexOf(b)),1)};D.prototype.ComparePairs=function(){return 0};D.__implements={};D.__implements[g]=true;H.b2DynamicTreeNode=function(){this.aabb=new B};H.prototype.IsLeaf=function(){return this.child1==null};O.b2DynamicTreePair=function(){};E.b2Manifold=function(){this.m_pointCount=0};E.prototype.b2Manifold=function(){this.m_points=new Vector(y.b2_maxManifoldPoints);
for(var b=0;b<y.b2_maxManifoldPoints;b++)this.m_points[b]=new R;this.m_localPlaneNormal=new p;this.m_localPoint=new p};E.prototype.Reset=function(){for(var b=0;b<y.b2_maxManifoldPoints;b++)(this.m_points[b]instanceof R?this.m_points[b]:null).Reset();this.m_localPlaneNormal.SetZero();this.m_localPoint.SetZero();this.m_pointCount=this.m_type=0};E.prototype.Set=function(b){this.m_pointCount=b.m_pointCount;for(var e=0;e<y.b2_maxManifoldPoints;e++)(this.m_points[e]instanceof R?this.m_points[e]:null).Set(b.m_points[e]);
this.m_localPlaneNormal.SetV(b.m_localPlaneNormal);this.m_localPoint.SetV(b.m_localPoint);this.m_type=b.m_type};E.prototype.Copy=function(){var b=new E;b.Set(this);return b};Box2D.postDefs.push(function(){Box2D.Collision.b2Manifold.e_circles=1;Box2D.Collision.b2Manifold.e_faceA=2;Box2D.Collision.b2Manifold.e_faceB=4});R.b2ManifoldPoint=function(){this.m_localPoint=new p;this.m_id=new L};R.prototype.b2ManifoldPoint=function(){this.Reset()};R.prototype.Reset=function(){this.m_localPoint.SetZero();this.m_tangentImpulse=
this.m_normalImpulse=0;this.m_id.key=0};R.prototype.Set=function(b){this.m_localPoint.SetV(b.m_localPoint);this.m_normalImpulse=b.m_normalImpulse;this.m_tangentImpulse=b.m_tangentImpulse;this.m_id.Set(b.m_id)};N.b2Point=function(){this.p=new p};N.prototype.Support=function(){return this.p};N.prototype.GetFirstVertex=function(){return this.p};S.b2RayCastInput=function(){this.p1=new p;this.p2=new p};S.prototype.b2RayCastInput=function(b,e,f){if(b===undefined)b=null;if(e===undefined)e=null;if(f===undefined)f=
1;b&&this.p1.SetV(b);e&&this.p2.SetV(e);this.maxFraction=f};aa.b2RayCastOutput=function(){this.normal=new p};Z.b2Segment=function(){this.p1=new p;this.p2=new p};Z.prototype.TestSegment=function(b,e,f,m){if(m===undefined)m=0;var r=f.p1,s=f.p2.x-r.x,v=f.p2.y-r.y;f=this.p2.y-this.p1.y;var t=-(this.p2.x-this.p1.x),x=100*Number.MIN_VALUE,C=-(s*f+v*t);if(C>x){var J=r.x-this.p1.x,T=r.y-this.p1.y;r=J*f+T*t;if(0<=r&&r<=m*C){m=-s*T+v*J;if(-x*C<=m&&m<=C*(1+x)){r/=C;m=Math.sqrt(f*f+t*t);f/=m;t/=m;b[0]=r;e.Set(f,
t);return true}}}return false};Z.prototype.Extend=function(b){this.ExtendForward(b);this.ExtendBackward(b)};Z.prototype.ExtendForward=function(b){var e=this.p2.x-this.p1.x,f=this.p2.y-this.p1.y;b=Math.min(e>0?(b.upperBound.x-this.p1.x)/e:e<0?(b.lowerBound.x-this.p1.x)/e:Number.POSITIVE_INFINITY,f>0?(b.upperBound.y-this.p1.y)/f:f<0?(b.lowerBound.y-this.p1.y)/f:Number.POSITIVE_INFINITY);this.p2.x=this.p1.x+e*b;this.p2.y=this.p1.y+f*b};Z.prototype.ExtendBackward=function(b){var e=-this.p2.x+this.p1.x,
f=-this.p2.y+this.p1.y;b=Math.min(e>0?(b.upperBound.x-this.p2.x)/e:e<0?(b.lowerBound.x-this.p2.x)/e:Number.POSITIVE_INFINITY,f>0?(b.upperBound.y-this.p2.y)/f:f<0?(b.lowerBound.y-this.p2.y)/f:Number.POSITIVE_INFINITY);this.p1.x=this.p2.x+e*b;this.p1.y=this.p2.y+f*b};d.b2SeparationFunction=function(){this.m_localPoint=new p;this.m_axis=new p};d.prototype.Initialize=function(b,e,f,m,r){this.m_proxyA=e;this.m_proxyB=m;var s=parseInt(b.count);y.b2Assert(0<s&&s<3);var v,t,x,C,J=C=x=m=e=0,T=0;J=0;if(s==
1){this.m_type=d.e_points;v=this.m_proxyA.GetVertex(b.indexA[0]);t=this.m_proxyB.GetVertex(b.indexB[0]);s=v;b=f.R;e=f.position.x+(b.col1.x*s.x+b.col2.x*s.y);m=f.position.y+(b.col1.y*s.x+b.col2.y*s.y);s=t;b=r.R;x=r.position.x+(b.col1.x*s.x+b.col2.x*s.y);C=r.position.y+(b.col1.y*s.x+b.col2.y*s.y);this.m_axis.x=x-e;this.m_axis.y=C-m;this.m_axis.Normalize()}else{if(b.indexB[0]==b.indexB[1]){this.m_type=d.e_faceA;e=this.m_proxyA.GetVertex(b.indexA[0]);m=this.m_proxyA.GetVertex(b.indexA[1]);t=this.m_proxyB.GetVertex(b.indexB[0]);
this.m_localPoint.x=0.5*(e.x+m.x);this.m_localPoint.y=0.5*(e.y+m.y);this.m_axis=w.CrossVF(w.SubtractVV(m,e),1);this.m_axis.Normalize();s=this.m_axis;b=f.R;J=b.col1.x*s.x+b.col2.x*s.y;T=b.col1.y*s.x+b.col2.y*s.y;s=this.m_localPoint;b=f.R;e=f.position.x+(b.col1.x*s.x+b.col2.x*s.y);m=f.position.y+(b.col1.y*s.x+b.col2.y*s.y);s=t;b=r.R;x=r.position.x+(b.col1.x*s.x+b.col2.x*s.y);C=r.position.y+(b.col1.y*s.x+b.col2.y*s.y);J=(x-e)*J+(C-m)*T}else if(b.indexA[0]==b.indexA[0]){this.m_type=d.e_faceB;x=this.m_proxyB.GetVertex(b.indexB[0]);
C=this.m_proxyB.GetVertex(b.indexB[1]);v=this.m_proxyA.GetVertex(b.indexA[0]);this.m_localPoint.x=0.5*(x.x+C.x);this.m_localPoint.y=0.5*(x.y+C.y);this.m_axis=w.CrossVF(w.SubtractVV(C,x),1);this.m_axis.Normalize();s=this.m_axis;b=r.R;J=b.col1.x*s.x+b.col2.x*s.y;T=b.col1.y*s.x+b.col2.y*s.y;s=this.m_localPoint;b=r.R;x=r.position.x+(b.col1.x*s.x+b.col2.x*s.y);C=r.position.y+(b.col1.y*s.x+b.col2.y*s.y);s=v;b=f.R;e=f.position.x+(b.col1.x*s.x+b.col2.x*s.y);m=f.position.y+(b.col1.y*s.x+b.col2.y*s.y);J=(e-
x)*J+(m-C)*T}else{e=this.m_proxyA.GetVertex(b.indexA[0]);m=this.m_proxyA.GetVertex(b.indexA[1]);x=this.m_proxyB.GetVertex(b.indexB[0]);C=this.m_proxyB.GetVertex(b.indexB[1]);w.MulX(f,v);v=w.MulMV(f.R,w.SubtractVV(m,e));w.MulX(r,t);J=w.MulMV(r.R,w.SubtractVV(C,x));r=v.x*v.x+v.y*v.y;t=J.x*J.x+J.y*J.y;b=w.SubtractVV(J,v);f=v.x*b.x+v.y*b.y;b=J.x*b.x+J.y*b.y;v=v.x*J.x+v.y*J.y;T=r*t-v*v;J=0;if(T!=0)J=w.Clamp((v*b-f*t)/T,0,1);if((v*J+b)/t<0)J=w.Clamp((v-f)/r,0,1);v=new p;v.x=e.x+J*(m.x-e.x);v.y=e.y+J*(m.y-
e.y);t=new p;t.x=x.x+J*(C.x-x.x);t.y=x.y+J*(C.y-x.y);if(J==0||J==1){this.m_type=d.e_faceB;this.m_axis=w.CrossVF(w.SubtractVV(C,x),1);this.m_axis.Normalize();this.m_localPoint=t}else{this.m_type=d.e_faceA;this.m_axis=w.CrossVF(w.SubtractVV(m,e),1);this.m_localPoint=v}}J<0&&this.m_axis.NegativeSelf()}};d.prototype.Evaluate=function(b,e){var f,m,r=0;switch(this.m_type){case d.e_points:f=w.MulTMV(b.R,this.m_axis);m=w.MulTMV(e.R,this.m_axis.GetNegative());f=this.m_proxyA.GetSupportVertex(f);m=this.m_proxyB.GetSupportVertex(m);
f=w.MulX(b,f);m=w.MulX(e,m);return r=(m.x-f.x)*this.m_axis.x+(m.y-f.y)*this.m_axis.y;case d.e_faceA:r=w.MulMV(b.R,this.m_axis);f=w.MulX(b,this.m_localPoint);m=w.MulTMV(e.R,r.GetNegative());m=this.m_proxyB.GetSupportVertex(m);m=w.MulX(e,m);return r=(m.x-f.x)*r.x+(m.y-f.y)*r.y;case d.e_faceB:r=w.MulMV(e.R,this.m_axis);m=w.MulX(e,this.m_localPoint);f=w.MulTMV(b.R,r.GetNegative());f=this.m_proxyA.GetSupportVertex(f);f=w.MulX(b,f);return r=(f.x-m.x)*r.x+(f.y-m.y)*r.y;default:y.b2Assert(false);return 0}};
Box2D.postDefs.push(function(){Box2D.Collision.b2SeparationFunction.e_points=1;Box2D.Collision.b2SeparationFunction.e_faceA=2;Box2D.Collision.b2SeparationFunction.e_faceB=4});h.b2Simplex=function(){this.m_v1=new j;this.m_v2=new j;this.m_v3=new j;this.m_vertices=new Vector(3)};h.prototype.b2Simplex=function(){this.m_vertices[0]=this.m_v1;this.m_vertices[1]=this.m_v2;this.m_vertices[2]=this.m_v3};h.prototype.ReadCache=function(b,e,f,m,r){y.b2Assert(0<=b.count&&b.count<=3);var s,v;this.m_count=b.count;
for(var t=this.m_vertices,x=0;x<this.m_count;x++){var C=t[x];C.indexA=b.indexA[x];C.indexB=b.indexB[x];s=e.GetVertex(C.indexA);v=m.GetVertex(C.indexB);C.wA=w.MulX(f,s);C.wB=w.MulX(r,v);C.w=w.SubtractVV(C.wB,C.wA);C.a=0}if(this.m_count>1){b=b.metric;s=this.GetMetric();if(s<0.5*b||2*b<s||s<Number.MIN_VALUE)this.m_count=0}if(this.m_count==0){C=t[0];C.indexA=0;C.indexB=0;s=e.GetVertex(0);v=m.GetVertex(0);C.wA=w.MulX(f,s);C.wB=w.MulX(r,v);C.w=w.SubtractVV(C.wB,C.wA);this.m_count=1}};h.prototype.WriteCache=
function(b){b.metric=this.GetMetric();b.count=Box2D.parseUInt(this.m_count);for(var e=this.m_vertices,f=0;f<this.m_count;f++){b.indexA[f]=Box2D.parseUInt(e[f].indexA);b.indexB[f]=Box2D.parseUInt(e[f].indexB)}};h.prototype.GetSearchDirection=function(){switch(this.m_count){case 1:return this.m_v1.w.GetNegative();case 2:var b=w.SubtractVV(this.m_v2.w,this.m_v1.w);return w.CrossVV(b,this.m_v1.w.GetNegative())>0?w.CrossFV(1,b):w.CrossVF(b,1);default:y.b2Assert(false);return new p}};h.prototype.GetClosestPoint=
function(){switch(this.m_count){case 0:y.b2Assert(false);return new p;case 1:return this.m_v1.w;case 2:return new p(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y);default:y.b2Assert(false);return new p}};h.prototype.GetWitnessPoints=function(b,e){switch(this.m_count){case 0:y.b2Assert(false);break;case 1:b.SetV(this.m_v1.wA);e.SetV(this.m_v1.wB);break;case 2:b.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x;b.y=this.m_v1.a*this.m_v1.wA.y+
this.m_v2.a*this.m_v2.wA.y;e.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x;e.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:e.x=b.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x;e.y=b.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y;break;default:y.b2Assert(false)}};h.prototype.GetMetric=function(){switch(this.m_count){case 0:y.b2Assert(false);return 0;case 1:return 0;case 2:return w.SubtractVV(this.m_v1.w,
this.m_v2.w).Length();case 3:return w.CrossVV(w.SubtractVV(this.m_v2.w,this.m_v1.w),w.SubtractVV(this.m_v3.w,this.m_v1.w));default:y.b2Assert(false);return 0}};h.prototype.Solve2=function(){var b=this.m_v1.w,e=this.m_v2.w,f=w.SubtractVV(e,b);b=-(b.x*f.x+b.y*f.y);if(b<=0)this.m_count=this.m_v1.a=1;else{e=e.x*f.x+e.y*f.y;if(e<=0){this.m_count=this.m_v2.a=1;this.m_v1.Set(this.m_v2)}else{f=1/(e+b);this.m_v1.a=e*f;this.m_v2.a=b*f;this.m_count=2}}};h.prototype.Solve3=function(){var b=this.m_v1.w,e=this.m_v2.w,
f=this.m_v3.w,m=w.SubtractVV(e,b),r=w.Dot(b,m),s=w.Dot(e,m);r=-r;var v=w.SubtractVV(f,b),t=w.Dot(b,v),x=w.Dot(f,v);t=-t;var C=w.SubtractVV(f,e),J=w.Dot(e,C);C=w.Dot(f,C);J=-J;v=w.CrossVV(m,v);m=v*w.CrossVV(e,f);f=v*w.CrossVV(f,b);b=v*w.CrossVV(b,e);if(r<=0&&t<=0)this.m_count=this.m_v1.a=1;else if(s>0&&r>0&&b<=0){x=1/(s+r);this.m_v1.a=s*x;this.m_v2.a=r*x;this.m_count=2}else if(x>0&&t>0&&f<=0){s=1/(x+t);this.m_v1.a=x*s;this.m_v3.a=t*s;this.m_count=2;this.m_v2.Set(this.m_v3)}else if(s<=0&&J<=0){this.m_count=
this.m_v2.a=1;this.m_v1.Set(this.m_v2)}else if(x<=0&&C<=0){this.m_count=this.m_v3.a=1;this.m_v1.Set(this.m_v3)}else if(C>0&&J>0&&m<=0){s=1/(C+J);this.m_v2.a=C*s;this.m_v3.a=J*s;this.m_count=2;this.m_v1.Set(this.m_v3)}else{s=1/(m+f+b);this.m_v1.a=m*s;this.m_v2.a=f*s;this.m_v3.a=b*s;this.m_count=3}};l.b2SimplexCache=function(){this.indexA=new Vector_a2j_Number(3);this.indexB=new Vector_a2j_Number(3)};j.b2SimplexVertex=function(){};j.prototype.Set=function(b){this.wA.SetV(b.wA);this.wB.SetV(b.wB);this.w.SetV(b.w);
this.a=b.a;this.indexA=b.indexA;this.indexB=b.indexB};o.b2TimeOfImpact=function(){};o.TimeOfImpact=function(b){++o.b2_toiCalls;var e=b.proxyA,f=b.proxyB,m=b.sweepA,r=b.sweepB;y.b2Assert(m.t0==r.t0);y.b2Assert(1-m.t0>Number.MIN_VALUE);var s=e.m_radius+f.m_radius;b=b.tolerance;var v=0,t=0,x=0;o.s_cache.count=0;for(o.s_distanceInput.useRadii=false;;){m.GetTransform(o.s_xfA,v);r.GetTransform(o.s_xfB,v);o.s_distanceInput.proxyA=e;o.s_distanceInput.proxyB=f;o.s_distanceInput.transformA=o.s_xfA;o.s_distanceInput.transformB=
o.s_xfB;W.Distance(o.s_distanceOutput,o.s_cache,o.s_distanceInput);if(o.s_distanceOutput.distance<=0){v=1;break}o.s_fcn.Initialize(o.s_cache,e,o.s_xfA,f,o.s_xfB);var C=o.s_fcn.Evaluate(o.s_xfA,o.s_xfB);if(C<=0){v=1;break}if(t==0)x=C>s?w.Max(s-b,0.75*s):w.Max(C-b,0.02*s);if(C-x<0.5*b){if(t==0){v=1;break}break}var J=v,T=v,P=1;C=C;m.GetTransform(o.s_xfA,P);r.GetTransform(o.s_xfB,P);var X=o.s_fcn.Evaluate(o.s_xfA,o.s_xfB);if(X>=x){v=1;break}for(var $=0;;){var ba=0;ba=$&1?T+(x-C)*(P-T)/(X-C):0.5*(T+P);
m.GetTransform(o.s_xfA,ba);r.GetTransform(o.s_xfB,ba);var ca=o.s_fcn.Evaluate(o.s_xfA,o.s_xfB);if(w.Abs(ca-x)<0.025*b){J=ba;break}if(ca>x){T=ba;C=ca}else{P=ba;X=ca}++$;++o.b2_toiRootIters;if($==50)break}o.b2_toiMaxRootIters=w.Max(o.b2_toiMaxRootIters,$);if(J<(1+100*Number.MIN_VALUE)*v)break;v=J;t++;++o.b2_toiIters;if(t==1E3)break}o.b2_toiMaxIters=w.Max(o.b2_toiMaxIters,t);return v};Box2D.postDefs.push(function(){Box2D.Collision.b2TimeOfImpact.b2_toiCalls=0;Box2D.Collision.b2TimeOfImpact.b2_toiIters=
0;Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters=0;Box2D.Collision.b2TimeOfImpact.b2_toiRootIters=0;Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters=0;Box2D.Collision.b2TimeOfImpact.s_cache=new l;Box2D.Collision.b2TimeOfImpact.s_distanceInput=new Y;Box2D.Collision.b2TimeOfImpact.s_xfA=new U;Box2D.Collision.b2TimeOfImpact.s_xfB=new U;Box2D.Collision.b2TimeOfImpact.s_fcn=new d;Box2D.Collision.b2TimeOfImpact.s_distanceOutput=new k});q.b2TOIInput=function(){this.proxyA=new z;this.proxyB=new z;this.sweepA=
new A;this.sweepB=new A};n.b2WorldManifold=function(){this.m_normal=new p};n.prototype.b2WorldManifold=function(){this.m_points=new Vector(y.b2_maxManifoldPoints);for(var b=0;b<y.b2_maxManifoldPoints;b++)this.m_points[b]=new p};n.prototype.Initialize=function(b,e,f,m,r){if(f===undefined)f=0;if(r===undefined)r=0;if(b.m_pointCount!=0){var s=0,v,t,x=0,C=0,J=0,T=0,P=0;v=0;switch(b.m_type){case E.e_circles:t=e.R;v=b.m_localPoint;s=e.position.x+t.col1.x*v.x+t.col2.x*v.y;e=e.position.y+t.col1.y*v.x+t.col2.y*
v.y;t=m.R;v=b.m_points[0].m_localPoint;b=m.position.x+t.col1.x*v.x+t.col2.x*v.y;m=m.position.y+t.col1.y*v.x+t.col2.y*v.y;v=b-s;t=m-e;x=v*v+t*t;if(x>Number.MIN_VALUE*Number.MIN_VALUE){x=Math.sqrt(x);this.m_normal.x=v/x;this.m_normal.y=t/x}else{this.m_normal.x=1;this.m_normal.y=0}v=e+f*this.m_normal.y;m=m-r*this.m_normal.y;this.m_points[0].x=0.5*(s+f*this.m_normal.x+(b-r*this.m_normal.x));this.m_points[0].y=0.5*(v+m);break;case E.e_faceA:t=e.R;v=b.m_localPlaneNormal;x=t.col1.x*v.x+t.col2.x*v.y;C=t.col1.y*
v.x+t.col2.y*v.y;t=e.R;v=b.m_localPoint;J=e.position.x+t.col1.x*v.x+t.col2.x*v.y;T=e.position.y+t.col1.y*v.x+t.col2.y*v.y;this.m_normal.x=x;this.m_normal.y=C;for(s=0;s<b.m_pointCount;s++){t=m.R;v=b.m_points[s].m_localPoint;P=m.position.x+t.col1.x*v.x+t.col2.x*v.y;v=m.position.y+t.col1.y*v.x+t.col2.y*v.y;this.m_points[s].x=P+0.5*(f-(P-J)*x-(v-T)*C-r)*x;this.m_points[s].y=v+0.5*(f-(P-J)*x-(v-T)*C-r)*C}break;case E.e_faceB:t=m.R;v=b.m_localPlaneNormal;x=t.col1.x*v.x+t.col2.x*v.y;C=t.col1.y*v.x+t.col2.y*
v.y;t=m.R;v=b.m_localPoint;J=m.position.x+t.col1.x*v.x+t.col2.x*v.y;T=m.position.y+t.col1.y*v.x+t.col2.y*v.y;this.m_normal.x=-x;this.m_normal.y=-C;for(s=0;s<b.m_pointCount;s++){t=e.R;v=b.m_points[s].m_localPoint;P=e.position.x+t.col1.x*v.x+t.col2.x*v.y;v=e.position.y+t.col1.y*v.x+t.col2.y*v.y;this.m_points[s].x=P+0.5*(r-(P-J)*x-(v-T)*C-f)*x;this.m_points[s].y=v+0.5*(r-(P-J)*x-(v-T)*C-f)*C}}}};a.ClipVertex=function(){this.v=new p;this.id=new L};a.prototype.Set=function(b){this.v.SetV(b.v);this.id.Set(b.id)};
c.Features=function(){};Object.defineProperty(c.prototype,"referenceEdge",{enumerable:false,configurable:true,get:function(){return this._referenceEdge}});Object.defineProperty(c.prototype,"referenceEdge",{enumerable:false,configurable:true,set:function(b){if(b===undefined)b=0;this._referenceEdge=b;this._m_id._key=this._m_id._key&4294967040|this._referenceEdge&255}});Object.defineProperty(c.prototype,"incidentEdge",{enumerable:false,configurable:true,get:function(){return this._incidentEdge}});Object.defineProperty(c.prototype,
"incidentEdge",{enumerable:false,configurable:true,set:function(b){if(b===undefined)b=0;this._incidentEdge=b;this._m_id._key=this._m_id._key&4294902015|this._incidentEdge<<8&65280}});Object.defineProperty(c.prototype,"incidentVertex",{enumerable:false,configurable:true,get:function(){return this._incidentVertex}});Object.defineProperty(c.prototype,"incidentVertex",{enumerable:false,configurable:true,set:function(b){if(b===undefined)b=0;this._incidentVertex=b;this._m_id._key=this._m_id._key&4278255615|
this._incidentVertex<<16&16711680}});Object.defineProperty(c.prototype,"flip",{enumerable:false,configurable:true,get:function(){return this._flip}});Object.defineProperty(c.prototype,"flip",{enumerable:false,configurable:true,set:function(b){if(b===undefined)b=0;this._flip=b;this._m_id._key=this._m_id._key&16777215|this._flip<<24&4278190080}})})();
(function(){var F=Box2D.Common.b2Settings,G=Box2D.Collision.Shapes.b2CircleShape,K=Box2D.Collision.Shapes.b2EdgeChainDef,y=Box2D.Collision.Shapes.b2EdgeShape,w=Box2D.Collision.Shapes.b2MassData,A=Box2D.Collision.Shapes.b2PolygonShape,U=Box2D.Collision.Shapes.b2Shape,p=Box2D.Common.Math.b2Mat22,B=Box2D.Common.Math.b2Math,Q=Box2D.Common.Math.b2Transform,V=Box2D.Common.Math.b2Vec2,M=Box2D.Collision.b2Distance,L=Box2D.Collision.b2DistanceInput,I=Box2D.Collision.b2DistanceOutput,W=Box2D.Collision.b2DistanceProxy,
Y=Box2D.Collision.b2SimplexCache;Box2D.inherit(G,Box2D.Collision.Shapes.b2Shape);G.prototype.__super=Box2D.Collision.Shapes.b2Shape.prototype;G.b2CircleShape=function(){Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this,arguments);this.m_p=new V};G.prototype.Copy=function(){var k=new G;k.Set(this);return k};G.prototype.Set=function(k){this.__super.Set.call(this,k);if(Box2D.is(k,G))this.m_p.SetV((k instanceof G?k:null).m_p)};G.prototype.TestPoint=function(k,z){var u=k.R,D=k.position.x+(u.col1.x*this.m_p.x+
u.col2.x*this.m_p.y);u=k.position.y+(u.col1.y*this.m_p.x+u.col2.y*this.m_p.y);D=z.x-D;u=z.y-u;return D*D+u*u<=this.m_radius*this.m_radius};G.prototype.RayCast=function(k,z,u){var D=u.R,H=z.p1.x-(u.position.x+(D.col1.x*this.m_p.x+D.col2.x*this.m_p.y));u=z.p1.y-(u.position.y+(D.col1.y*this.m_p.x+D.col2.y*this.m_p.y));D=z.p2.x-z.p1.x;var O=z.p2.y-z.p1.y,E=H*D+u*O,R=D*D+O*O,N=E*E-R*(H*H+u*u-this.m_radius*this.m_radius);if(N<0||R<Number.MIN_VALUE)return false;E=-(E+Math.sqrt(N));if(0<=E&&E<=z.maxFraction*
R){E/=R;k.fraction=E;k.normal.x=H+E*D;k.normal.y=u+E*O;k.normal.Normalize();return true}return false};G.prototype.ComputeAABB=function(k,z){var u=z.R,D=z.position.x+(u.col1.x*this.m_p.x+u.col2.x*this.m_p.y);u=z.position.y+(u.col1.y*this.m_p.x+u.col2.y*this.m_p.y);k.lowerBound.Set(D-this.m_radius,u-this.m_radius);k.upperBound.Set(D+this.m_radius,u+this.m_radius)};G.prototype.ComputeMass=function(k,z){if(z===undefined)z=0;k.mass=z*F.b2_pi*this.m_radius*this.m_radius;k.center.SetV(this.m_p);k.I=k.mass*
(0.5*this.m_radius*this.m_radius+(this.m_p.x*this.m_p.x+this.m_p.y*this.m_p.y))};G.prototype.ComputeSubmergedArea=function(k,z,u,D){if(z===undefined)z=0;u=B.MulX(u,this.m_p);var H=-(B.Dot(k,u)-z);if(H<-this.m_radius+Number.MIN_VALUE)return 0;if(H>this.m_radius){D.SetV(u);return Math.PI*this.m_radius*this.m_radius}z=this.m_radius*this.m_radius;var O=H*H;H=z*(Math.asin(H/this.m_radius)+Math.PI/2)+H*Math.sqrt(z-O);z=-2/3*Math.pow(z-O,1.5)/H;D.x=u.x+k.x*z;D.y=u.y+k.y*z;return H};G.prototype.GetLocalPosition=
function(){return this.m_p};G.prototype.SetLocalPosition=function(k){this.m_p.SetV(k)};G.prototype.GetRadius=function(){return this.m_radius};G.prototype.SetRadius=function(k){if(k===undefined)k=0;this.m_radius=k};G.prototype.b2CircleShape=function(k){if(k===undefined)k=0;this.__super.b2Shape.call(this);this.m_type=U.e_circleShape;this.m_radius=k};K.b2EdgeChainDef=function(){};K.prototype.b2EdgeChainDef=function(){this.vertexCount=0;this.isALoop=true;this.vertices=[]};Box2D.inherit(y,Box2D.Collision.Shapes.b2Shape);
y.prototype.__super=Box2D.Collision.Shapes.b2Shape.prototype;y.b2EdgeShape=function(){Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this,arguments);this.s_supportVec=new V;this.m_v1=new V;this.m_v2=new V;this.m_coreV1=new V;this.m_coreV2=new V;this.m_normal=new V;this.m_direction=new V;this.m_cornerDir1=new V;this.m_cornerDir2=new V};y.prototype.TestPoint=function(){return false};y.prototype.RayCast=function(k,z,u){var D,H=z.p2.x-z.p1.x,O=z.p2.y-z.p1.y;D=u.R;var E=u.position.x+(D.col1.x*this.m_v1.x+
D.col2.x*this.m_v1.y),R=u.position.y+(D.col1.y*this.m_v1.x+D.col2.y*this.m_v1.y),N=u.position.y+(D.col1.y*this.m_v2.x+D.col2.y*this.m_v2.y)-R;u=-(u.position.x+(D.col1.x*this.m_v2.x+D.col2.x*this.m_v2.y)-E);D=100*Number.MIN_VALUE;var S=-(H*N+O*u);if(S>D){E=z.p1.x-E;var aa=z.p1.y-R;R=E*N+aa*u;if(0<=R&&R<=z.maxFraction*S){z=-H*aa+O*E;if(-D*S<=z&&z<=S*(1+D)){R/=S;k.fraction=R;z=Math.sqrt(N*N+u*u);k.normal.x=N/z;k.normal.y=u/z;return true}}}return false};y.prototype.ComputeAABB=function(k,z){var u=z.R,
D=z.position.x+(u.col1.x*this.m_v1.x+u.col2.x*this.m_v1.y),H=z.position.y+(u.col1.y*this.m_v1.x+u.col2.y*this.m_v1.y),O=z.position.x+(u.col1.x*this.m_v2.x+u.col2.x*this.m_v2.y);u=z.position.y+(u.col1.y*this.m_v2.x+u.col2.y*this.m_v2.y);if(D<O){k.lowerBound.x=D;k.upperBound.x=O}else{k.lowerBound.x=O;k.upperBound.x=D}if(H<u){k.lowerBound.y=H;k.upperBound.y=u}else{k.lowerBound.y=u;k.upperBound.y=H}};y.prototype.ComputeMass=function(k){k.mass=0;k.center.SetV(this.m_v1);k.I=0};y.prototype.ComputeSubmergedArea=
function(k,z,u,D){if(z===undefined)z=0;var H=new V(k.x*z,k.y*z),O=B.MulX(u,this.m_v1);u=B.MulX(u,this.m_v2);var E=B.Dot(k,O)-z;k=B.Dot(k,u)-z;if(E>0)if(k>0)return 0;else{O.x=-k/(E-k)*O.x+E/(E-k)*u.x;O.y=-k/(E-k)*O.y+E/(E-k)*u.y}else if(k>0){u.x=-k/(E-k)*O.x+E/(E-k)*u.x;u.y=-k/(E-k)*O.y+E/(E-k)*u.y}D.x=(H.x+O.x+u.x)/3;D.y=(H.y+O.y+u.y)/3;return 0.5*((O.x-H.x)*(u.y-H.y)-(O.y-H.y)*(u.x-H.x))};y.prototype.GetLength=function(){return this.m_length};y.prototype.GetVertex1=function(){return this.m_v1};y.prototype.GetVertex2=
function(){return this.m_v2};y.prototype.GetCoreVertex1=function(){return this.m_coreV1};y.prototype.GetCoreVertex2=function(){return this.m_coreV2};y.prototype.GetNormalVector=function(){return this.m_normal};y.prototype.GetDirectionVector=function(){return this.m_direction};y.prototype.GetCorner1Vector=function(){return this.m_cornerDir1};y.prototype.GetCorner2Vector=function(){return this.m_cornerDir2};y.prototype.Corner1IsConvex=function(){return this.m_cornerConvex1};y.prototype.Corner2IsConvex=
function(){return this.m_cornerConvex2};y.prototype.GetFirstVertex=function(k){var z=k.R;return new V(k.position.x+(z.col1.x*this.m_coreV1.x+z.col2.x*this.m_coreV1.y),k.position.y+(z.col1.y*this.m_coreV1.x+z.col2.y*this.m_coreV1.y))};y.prototype.GetNextEdge=function(){return this.m_nextEdge};y.prototype.GetPrevEdge=function(){return this.m_prevEdge};y.prototype.Support=function(k,z,u){if(z===undefined)z=0;if(u===undefined)u=0;var D=k.R,H=k.position.x+(D.col1.x*this.m_coreV1.x+D.col2.x*this.m_coreV1.y),
O=k.position.y+(D.col1.y*this.m_coreV1.x+D.col2.y*this.m_coreV1.y),E=k.position.x+(D.col1.x*this.m_coreV2.x+D.col2.x*this.m_coreV2.y);k=k.position.y+(D.col1.y*this.m_coreV2.x+D.col2.y*this.m_coreV2.y);if(H*z+O*u>E*z+k*u){this.s_supportVec.x=H;this.s_supportVec.y=O}else{this.s_supportVec.x=E;this.s_supportVec.y=k}return this.s_supportVec};y.prototype.b2EdgeShape=function(k,z){this.__super.b2Shape.call(this);this.m_type=U.e_edgeShape;this.m_nextEdge=this.m_prevEdge=null;this.m_v1=k;this.m_v2=z;this.m_direction.Set(this.m_v2.x-
this.m_v1.x,this.m_v2.y-this.m_v1.y);this.m_length=this.m_direction.Normalize();this.m_normal.Set(this.m_direction.y,-this.m_direction.x);this.m_coreV1.Set(-F.b2_toiSlop*(this.m_normal.x-this.m_direction.x)+this.m_v1.x,-F.b2_toiSlop*(this.m_normal.y-this.m_direction.y)+this.m_v1.y);this.m_coreV2.Set(-F.b2_toiSlop*(this.m_normal.x+this.m_direction.x)+this.m_v2.x,-F.b2_toiSlop*(this.m_normal.y+this.m_direction.y)+this.m_v2.y);this.m_cornerDir1=this.m_normal;this.m_cornerDir2.Set(-this.m_normal.x,-this.m_normal.y)};
y.prototype.SetPrevEdge=function(k,z,u,D){this.m_prevEdge=k;this.m_coreV1=z;this.m_cornerDir1=u;this.m_cornerConvex1=D};y.prototype.SetNextEdge=function(k,z,u,D){this.m_nextEdge=k;this.m_coreV2=z;this.m_cornerDir2=u;this.m_cornerConvex2=D};w.b2MassData=function(){this.mass=0;this.center=new V(0,0);this.I=0};Box2D.inherit(A,Box2D.Collision.Shapes.b2Shape);A.prototype.__super=Box2D.Collision.Shapes.b2Shape.prototype;A.b2PolygonShape=function(){Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this,arguments)};
A.prototype.Copy=function(){var k=new A;k.Set(this);return k};A.prototype.Set=function(k){this.__super.Set.call(this,k);if(Box2D.is(k,A)){k=k instanceof A?k:null;this.m_centroid.SetV(k.m_centroid);this.m_vertexCount=k.m_vertexCount;this.Reserve(this.m_vertexCount);for(var z=0;z<this.m_vertexCount;z++){this.m_vertices[z].SetV(k.m_vertices[z]);this.m_normals[z].SetV(k.m_normals[z])}}};A.prototype.SetAsArray=function(k,z){if(z===undefined)z=0;var u=new Vector,D=0,H;for(D=0;D<k.length;++D){H=k[D];u.push(H)}this.SetAsVector(u,
z)};A.AsArray=function(k,z){if(z===undefined)z=0;var u=new A;u.SetAsArray(k,z);return u};A.prototype.SetAsVector=function(k,z){if(z===undefined)z=0;if(z==0)z=k.length;F.b2Assert(2<=z);this.m_vertexCount=z;this.Reserve(z);var u=0;for(u=0;u<this.m_vertexCount;u++)this.m_vertices[u].SetV(k[u]);for(u=0;u<this.m_vertexCount;++u){var D=parseInt(u),H=parseInt(u+1<this.m_vertexCount?u+1:0);D=B.SubtractVV(this.m_vertices[H],this.m_vertices[D]);F.b2Assert(D.LengthSquared()>Number.MIN_VALUE);this.m_normals[u].SetV(B.CrossVF(D,
1));this.m_normals[u].Normalize()}this.m_centroid=A.ComputeCentroid(this.m_vertices,this.m_vertexCount)};A.AsVector=function(k,z){if(z===undefined)z=0;var u=new A;u.SetAsVector(k,z);return u};A.prototype.SetAsBox=function(k,z){if(k===undefined)k=0;if(z===undefined)z=0;this.m_vertexCount=4;this.Reserve(4);this.m_vertices[0].Set(-k,-z);this.m_vertices[1].Set(k,-z);this.m_vertices[2].Set(k,z);this.m_vertices[3].Set(-k,z);this.m_normals[0].Set(0,-1);this.m_normals[1].Set(1,0);this.m_normals[2].Set(0,
1);this.m_normals[3].Set(-1,0);this.m_centroid.SetZero()};A.AsBox=function(k,z){if(k===undefined)k=0;if(z===undefined)z=0;var u=new A;u.SetAsBox(k,z);return u};A.prototype.SetAsOrientedBox=function(k,z,u,D){if(k===undefined)k=0;if(z===undefined)z=0;if(u===undefined)u=null;if(D===undefined)D=0;this.m_vertexCount=4;this.Reserve(4);this.m_vertices[0].Set(-k,-z);this.m_vertices[1].Set(k,-z);this.m_vertices[2].Set(k,z);this.m_vertices[3].Set(-k,z);this.m_normals[0].Set(0,-1);this.m_normals[1].Set(1,0);
this.m_normals[2].Set(0,1);this.m_normals[3].Set(-1,0);this.m_centroid=u;k=new Q;k.position=u;k.R.Set(D);for(u=0;u<this.m_vertexCount;++u){this.m_vertices[u]=B.MulX(k,this.m_vertices[u]);this.m_normals[u]=B.MulMV(k.R,this.m_normals[u])}};A.AsOrientedBox=function(k,z,u,D){if(k===undefined)k=0;if(z===undefined)z=0;if(u===undefined)u=null;if(D===undefined)D=0;var H=new A;H.SetAsOrientedBox(k,z,u,D);return H};A.prototype.SetAsEdge=function(k,z){this.m_vertexCount=2;this.Reserve(2);this.m_vertices[0].SetV(k);
this.m_vertices[1].SetV(z);this.m_centroid.x=0.5*(k.x+z.x);this.m_centroid.y=0.5*(k.y+z.y);this.m_normals[0]=B.CrossVF(B.SubtractVV(z,k),1);this.m_normals[0].Normalize();this.m_normals[1].x=-this.m_normals[0].x;this.m_normals[1].y=-this.m_normals[0].y};A.AsEdge=function(k,z){var u=new A;u.SetAsEdge(k,z);return u};A.prototype.TestPoint=function(k,z){var u;u=k.R;for(var D=z.x-k.position.x,H=z.y-k.position.y,O=D*u.col1.x+H*u.col1.y,E=D*u.col2.x+H*u.col2.y,R=0;R<this.m_vertexCount;++R){u=this.m_vertices[R];
D=O-u.x;H=E-u.y;u=this.m_normals[R];if(u.x*D+u.y*H>0)return false}return true};A.prototype.RayCast=function(k,z,u){var D=0,H=z.maxFraction,O=0,E=0,R,N;O=z.p1.x-u.position.x;E=z.p1.y-u.position.y;R=u.R;var S=O*R.col1.x+E*R.col1.y,aa=O*R.col2.x+E*R.col2.y;O=z.p2.x-u.position.x;E=z.p2.y-u.position.y;R=u.R;z=O*R.col1.x+E*R.col1.y-S;R=O*R.col2.x+E*R.col2.y-aa;for(var Z=parseInt(-1),d=0;d<this.m_vertexCount;++d){N=this.m_vertices[d];O=N.x-S;E=N.y-aa;N=this.m_normals[d];O=N.x*O+N.y*E;E=N.x*z+N.y*R;if(E==
0){if(O<0)return false}else if(E<0&&O<D*E){D=O/E;Z=d}else if(E>0&&O<H*E)H=O/E;if(H<D-Number.MIN_VALUE)return false}if(Z>=0){k.fraction=D;R=u.R;N=this.m_normals[Z];k.normal.x=R.col1.x*N.x+R.col2.x*N.y;k.normal.y=R.col1.y*N.x+R.col2.y*N.y;return true}return false};A.prototype.ComputeAABB=function(k,z){for(var u=z.R,D=this.m_vertices[0],H=z.position.x+(u.col1.x*D.x+u.col2.x*D.y),O=z.position.y+(u.col1.y*D.x+u.col2.y*D.y),E=H,R=O,N=1;N<this.m_vertexCount;++N){D=this.m_vertices[N];var S=z.position.x+(u.col1.x*
D.x+u.col2.x*D.y);D=z.position.y+(u.col1.y*D.x+u.col2.y*D.y);H=H<S?H:S;O=O<D?O:D;E=E>S?E:S;R=R>D?R:D}k.lowerBound.x=H-this.m_radius;k.lowerBound.y=O-this.m_radius;k.upperBound.x=E+this.m_radius;k.upperBound.y=R+this.m_radius};A.prototype.ComputeMass=function(k,z){if(z===undefined)z=0;if(this.m_vertexCount==2){k.center.x=0.5*(this.m_vertices[0].x+this.m_vertices[1].x);k.center.y=0.5*(this.m_vertices[0].y+this.m_vertices[1].y);k.mass=0;k.I=0}else{for(var u=0,D=0,H=0,O=0,E=1/3,R=0;R<this.m_vertexCount;++R){var N=
this.m_vertices[R],S=R+1<this.m_vertexCount?this.m_vertices[parseInt(R+1)]:this.m_vertices[0],aa=N.x-0,Z=N.y-0,d=S.x-0,h=S.y-0,l=aa*h-Z*d,j=0.5*l;H+=j;u+=j*E*(0+N.x+S.x);D+=j*E*(0+N.y+S.y);N=aa;Z=Z;d=d;h=h;O+=l*(E*(0.25*(N*N+d*N+d*d)+(0*N+0*d))+0+(E*(0.25*(Z*Z+h*Z+h*h)+(0*Z+0*h))+0))}k.mass=z*H;u*=1/H;D*=1/H;k.center.Set(u,D);k.I=z*O}};A.prototype.ComputeSubmergedArea=function(k,z,u,D){if(z===undefined)z=0;var H=B.MulTMV(u.R,k),O=z-B.Dot(k,u.position),E=new Vector_a2j_Number,R=0,N=parseInt(-1);z=
parseInt(-1);var S=false;for(k=k=0;k<this.m_vertexCount;++k){E[k]=B.Dot(H,this.m_vertices[k])-O;var aa=E[k]<-Number.MIN_VALUE;if(k>0)if(aa){if(!S){N=k-1;R++}}else if(S){z=k-1;R++}S=aa}switch(R){case 0:if(S){k=new w;this.ComputeMass(k,1);D.SetV(B.MulX(u,k.center));return k.mass}else return 0;case 1:if(N==-1)N=this.m_vertexCount-1;else z=this.m_vertexCount-1}k=parseInt((N+1)%this.m_vertexCount);H=parseInt((z+1)%this.m_vertexCount);O=(0-E[N])/(E[k]-E[N]);E=(0-E[z])/(E[H]-E[z]);N=new V(this.m_vertices[N].x*
(1-O)+this.m_vertices[k].x*O,this.m_vertices[N].y*(1-O)+this.m_vertices[k].y*O);z=new V(this.m_vertices[z].x*(1-E)+this.m_vertices[H].x*E,this.m_vertices[z].y*(1-E)+this.m_vertices[H].y*E);E=0;O=new V;R=this.m_vertices[k];for(k=k;k!=H;){k=(k+1)%this.m_vertexCount;S=k==H?z:this.m_vertices[k];aa=0.5*((R.x-N.x)*(S.y-N.y)-(R.y-N.y)*(S.x-N.x));E+=aa;O.x+=aa*(N.x+R.x+S.x)/3;O.y+=aa*(N.y+R.y+S.y)/3;R=S}O.Multiply(1/E);D.SetV(B.MulX(u,O));return E};A.prototype.GetVertexCount=function(){return this.m_vertexCount};
A.prototype.GetVertices=function(){return this.m_vertices};A.prototype.GetNormals=function(){return this.m_normals};A.prototype.GetSupport=function(k){for(var z=0,u=this.m_vertices[0].x*k.x+this.m_vertices[0].y*k.y,D=1;D<this.m_vertexCount;++D){var H=this.m_vertices[D].x*k.x+this.m_vertices[D].y*k.y;if(H>u){z=D;u=H}}return z};A.prototype.GetSupportVertex=function(k){for(var z=0,u=this.m_vertices[0].x*k.x+this.m_vertices[0].y*k.y,D=1;D<this.m_vertexCount;++D){var H=this.m_vertices[D].x*k.x+this.m_vertices[D].y*
k.y;if(H>u){z=D;u=H}}return this.m_vertices[z]};A.prototype.Validate=function(){return false};A.prototype.b2PolygonShape=function(){this.__super.b2Shape.call(this);this.m_type=U.e_polygonShape;this.m_centroid=new V;this.m_vertices=new Vector;this.m_normals=new Vector};A.prototype.Reserve=function(k){if(k===undefined)k=0;for(var z=parseInt(this.m_vertices.length);z<k;z++){this.m_vertices[z]=new V;this.m_normals[z]=new V}};A.ComputeCentroid=function(k,z){if(z===undefined)z=0;for(var u=new V,D=0,H=1/
3,O=0;O<z;++O){var E=k[O],R=O+1<z?k[parseInt(O+1)]:k[0],N=0.5*((E.x-0)*(R.y-0)-(E.y-0)*(R.x-0));D+=N;u.x+=N*H*(0+E.x+R.x);u.y+=N*H*(0+E.y+R.y)}u.x*=1/D;u.y*=1/D;return u};A.ComputeOBB=function(k,z,u){if(u===undefined)u=0;var D=0,H=new Vector(u+1);for(D=0;D<u;++D)H[D]=z[D];H[u]=H[0];z=Number.MAX_VALUE;for(D=1;D<=u;++D){var O=H[parseInt(D-1)],E=H[D].x-O.x,R=H[D].y-O.y,N=Math.sqrt(E*E+R*R);E/=N;R/=N;for(var S=-R,aa=E,Z=N=Number.MAX_VALUE,d=-Number.MAX_VALUE,h=-Number.MAX_VALUE,l=0;l<u;++l){var j=H[l].x-
O.x,o=H[l].y-O.y,q=E*j+R*o;j=S*j+aa*o;if(q<N)N=q;if(j<Z)Z=j;if(q>d)d=q;if(j>h)h=j}l=(d-N)*(h-Z);if(l<0.95*z){z=l;k.R.col1.x=E;k.R.col1.y=R;k.R.col2.x=S;k.R.col2.y=aa;E=0.5*(N+d);R=0.5*(Z+h);S=k.R;k.center.x=O.x+(S.col1.x*E+S.col2.x*R);k.center.y=O.y+(S.col1.y*E+S.col2.y*R);k.extents.x=0.5*(d-N);k.extents.y=0.5*(h-Z)}}};Box2D.postDefs.push(function(){Box2D.Collision.Shapes.b2PolygonShape.s_mat=new p});U.b2Shape=function(){};U.prototype.Copy=function(){return null};U.prototype.Set=function(k){this.m_radius=
k.m_radius};U.prototype.GetType=function(){return this.m_type};U.prototype.TestPoint=function(){return false};U.prototype.RayCast=function(){return false};U.prototype.ComputeAABB=function(){};U.prototype.ComputeMass=function(){};U.prototype.ComputeSubmergedArea=function(){return 0};U.TestOverlap=function(k,z,u,D){var H=new L;H.proxyA=new W;H.proxyA.Set(k);H.proxyB=new W;H.proxyB.Set(u);H.transformA=z;H.transformB=D;H.useRadii=true;k=new Y;k.count=0;z=new I;M.Distance(z,k,H);return z.distance<10*Number.MIN_VALUE};
U.prototype.b2Shape=function(){this.m_type=U.e_unknownShape;this.m_radius=F.b2_linearSlop};Box2D.postDefs.push(function(){Box2D.Collision.Shapes.b2Shape.e_unknownShape=parseInt(-1);Box2D.Collision.Shapes.b2Shape.e_circleShape=0;Box2D.Collision.Shapes.b2Shape.e_polygonShape=1;Box2D.Collision.Shapes.b2Shape.e_edgeShape=2;Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount=3;Box2D.Collision.Shapes.b2Shape.e_hitCollide=1;Box2D.Collision.Shapes.b2Shape.e_missCollide=0;Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide=
parseInt(-1)})})();
(function(){var F=Box2D.Common.b2Color,G=Box2D.Common.b2Settings,K=Box2D.Common.Math.b2Math;F.b2Color=function(){this._b=this._g=this._r=0};F.prototype.b2Color=function(y,w,A){if(y===undefined)y=0;if(w===undefined)w=0;if(A===undefined)A=0;this._r=Box2D.parseUInt(255*K.Clamp(y,0,1));this._g=Box2D.parseUInt(255*K.Clamp(w,0,1));this._b=Box2D.parseUInt(255*K.Clamp(A,0,1))};F.prototype.Set=function(y,w,A){if(y===undefined)y=0;if(w===undefined)w=0;if(A===undefined)A=0;this._r=Box2D.parseUInt(255*K.Clamp(y,
0,1));this._g=Box2D.parseUInt(255*K.Clamp(w,0,1));this._b=Box2D.parseUInt(255*K.Clamp(A,0,1))};Object.defineProperty(F.prototype,"r",{enumerable:false,configurable:true,set:function(y){if(y===undefined)y=0;this._r=Box2D.parseUInt(255*K.Clamp(y,0,1))}});Object.defineProperty(F.prototype,"g",{enumerable:false,configurable:true,set:function(y){if(y===undefined)y=0;this._g=Box2D.parseUInt(255*K.Clamp(y,0,1))}});Object.defineProperty(F.prototype,"b",{enumerable:false,configurable:true,set:function(y){if(y===
undefined)y=0;this._b=Box2D.parseUInt(255*K.Clamp(y,0,1))}});Object.defineProperty(F.prototype,"color",{enumerable:false,configurable:true,get:function(){return this._r<<16|this._g<<8|this._b}});G.b2Settings=function(){};G.b2MixFriction=function(y,w){if(y===undefined)y=0;if(w===undefined)w=0;return Math.sqrt(y*w)};G.b2MixRestitution=function(y,w){if(y===undefined)y=0;if(w===undefined)w=0;return y>w?y:w};G.b2Assert=function(y){if(!y)throw"Assertion Failed";};Box2D.postDefs.push(function(){Box2D.Common.b2Settings.VERSION=
"2.1alpha";Box2D.Common.b2Settings.USHRT_MAX=65535;Box2D.Common.b2Settings.b2_pi=Math.PI;Box2D.Common.b2Settings.b2_maxManifoldPoints=2;Box2D.Common.b2Settings.b2_aabbExtension=0.1;Box2D.Common.b2Settings.b2_aabbMultiplier=2;Box2D.Common.b2Settings.b2_polygonRadius=2*G.b2_linearSlop;Box2D.Common.b2Settings.b2_linearSlop=0.0050;Box2D.Common.b2Settings.b2_angularSlop=2/180*G.b2_pi;Box2D.Common.b2Settings.b2_toiSlop=8*G.b2_linearSlop;Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland=32;Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland=
32;Box2D.Common.b2Settings.b2_velocityThreshold=1;Box2D.Common.b2Settings.b2_maxLinearCorrection=0.2;Box2D.Common.b2Settings.b2_maxAngularCorrection=8/180*G.b2_pi;Box2D.Common.b2Settings.b2_maxTranslation=2;Box2D.Common.b2Settings.b2_maxTranslationSquared=G.b2_maxTranslation*G.b2_maxTranslation;Box2D.Common.b2Settings.b2_maxRotation=0.5*G.b2_pi;Box2D.Common.b2Settings.b2_maxRotationSquared=G.b2_maxRotation*G.b2_maxRotation;Box2D.Common.b2Settings.b2_contactBaumgarte=0.2;Box2D.Common.b2Settings.b2_timeToSleep=
0.5;Box2D.Common.b2Settings.b2_linearSleepTolerance=0.01;Box2D.Common.b2Settings.b2_angularSleepTolerance=2/180*G.b2_pi})})();
(function(){var F=Box2D.Common.Math.b2Mat22,G=Box2D.Common.Math.b2Mat33,K=Box2D.Common.Math.b2Math,y=Box2D.Common.Math.b2Sweep,w=Box2D.Common.Math.b2Transform,A=Box2D.Common.Math.b2Vec2,U=Box2D.Common.Math.b2Vec3;F.b2Mat22=function(){this.col1=new A;this.col2=new A};F.prototype.b2Mat22=function(){this.SetIdentity()};F.FromAngle=function(p){if(p===undefined)p=0;var B=new F;B.Set(p);return B};F.FromVV=function(p,B){var Q=new F;Q.SetVV(p,B);return Q};F.prototype.Set=function(p){if(p===undefined)p=0;
var B=Math.cos(p);p=Math.sin(p);this.col1.x=B;this.col2.x=-p;this.col1.y=p;this.col2.y=B};F.prototype.SetVV=function(p,B){this.col1.SetV(p);this.col2.SetV(B)};F.prototype.Copy=function(){var p=new F;p.SetM(this);return p};F.prototype.SetM=function(p){this.col1.SetV(p.col1);this.col2.SetV(p.col2)};F.prototype.AddM=function(p){this.col1.x+=p.col1.x;this.col1.y+=p.col1.y;this.col2.x+=p.col2.x;this.col2.y+=p.col2.y};F.prototype.SetIdentity=function(){this.col1.x=1;this.col2.x=0;this.col1.y=0;this.col2.y=
1};F.prototype.SetZero=function(){this.col1.x=0;this.col2.x=0;this.col1.y=0;this.col2.y=0};F.prototype.GetAngle=function(){return Math.atan2(this.col1.y,this.col1.x)};F.prototype.GetInverse=function(p){var B=this.col1.x,Q=this.col2.x,V=this.col1.y,M=this.col2.y,L=B*M-Q*V;if(L!=0)L=1/L;p.col1.x=L*M;p.col2.x=-L*Q;p.col1.y=-L*V;p.col2.y=L*B;return p};F.prototype.Solve=function(p,B,Q){if(B===undefined)B=0;if(Q===undefined)Q=0;var V=this.col1.x,M=this.col2.x,L=this.col1.y,I=this.col2.y,W=V*I-M*L;if(W!=
0)W=1/W;p.x=W*(I*B-M*Q);p.y=W*(V*Q-L*B);return p};F.prototype.Abs=function(){this.col1.Abs();this.col2.Abs()};G.b2Mat33=function(){this.col1=new U;this.col2=new U;this.col3=new U};G.prototype.b2Mat33=function(p,B,Q){if(p===undefined)p=null;if(B===undefined)B=null;if(Q===undefined)Q=null;if(!p&&!B&&!Q){this.col1.SetZero();this.col2.SetZero();this.col3.SetZero()}else{this.col1.SetV(p);this.col2.SetV(B);this.col3.SetV(Q)}};G.prototype.SetVVV=function(p,B,Q){this.col1.SetV(p);this.col2.SetV(B);this.col3.SetV(Q)};
G.prototype.Copy=function(){return new G(this.col1,this.col2,this.col3)};G.prototype.SetM=function(p){this.col1.SetV(p.col1);this.col2.SetV(p.col2);this.col3.SetV(p.col3)};G.prototype.AddM=function(p){this.col1.x+=p.col1.x;this.col1.y+=p.col1.y;this.col1.z+=p.col1.z;this.col2.x+=p.col2.x;this.col2.y+=p.col2.y;this.col2.z+=p.col2.z;this.col3.x+=p.col3.x;this.col3.y+=p.col3.y;this.col3.z+=p.col3.z};G.prototype.SetIdentity=function(){this.col1.x=1;this.col2.x=0;this.col3.x=0;this.col1.y=0;this.col2.y=
1;this.col3.y=0;this.col1.z=0;this.col2.z=0;this.col3.z=1};G.prototype.SetZero=function(){this.col1.x=0;this.col2.x=0;this.col3.x=0;this.col1.y=0;this.col2.y=0;this.col3.y=0;this.col1.z=0;this.col2.z=0;this.col3.z=0};G.prototype.Solve22=function(p,B,Q){if(B===undefined)B=0;if(Q===undefined)Q=0;var V=this.col1.x,M=this.col2.x,L=this.col1.y,I=this.col2.y,W=V*I-M*L;if(W!=0)W=1/W;p.x=W*(I*B-M*Q);p.y=W*(V*Q-L*B);return p};G.prototype.Solve33=function(p,B,Q,V){if(B===undefined)B=0;if(Q===undefined)Q=0;
if(V===undefined)V=0;var M=this.col1.x,L=this.col1.y,I=this.col1.z,W=this.col2.x,Y=this.col2.y,k=this.col2.z,z=this.col3.x,u=this.col3.y,D=this.col3.z,H=M*(Y*D-k*u)+L*(k*z-W*D)+I*(W*u-Y*z);if(H!=0)H=1/H;p.x=H*(B*(Y*D-k*u)+Q*(k*z-W*D)+V*(W*u-Y*z));p.y=H*(M*(Q*D-V*u)+L*(V*z-B*D)+I*(B*u-Q*z));p.z=H*(M*(Y*V-k*Q)+L*(k*B-W*V)+I*(W*Q-Y*B));return p};K.b2Math=function(){};K.IsValid=function(p){if(p===undefined)p=0;return isFinite(p)};K.Dot=function(p,B){return p.x*B.x+p.y*B.y};K.CrossVV=function(p,B){return p.x*
B.y-p.y*B.x};K.CrossVF=function(p,B){if(B===undefined)B=0;return new A(B*p.y,-B*p.x)};K.CrossFV=function(p,B){if(p===undefined)p=0;return new A(-p*B.y,p*B.x)};K.MulMV=function(p,B){return new A(p.col1.x*B.x+p.col2.x*B.y,p.col1.y*B.x+p.col2.y*B.y)};K.MulTMV=function(p,B){return new A(K.Dot(B,p.col1),K.Dot(B,p.col2))};K.MulX=function(p,B){var Q=K.MulMV(p.R,B);Q.x+=p.position.x;Q.y+=p.position.y;return Q};K.MulXT=function(p,B){var Q=K.SubtractVV(B,p.position),V=Q.x*p.R.col1.x+Q.y*p.R.col1.y;Q.y=Q.x*
p.R.col2.x+Q.y*p.R.col2.y;Q.x=V;return Q};K.AddVV=function(p,B){return new A(p.x+B.x,p.y+B.y)};K.SubtractVV=function(p,B){return new A(p.x-B.x,p.y-B.y)};K.Distance=function(p,B){var Q=p.x-B.x,V=p.y-B.y;return Math.sqrt(Q*Q+V*V)};K.DistanceSquared=function(p,B){var Q=p.x-B.x,V=p.y-B.y;return Q*Q+V*V};K.MulFV=function(p,B){if(p===undefined)p=0;return new A(p*B.x,p*B.y)};K.AddMM=function(p,B){return F.FromVV(K.AddVV(p.col1,B.col1),K.AddVV(p.col2,B.col2))};K.MulMM=function(p,B){return F.FromVV(K.MulMV(p,
B.col1),K.MulMV(p,B.col2))};K.MulTMM=function(p,B){var Q=new A(K.Dot(p.col1,B.col1),K.Dot(p.col2,B.col1)),V=new A(K.Dot(p.col1,B.col2),K.Dot(p.col2,B.col2));return F.FromVV(Q,V)};K.Abs=function(p){if(p===undefined)p=0;return p>0?p:-p};K.AbsV=function(p){return new A(K.Abs(p.x),K.Abs(p.y))};K.AbsM=function(p){return F.FromVV(K.AbsV(p.col1),K.AbsV(p.col2))};K.Min=function(p,B){if(p===undefined)p=0;if(B===undefined)B=0;return p<B?p:B};K.MinV=function(p,B){return new A(K.Min(p.x,B.x),K.Min(p.y,B.y))};
K.Max=function(p,B){if(p===undefined)p=0;if(B===undefined)B=0;return p>B?p:B};K.MaxV=function(p,B){return new A(K.Max(p.x,B.x),K.Max(p.y,B.y))};K.Clamp=function(p,B,Q){if(p===undefined)p=0;if(B===undefined)B=0;if(Q===undefined)Q=0;return p<B?B:p>Q?Q:p};K.ClampV=function(p,B,Q){return K.MaxV(B,K.MinV(p,Q))};K.Swap=function(p,B){var Q=p[0];p[0]=B[0];B[0]=Q};K.Random=function(){return Math.random()*2-1};K.RandomRange=function(p,B){if(p===undefined)p=0;if(B===undefined)B=0;var Q=Math.random();return Q=
(B-p)*Q+p};K.NextPowerOfTwo=function(p){if(p===undefined)p=0;p|=p>>1&2147483647;p|=p>>2&1073741823;p|=p>>4&268435455;p|=p>>8&16777215;p|=p>>16&65535;return p+1};K.IsPowerOfTwo=function(p){if(p===undefined)p=0;return p>0&&(p&p-1)==0};Box2D.postDefs.push(function(){Box2D.Common.Math.b2Math.b2Vec2_zero=new A(0,0);Box2D.Common.Math.b2Math.b2Mat22_identity=F.FromVV(new A(1,0),new A(0,1));Box2D.Common.Math.b2Math.b2Transform_identity=new w(K.b2Vec2_zero,K.b2Mat22_identity)});y.b2Sweep=function(){this.localCenter=
new A;this.c0=new A;this.c=new A};y.prototype.Set=function(p){this.localCenter.SetV(p.localCenter);this.c0.SetV(p.c0);this.c.SetV(p.c);this.a0=p.a0;this.a=p.a;this.t0=p.t0};y.prototype.Copy=function(){var p=new y;p.localCenter.SetV(this.localCenter);p.c0.SetV(this.c0);p.c.SetV(this.c);p.a0=this.a0;p.a=this.a;p.t0=this.t0;return p};y.prototype.GetTransform=function(p,B){if(B===undefined)B=0;p.position.x=(1-B)*this.c0.x+B*this.c.x;p.position.y=(1-B)*this.c0.y+B*this.c.y;p.R.Set((1-B)*this.a0+B*this.a);
var Q=p.R;p.position.x-=Q.col1.x*this.localCenter.x+Q.col2.x*this.localCenter.y;p.position.y-=Q.col1.y*this.localCenter.x+Q.col2.y*this.localCenter.y};y.prototype.Advance=function(p){if(p===undefined)p=0;if(this.t0<p&&1-this.t0>Number.MIN_VALUE){var B=(p-this.t0)/(1-this.t0);this.c0.x=(1-B)*this.c0.x+B*this.c.x;this.c0.y=(1-B)*this.c0.y+B*this.c.y;this.a0=(1-B)*this.a0+B*this.a;this.t0=p}};w.b2Transform=function(){this.position=new A;this.R=new F};w.prototype.b2Transform=function(p,B){if(p===undefined)p=
null;if(B===undefined)B=null;if(p){this.position.SetV(p);this.R.SetM(B)}};w.prototype.Initialize=function(p,B){this.position.SetV(p);this.R.SetM(B)};w.prototype.SetIdentity=function(){this.position.SetZero();this.R.SetIdentity()};w.prototype.Set=function(p){this.position.SetV(p.position);this.R.SetM(p.R)};w.prototype.GetAngle=function(){return Math.atan2(this.R.col1.y,this.R.col1.x)};A.b2Vec2=function(){};A.prototype.b2Vec2=function(p,B){if(p===undefined)p=0;if(B===undefined)B=0;this.x=p;this.y=B};
A.prototype.SetZero=function(){this.y=this.x=0};A.prototype.Set=function(p,B){if(p===undefined)p=0;if(B===undefined)B=0;this.x=p;this.y=B};A.prototype.SetV=function(p){this.x=p.x;this.y=p.y};A.prototype.GetNegative=function(){return new A(-this.x,-this.y)};A.prototype.NegativeSelf=function(){this.x=-this.x;this.y=-this.y};A.Make=function(p,B){if(p===undefined)p=0;if(B===undefined)B=0;return new A(p,B)};A.prototype.Copy=function(){return new A(this.x,this.y)};A.prototype.Add=function(p){this.x+=p.x;
this.y+=p.y};A.prototype.Subtract=function(p){this.x-=p.x;this.y-=p.y};A.prototype.Multiply=function(p){if(p===undefined)p=0;this.x*=p;this.y*=p};A.prototype.MulM=function(p){var B=this.x;this.x=p.col1.x*B+p.col2.x*this.y;this.y=p.col1.y*B+p.col2.y*this.y};A.prototype.MulTM=function(p){var B=K.Dot(this,p.col1);this.y=K.Dot(this,p.col2);this.x=B};A.prototype.CrossVF=function(p){if(p===undefined)p=0;var B=this.x;this.x=p*this.y;this.y=-p*B};A.prototype.CrossFV=function(p){if(p===undefined)p=0;var B=
this.x;this.x=-p*this.y;this.y=p*B};A.prototype.MinV=function(p){this.x=this.x<p.x?this.x:p.x;this.y=this.y<p.y?this.y:p.y};A.prototype.MaxV=function(p){this.x=this.x>p.x?this.x:p.x;this.y=this.y>p.y?this.y:p.y};A.prototype.Abs=function(){if(this.x<0)this.x=-this.x;if(this.y<0)this.y=-this.y};A.prototype.Length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)};A.prototype.LengthSquared=function(){return this.x*this.x+this.y*this.y};A.prototype.Normalize=function(){var p=Math.sqrt(this.x*this.x+
this.y*this.y);if(p<Number.MIN_VALUE)return 0;var B=1/p;this.x*=B;this.y*=B;return p};A.prototype.IsValid=function(){return K.IsValid(this.x)&&K.IsValid(this.y)};U.b2Vec3=function(){};U.prototype.b2Vec3=function(p,B,Q){if(p===undefined)p=0;if(B===undefined)B=0;if(Q===undefined)Q=0;this.x=p;this.y=B;this.z=Q};U.prototype.SetZero=function(){this.x=this.y=this.z=0};U.prototype.Set=function(p,B,Q){if(p===undefined)p=0;if(B===undefined)B=0;if(Q===undefined)Q=0;this.x=p;this.y=B;this.z=Q};U.prototype.SetV=
function(p){this.x=p.x;this.y=p.y;this.z=p.z};U.prototype.GetNegative=function(){return new U(-this.x,-this.y,-this.z)};U.prototype.NegativeSelf=function(){this.x=-this.x;this.y=-this.y;this.z=-this.z};U.prototype.Copy=function(){return new U(this.x,this.y,this.z)};U.prototype.Add=function(p){this.x+=p.x;this.y+=p.y;this.z+=p.z};U.prototype.Subtract=function(p){this.x-=p.x;this.y-=p.y;this.z-=p.z};U.prototype.Multiply=function(p){if(p===undefined)p=0;this.x*=p;this.y*=p;this.z*=p}})();
(function(){var F=Box2D.Common.Math.b2Math,G=Box2D.Common.Math.b2Sweep,K=Box2D.Common.Math.b2Transform,y=Box2D.Common.Math.b2Vec2,w=Box2D.Common.b2Color,A=Box2D.Common.b2Settings,U=Box2D.Collision.b2AABB,p=Box2D.Collision.b2ContactPoint,B=Box2D.Collision.b2DynamicTreeBroadPhase,Q=Box2D.Collision.b2RayCastInput,V=Box2D.Collision.b2RayCastOutput,M=Box2D.Collision.Shapes.b2CircleShape,L=Box2D.Collision.Shapes.b2EdgeShape,I=Box2D.Collision.Shapes.b2MassData,W=Box2D.Collision.Shapes.b2PolygonShape,Y=Box2D.Collision.Shapes.b2Shape,
k=Box2D.Dynamics.b2Body,z=Box2D.Dynamics.b2BodyDef,u=Box2D.Dynamics.b2ContactFilter,D=Box2D.Dynamics.b2ContactImpulse,H=Box2D.Dynamics.b2ContactListener,O=Box2D.Dynamics.b2ContactManager,E=Box2D.Dynamics.b2DebugDraw,R=Box2D.Dynamics.b2DestructionListener,N=Box2D.Dynamics.b2FilterData,S=Box2D.Dynamics.b2Fixture,aa=Box2D.Dynamics.b2FixtureDef,Z=Box2D.Dynamics.b2Island,d=Box2D.Dynamics.b2TimeStep,h=Box2D.Dynamics.b2World,l=Box2D.Dynamics.Contacts.b2Contact,j=Box2D.Dynamics.Contacts.b2ContactFactory,
o=Box2D.Dynamics.Contacts.b2ContactSolver,q=Box2D.Dynamics.Joints.b2Joint,n=Box2D.Dynamics.Joints.b2PulleyJoint;k.b2Body=function(){this.m_xf=new K;this.m_sweep=new G;this.m_linearVelocity=new y;this.m_force=new y};k.prototype.connectEdges=function(a,c,g){if(g===undefined)g=0;var b=Math.atan2(c.GetDirectionVector().y,c.GetDirectionVector().x);g=F.MulFV(Math.tan((b-g)*0.5),c.GetDirectionVector());g=F.SubtractVV(g,c.GetNormalVector());g=F.MulFV(A.b2_toiSlop,g);g=F.AddVV(g,c.GetVertex1());var e=F.AddVV(a.GetDirectionVector(),
c.GetDirectionVector());e.Normalize();var f=F.Dot(a.GetDirectionVector(),c.GetNormalVector())>0;a.SetNextEdge(c,g,e,f);c.SetPrevEdge(a,g,e,f);return b};k.prototype.CreateFixture=function(a){if(this.m_world.IsLocked()==true)return null;var c=new S;c.Create(this,this.m_xf,a);this.m_flags&k.e_activeFlag&&c.CreateProxy(this.m_world.m_contactManager.m_broadPhase,this.m_xf);c.m_next=this.m_fixtureList;this.m_fixtureList=c;++this.m_fixtureCount;c.m_body=this;c.m_density>0&&this.ResetMassData();this.m_world.m_flags|=
h.e_newFixture;return c};k.prototype.CreateFixture2=function(a,c){if(c===undefined)c=0;var g=new aa;g.shape=a;g.density=c;return this.CreateFixture(g)};k.prototype.DestroyFixture=function(a){if(this.m_world.IsLocked()!=true){for(var c=this.m_fixtureList,g=null;c!=null;){if(c==a){if(g)g.m_next=a.m_next;else this.m_fixtureList=a.m_next;break}g=c;c=c.m_next}for(c=this.m_contactList;c;){g=c.contact;c=c.next;var b=g.GetFixtureA(),e=g.GetFixtureB();if(a==b||a==e)this.m_world.m_contactManager.Destroy(g)}this.m_flags&
k.e_activeFlag&&a.DestroyProxy(this.m_world.m_contactManager.m_broadPhase);a.Destroy();a.m_body=null;a.m_next=null;--this.m_fixtureCount;this.ResetMassData()}};k.prototype.SetPositionAndAngle=function(a,c){if(c===undefined)c=0;var g;if(this.m_world.IsLocked()!=true){this.m_xf.R.Set(c);this.m_xf.position.SetV(a);g=this.m_xf.R;var b=this.m_sweep.localCenter;this.m_sweep.c.x=g.col1.x*b.x+g.col2.x*b.y;this.m_sweep.c.y=g.col1.y*b.x+g.col2.y*b.y;this.m_sweep.c.x+=this.m_xf.position.x;this.m_sweep.c.y+=
this.m_xf.position.y;this.m_sweep.c0.SetV(this.m_sweep.c);this.m_sweep.a0=this.m_sweep.a=c;b=this.m_world.m_contactManager.m_broadPhase;for(g=this.m_fixtureList;g;g=g.m_next)g.Synchronize(b,this.m_xf,this.m_xf);this.m_world.m_contactManager.FindNewContacts()}};k.prototype.SetTransform=function(a){this.SetPositionAndAngle(a.position,a.GetAngle())};k.prototype.GetTransform=function(){return this.m_xf};k.prototype.GetPosition=function(){return this.m_xf.position};k.prototype.SetPosition=function(a){this.SetPositionAndAngle(a,
this.GetAngle())};k.prototype.GetAngle=function(){return this.m_sweep.a};k.prototype.SetAngle=function(a){if(a===undefined)a=0;this.SetPositionAndAngle(this.GetPosition(),a)};k.prototype.GetWorldCenter=function(){return this.m_sweep.c};k.prototype.GetLocalCenter=function(){return this.m_sweep.localCenter};k.prototype.SetLinearVelocity=function(a){this.m_type!=k.b2_staticBody&&this.m_linearVelocity.SetV(a)};k.prototype.GetLinearVelocity=function(){return this.m_linearVelocity};k.prototype.SetAngularVelocity=
function(a){if(a===undefined)a=0;if(this.m_type!=k.b2_staticBody)this.m_angularVelocity=a};k.prototype.GetAngularVelocity=function(){return this.m_angularVelocity};k.prototype.GetDefinition=function(){var a=new z;a.type=this.GetType();a.allowSleep=(this.m_flags&k.e_allowSleepFlag)==k.e_allowSleepFlag;a.angle=this.GetAngle();a.angularDamping=this.m_angularDamping;a.angularVelocity=this.m_angularVelocity;a.fixedRotation=(this.m_flags&k.e_fixedRotationFlag)==k.e_fixedRotationFlag;a.bullet=(this.m_flags&
k.e_bulletFlag)==k.e_bulletFlag;a.awake=(this.m_flags&k.e_awakeFlag)==k.e_awakeFlag;a.linearDamping=this.m_linearDamping;a.linearVelocity.SetV(this.GetLinearVelocity());a.position=this.GetPosition();a.userData=this.GetUserData();return a};k.prototype.ApplyForce=function(a,c){if(this.m_type==k.b2_dynamicBody){this.IsAwake()==false&&this.SetAwake(true);this.m_force.x+=a.x;this.m_force.y+=a.y;this.m_torque+=(c.x-this.m_sweep.c.x)*a.y-(c.y-this.m_sweep.c.y)*a.x}};k.prototype.ApplyTorque=function(a){if(a===
undefined)a=0;if(this.m_type==k.b2_dynamicBody){this.IsAwake()==false&&this.SetAwake(true);this.m_torque+=a}};k.prototype.ApplyImpulse=function(a,c){if(this.m_type==k.b2_dynamicBody){this.IsAwake()==false&&this.SetAwake(true);this.m_linearVelocity.x+=this.m_invMass*a.x;this.m_linearVelocity.y+=this.m_invMass*a.y;this.m_angularVelocity+=this.m_invI*((c.x-this.m_sweep.c.x)*a.y-(c.y-this.m_sweep.c.y)*a.x)}};k.prototype.Split=function(a){for(var c=this.GetLinearVelocity().Copy(),g=this.GetAngularVelocity(),
b=this.GetWorldCenter(),e=this.m_world.CreateBody(this.GetDefinition()),f,m=this.m_fixtureList;m;)if(a(m)){var r=m.m_next;if(f)f.m_next=r;else this.m_fixtureList=r;this.m_fixtureCount--;m.m_next=e.m_fixtureList;e.m_fixtureList=m;e.m_fixtureCount++;m.m_body=e;m=r}else{f=m;m=m.m_next}this.ResetMassData();e.ResetMassData();f=this.GetWorldCenter();a=e.GetWorldCenter();f=F.AddVV(c,F.CrossFV(g,F.SubtractVV(f,b)));c=F.AddVV(c,F.CrossFV(g,F.SubtractVV(a,b)));this.SetLinearVelocity(f);e.SetLinearVelocity(c);
this.SetAngularVelocity(g);e.SetAngularVelocity(g);this.SynchronizeFixtures();e.SynchronizeFixtures();return e};k.prototype.Merge=function(a){var c;for(c=a.m_fixtureList;c;){var g=c.m_next;a.m_fixtureCount--;c.m_next=this.m_fixtureList;this.m_fixtureList=c;this.m_fixtureCount++;c.m_body=e;c=g}b.m_fixtureCount=0;var b=this,e=a;b.GetWorldCenter();e.GetWorldCenter();b.GetLinearVelocity().Copy();e.GetLinearVelocity().Copy();b.GetAngularVelocity();e.GetAngularVelocity();b.ResetMassData();this.SynchronizeFixtures()};
k.prototype.GetMass=function(){return this.m_mass};k.prototype.GetInertia=function(){return this.m_I};k.prototype.GetMassData=function(a){a.mass=this.m_mass;a.I=this.m_I;a.center.SetV(this.m_sweep.localCenter)};k.prototype.SetMassData=function(a){A.b2Assert(this.m_world.IsLocked()==false);if(this.m_world.IsLocked()!=true)if(this.m_type==k.b2_dynamicBody){this.m_invI=this.m_I=this.m_invMass=0;this.m_mass=a.mass;if(this.m_mass<=0)this.m_mass=1;this.m_invMass=1/this.m_mass;if(a.I>0&&(this.m_flags&k.e_fixedRotationFlag)==
0){this.m_I=a.I-this.m_mass*(a.center.x*a.center.x+a.center.y*a.center.y);this.m_invI=1/this.m_I}var c=this.m_sweep.c.Copy();this.m_sweep.localCenter.SetV(a.center);this.m_sweep.c0.SetV(F.MulX(this.m_xf,this.m_sweep.localCenter));this.m_sweep.c.SetV(this.m_sweep.c0);this.m_linearVelocity.x+=this.m_angularVelocity*-(this.m_sweep.c.y-c.y);this.m_linearVelocity.y+=this.m_angularVelocity*+(this.m_sweep.c.x-c.x)}};k.prototype.ResetMassData=function(){this.m_invI=this.m_I=this.m_invMass=this.m_mass=0;this.m_sweep.localCenter.SetZero();
if(!(this.m_type==k.b2_staticBody||this.m_type==k.b2_kinematicBody)){for(var a=y.Make(0,0),c=this.m_fixtureList;c;c=c.m_next)if(c.m_density!=0){var g=c.GetMassData();this.m_mass+=g.mass;a.x+=g.center.x*g.mass;a.y+=g.center.y*g.mass;this.m_I+=g.I}if(this.m_mass>0){this.m_invMass=1/this.m_mass;a.x*=this.m_invMass;a.y*=this.m_invMass}else this.m_invMass=this.m_mass=1;if(this.m_I>0&&(this.m_flags&k.e_fixedRotationFlag)==0){this.m_I-=this.m_mass*(a.x*a.x+a.y*a.y);this.m_I*=this.m_inertiaScale;A.b2Assert(this.m_I>
0);this.m_invI=1/this.m_I}else this.m_invI=this.m_I=0;c=this.m_sweep.c.Copy();this.m_sweep.localCenter.SetV(a);this.m_sweep.c0.SetV(F.MulX(this.m_xf,this.m_sweep.localCenter));this.m_sweep.c.SetV(this.m_sweep.c0);this.m_linearVelocity.x+=this.m_angularVelocity*-(this.m_sweep.c.y-c.y);this.m_linearVelocity.y+=this.m_angularVelocity*+(this.m_sweep.c.x-c.x)}};k.prototype.GetWorldPoint=function(a){var c=this.m_xf.R;a=new y(c.col1.x*a.x+c.col2.x*a.y,c.col1.y*a.x+c.col2.y*a.y);a.x+=this.m_xf.position.x;
a.y+=this.m_xf.position.y;return a};k.prototype.GetWorldVector=function(a){return F.MulMV(this.m_xf.R,a)};k.prototype.GetLocalPoint=function(a){return F.MulXT(this.m_xf,a)};k.prototype.GetLocalVector=function(a){return F.MulTMV(this.m_xf.R,a)};k.prototype.GetLinearVelocityFromWorldPoint=function(a){return new y(this.m_linearVelocity.x-this.m_angularVelocity*(a.y-this.m_sweep.c.y),this.m_linearVelocity.y+this.m_angularVelocity*(a.x-this.m_sweep.c.x))};k.prototype.GetLinearVelocityFromLocalPoint=function(a){var c=
this.m_xf.R;a=new y(c.col1.x*a.x+c.col2.x*a.y,c.col1.y*a.x+c.col2.y*a.y);a.x+=this.m_xf.position.x;a.y+=this.m_xf.position.y;return new y(this.m_linearVelocity.x-this.m_angularVelocity*(a.y-this.m_sweep.c.y),this.m_linearVelocity.y+this.m_angularVelocity*(a.x-this.m_sweep.c.x))};k.prototype.GetLinearDamping=function(){return this.m_linearDamping};k.prototype.SetLinearDamping=function(a){if(a===undefined)a=0;this.m_linearDamping=a};k.prototype.GetAngularDamping=function(){return this.m_angularDamping};
k.prototype.SetAngularDamping=function(a){if(a===undefined)a=0;this.m_angularDamping=a};k.prototype.SetType=function(a){if(a===undefined)a=0;if(this.m_type!=a){this.m_type=a;this.ResetMassData();if(this.m_type==k.b2_staticBody){this.m_linearVelocity.SetZero();this.m_angularVelocity=0}this.SetAwake(true);this.m_force.SetZero();this.m_torque=0;for(a=this.m_contactList;a;a=a.next)a.contact.FlagForFiltering()}};k.prototype.GetType=function(){return this.m_type};k.prototype.SetBullet=function(a){if(a)this.m_flags|=
k.e_bulletFlag;else this.m_flags&=~k.e_bulletFlag};k.prototype.IsBullet=function(){return(this.m_flags&k.e_bulletFlag)==k.e_bulletFlag};k.prototype.SetSleepingAllowed=function(a){if(a)this.m_flags|=k.e_allowSleepFlag;else{this.m_flags&=~k.e_allowSleepFlag;this.SetAwake(true)}};k.prototype.SetAwake=function(a){if(a){this.m_flags|=k.e_awakeFlag;this.m_sleepTime=0}else{this.m_flags&=~k.e_awakeFlag;this.m_sleepTime=0;this.m_linearVelocity.SetZero();this.m_angularVelocity=0;this.m_force.SetZero();this.m_torque=
0}};k.prototype.IsAwake=function(){return(this.m_flags&k.e_awakeFlag)==k.e_awakeFlag};k.prototype.SetFixedRotation=function(a){if(a)this.m_flags|=k.e_fixedRotationFlag;else this.m_flags&=~k.e_fixedRotationFlag;this.ResetMassData()};k.prototype.IsFixedRotation=function(){return(this.m_flags&k.e_fixedRotationFlag)==k.e_fixedRotationFlag};k.prototype.SetActive=function(a){if(a!=this.IsActive()){var c;if(a){this.m_flags|=k.e_activeFlag;a=this.m_world.m_contactManager.m_broadPhase;for(c=this.m_fixtureList;c;c=
c.m_next)c.CreateProxy(a,this.m_xf)}else{this.m_flags&=~k.e_activeFlag;a=this.m_world.m_contactManager.m_broadPhase;for(c=this.m_fixtureList;c;c=c.m_next)c.DestroyProxy(a);for(a=this.m_contactList;a;){c=a;a=a.next;this.m_world.m_contactManager.Destroy(c.contact)}this.m_contactList=null}}};k.prototype.IsActive=function(){return(this.m_flags&k.e_activeFlag)==k.e_activeFlag};k.prototype.IsSleepingAllowed=function(){return(this.m_flags&k.e_allowSleepFlag)==k.e_allowSleepFlag};k.prototype.GetFixtureList=
function(){return this.m_fixtureList};k.prototype.GetJointList=function(){return this.m_jointList};k.prototype.GetControllerList=function(){return this.m_controllerList};k.prototype.GetContactList=function(){return this.m_contactList};k.prototype.GetNext=function(){return this.m_next};k.prototype.GetUserData=function(){return this.m_userData};k.prototype.SetUserData=function(a){this.m_userData=a};k.prototype.GetWorld=function(){return this.m_world};k.prototype.b2Body=function(a,c){this.m_flags=0;
if(a.bullet)this.m_flags|=k.e_bulletFlag;if(a.fixedRotation)this.m_flags|=k.e_fixedRotationFlag;if(a.allowSleep)this.m_flags|=k.e_allowSleepFlag;if(a.awake)this.m_flags|=k.e_awakeFlag;if(a.active)this.m_flags|=k.e_activeFlag;this.m_world=c;this.m_xf.position.SetV(a.position);this.m_xf.R.Set(a.angle);this.m_sweep.localCenter.SetZero();this.m_sweep.t0=1;this.m_sweep.a0=this.m_sweep.a=a.angle;var g=this.m_xf.R,b=this.m_sweep.localCenter;this.m_sweep.c.x=g.col1.x*b.x+g.col2.x*b.y;this.m_sweep.c.y=g.col1.y*
b.x+g.col2.y*b.y;this.m_sweep.c.x+=this.m_xf.position.x;this.m_sweep.c.y+=this.m_xf.position.y;this.m_sweep.c0.SetV(this.m_sweep.c);this.m_contactList=this.m_controllerList=this.m_jointList=null;this.m_controllerCount=0;this.m_next=this.m_prev=null;this.m_linearVelocity.SetV(a.linearVelocity);this.m_angularVelocity=a.angularVelocity;this.m_linearDamping=a.linearDamping;this.m_angularDamping=a.angularDamping;this.m_force.Set(0,0);this.m_sleepTime=this.m_torque=0;this.m_type=a.type;if(this.m_type==
k.b2_dynamicBody)this.m_invMass=this.m_mass=1;else this.m_invMass=this.m_mass=0;this.m_invI=this.m_I=0;this.m_inertiaScale=a.inertiaScale;this.m_userData=a.userData;this.m_fixtureList=null;this.m_fixtureCount=0};k.prototype.SynchronizeFixtures=function(){var a=k.s_xf1;a.R.Set(this.m_sweep.a0);var c=a.R,g=this.m_sweep.localCenter;a.position.x=this.m_sweep.c0.x-(c.col1.x*g.x+c.col2.x*g.y);a.position.y=this.m_sweep.c0.y-(c.col1.y*g.x+c.col2.y*g.y);g=this.m_world.m_contactManager.m_broadPhase;for(c=this.m_fixtureList;c;c=
c.m_next)c.Synchronize(g,a,this.m_xf)};k.prototype.SynchronizeTransform=function(){this.m_xf.R.Set(this.m_sweep.a);var a=this.m_xf.R,c=this.m_sweep.localCenter;this.m_xf.position.x=this.m_sweep.c.x-(a.col1.x*c.x+a.col2.x*c.y);this.m_xf.position.y=this.m_sweep.c.y-(a.col1.y*c.x+a.col2.y*c.y)};k.prototype.ShouldCollide=function(a){if(this.m_type!=k.b2_dynamicBody&&a.m_type!=k.b2_dynamicBody)return false;for(var c=this.m_jointList;c;c=c.next)if(c.other==a)if(c.joint.m_collideConnected==false)return false;
return true};k.prototype.Advance=function(a){if(a===undefined)a=0;this.m_sweep.Advance(a);this.m_sweep.c.SetV(this.m_sweep.c0);this.m_sweep.a=this.m_sweep.a0;this.SynchronizeTransform()};Box2D.postDefs.push(function(){Box2D.Dynamics.b2Body.s_xf1=new K;Box2D.Dynamics.b2Body.e_islandFlag=1;Box2D.Dynamics.b2Body.e_awakeFlag=2;Box2D.Dynamics.b2Body.e_allowSleepFlag=4;Box2D.Dynamics.b2Body.e_bulletFlag=8;Box2D.Dynamics.b2Body.e_fixedRotationFlag=16;Box2D.Dynamics.b2Body.e_activeFlag=32;Box2D.Dynamics.b2Body.b2_staticBody=
0;Box2D.Dynamics.b2Body.b2_kinematicBody=1;Box2D.Dynamics.b2Body.b2_dynamicBody=2});z.b2BodyDef=function(){this.position=new y;this.linearVelocity=new y};z.prototype.b2BodyDef=function(){this.userData=null;this.position.Set(0,0);this.angle=0;this.linearVelocity.Set(0,0);this.angularDamping=this.linearDamping=this.angularVelocity=0;this.awake=this.allowSleep=true;this.bullet=this.fixedRotation=false;this.type=k.b2_staticBody;this.active=true;this.inertiaScale=1};u.b2ContactFilter=function(){};u.prototype.ShouldCollide=
function(a,c){var g=a.GetFilterData(),b=c.GetFilterData();if(g.groupIndex==b.groupIndex&&g.groupIndex!=0)return g.groupIndex>0;return(g.maskBits&b.categoryBits)!=0&&(g.categoryBits&b.maskBits)!=0};u.prototype.RayCollide=function(a,c){if(!a)return true;return this.ShouldCollide(a instanceof S?a:null,c)};Box2D.postDefs.push(function(){Box2D.Dynamics.b2ContactFilter.b2_defaultFilter=new u});D.b2ContactImpulse=function(){this.normalImpulses=new Vector_a2j_Number(A.b2_maxManifoldPoints);this.tangentImpulses=
new Vector_a2j_Number(A.b2_maxManifoldPoints)};H.b2ContactListener=function(){};H.prototype.BeginContact=function(){};H.prototype.EndContact=function(){};H.prototype.PreSolve=function(){};H.prototype.PostSolve=function(){};Box2D.postDefs.push(function(){Box2D.Dynamics.b2ContactListener.b2_defaultListener=new H});O.b2ContactManager=function(){};O.prototype.b2ContactManager=function(){this.m_world=null;this.m_contactCount=0;this.m_contactFilter=u.b2_defaultFilter;this.m_contactListener=H.b2_defaultListener;
this.m_contactFactory=new j(this.m_allocator);this.m_broadPhase=new B};O.prototype.AddPair=function(a,c){var g=a instanceof S?a:null,b=c instanceof S?c:null,e=g.GetBody(),f=b.GetBody();if(e!=f){for(var m=f.GetContactList();m;){if(m.other==e){var r=m.contact.GetFixtureA(),s=m.contact.GetFixtureB();if(r==g&&s==b)return;if(r==b&&s==g)return}m=m.next}if(f.ShouldCollide(e)!=false)if(this.m_contactFilter.ShouldCollide(g,b)!=false){m=this.m_contactFactory.Create(g,b);g=m.GetFixtureA();b=m.GetFixtureB();
e=g.m_body;f=b.m_body;m.m_prev=null;m.m_next=this.m_world.m_contactList;if(this.m_world.m_contactList!=null)this.m_world.m_contactList.m_prev=m;this.m_world.m_contactList=m;m.m_nodeA.contact=m;m.m_nodeA.other=f;m.m_nodeA.prev=null;m.m_nodeA.next=e.m_contactList;if(e.m_contactList!=null)e.m_contactList.prev=m.m_nodeA;e.m_contactList=m.m_nodeA;m.m_nodeB.contact=m;m.m_nodeB.other=e;m.m_nodeB.prev=null;m.m_nodeB.next=f.m_contactList;if(f.m_contactList!=null)f.m_contactList.prev=m.m_nodeB;f.m_contactList=
m.m_nodeB;++this.m_world.m_contactCount}}};O.prototype.FindNewContacts=function(){this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this,this.AddPair))};O.prototype.Destroy=function(a){var c=a.GetFixtureA(),g=a.GetFixtureB();c=c.GetBody();g=g.GetBody();a.IsTouching()&&this.m_contactListener.EndContact(a);if(a.m_prev)a.m_prev.m_next=a.m_next;if(a.m_next)a.m_next.m_prev=a.m_prev;if(a==this.m_world.m_contactList)this.m_world.m_contactList=a.m_next;if(a.m_nodeA.prev)a.m_nodeA.prev.next=a.m_nodeA.next;
if(a.m_nodeA.next)a.m_nodeA.next.prev=a.m_nodeA.prev;if(a.m_nodeA==c.m_contactList)c.m_contactList=a.m_nodeA.next;if(a.m_nodeB.prev)a.m_nodeB.prev.next=a.m_nodeB.next;if(a.m_nodeB.next)a.m_nodeB.next.prev=a.m_nodeB.prev;if(a.m_nodeB==g.m_contactList)g.m_contactList=a.m_nodeB.next;this.m_contactFactory.Destroy(a);--this.m_contactCount};O.prototype.Collide=function(){for(var a=this.m_world.m_contactList;a;){var c=a.GetFixtureA(),g=a.GetFixtureB(),b=c.GetBody(),e=g.GetBody();if(b.IsAwake()==false&&e.IsAwake()==
false)a=a.GetNext();else{if(a.m_flags&l.e_filterFlag){if(e.ShouldCollide(b)==false){c=a;a=c.GetNext();this.Destroy(c);continue}if(this.m_contactFilter.ShouldCollide(c,g)==false){c=a;a=c.GetNext();this.Destroy(c);continue}a.m_flags&=~l.e_filterFlag}if(this.m_broadPhase.TestOverlap(c.m_proxy,g.m_proxy)==false){c=a;a=c.GetNext();this.Destroy(c)}else{a.Update(this.m_contactListener);a=a.GetNext()}}}};Box2D.postDefs.push(function(){Box2D.Dynamics.b2ContactManager.s_evalCP=new p});E.b2DebugDraw=function(){};
E.prototype.b2DebugDraw=function(){};E.prototype.SetFlags=function(){};E.prototype.GetFlags=function(){};E.prototype.AppendFlags=function(){};E.prototype.ClearFlags=function(){};E.prototype.SetSprite=function(){};E.prototype.GetSprite=function(){};E.prototype.SetDrawScale=function(){};E.prototype.GetDrawScale=function(){};E.prototype.SetLineThickness=function(){};E.prototype.GetLineThickness=function(){};E.prototype.SetAlpha=function(){};E.prototype.GetAlpha=function(){};E.prototype.SetFillAlpha=
function(){};E.prototype.GetFillAlpha=function(){};E.prototype.SetXFormScale=function(){};E.prototype.GetXFormScale=function(){};E.prototype.DrawPolygon=function(){};E.prototype.DrawSolidPolygon=function(){};E.prototype.DrawCircle=function(){};E.prototype.DrawSolidCircle=function(){};E.prototype.DrawSegment=function(){};E.prototype.DrawTransform=function(){};Box2D.postDefs.push(function(){Box2D.Dynamics.b2DebugDraw.e_shapeBit=1;Box2D.Dynamics.b2DebugDraw.e_jointBit=2;Box2D.Dynamics.b2DebugDraw.e_aabbBit=
4;Box2D.Dynamics.b2DebugDraw.e_pairBit=8;Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit=16;Box2D.Dynamics.b2DebugDraw.e_controllerBit=32});R.b2DestructionListener=function(){};R.prototype.SayGoodbyeJoint=function(){};R.prototype.SayGoodbyeFixture=function(){};N.b2FilterData=function(){this.categoryBits=1;this.maskBits=65535;this.groupIndex=0};N.prototype.Copy=function(){var a=new N;a.categoryBits=this.categoryBits;a.maskBits=this.maskBits;a.groupIndex=this.groupIndex;return a};S.b2Fixture=function(){this.m_filter=
new N};S.prototype.GetType=function(){return this.m_shape.GetType()};S.prototype.GetShape=function(){return this.m_shape};S.prototype.SetSensor=function(a){if(this.m_isSensor!=a){this.m_isSensor=a;if(this.m_body!=null)for(a=this.m_body.GetContactList();a;){var c=a.contact,g=c.GetFixtureA(),b=c.GetFixtureB();if(g==this||b==this)c.SetSensor(g.IsSensor()||b.IsSensor());a=a.next}}};S.prototype.IsSensor=function(){return this.m_isSensor};S.prototype.SetFilterData=function(a){this.m_filter=a.Copy();if(!this.m_body)for(a=
this.m_body.GetContactList();a;){var c=a.contact,g=c.GetFixtureA(),b=c.GetFixtureB();if(g==this||b==this)c.FlagForFiltering();a=a.next}};S.prototype.GetFilterData=function(){return this.m_filter.Copy()};S.prototype.GetBody=function(){return this.m_body};S.prototype.GetNext=function(){return this.m_next};S.prototype.GetUserData=function(){return this.m_userData};S.prototype.SetUserData=function(a){this.m_userData=a};S.prototype.TestPoint=function(a){return this.m_shape.TestPoint(this.m_body.GetTransform(),
a)};S.prototype.RayCast=function(a,c){return this.m_shape.RayCast(a,c,this.m_body.GetTransform())};S.prototype.GetMassData=function(a){if(a===undefined)a=null;if(a==null)a=new I;this.m_shape.ComputeMass(a,this.m_density);return a};S.prototype.SetDensity=function(a){if(a===undefined)a=0;this.m_density=a};S.prototype.GetDensity=function(){return this.m_density};S.prototype.GetFriction=function(){return this.m_friction};S.prototype.SetFriction=function(a){if(a===undefined)a=0;this.m_friction=a};S.prototype.GetRestitution=
function(){return this.m_restitution};S.prototype.SetRestitution=function(a){if(a===undefined)a=0;this.m_restitution=a};S.prototype.GetAABB=function(){return this.m_aabb};S.prototype.b2Fixture=function(){this.m_aabb=new U;this.m_shape=this.m_next=this.m_body=this.m_userData=null;this.m_restitution=this.m_friction=this.m_density=0};S.prototype.Create=function(a,c,g){this.m_userData=g.userData;this.m_friction=g.friction;this.m_restitution=g.restitution;this.m_body=a;this.m_next=null;this.m_filter=g.filter.Copy();
this.m_isSensor=g.isSensor;this.m_shape=g.shape.Copy();this.m_density=g.density};S.prototype.Destroy=function(){this.m_shape=null};S.prototype.CreateProxy=function(a,c){this.m_shape.ComputeAABB(this.m_aabb,c);this.m_proxy=a.CreateProxy(this.m_aabb,this)};S.prototype.DestroyProxy=function(a){if(this.m_proxy!=null){a.DestroyProxy(this.m_proxy);this.m_proxy=null}};S.prototype.Synchronize=function(a,c,g){if(this.m_proxy){var b=new U,e=new U;this.m_shape.ComputeAABB(b,c);this.m_shape.ComputeAABB(e,g);
this.m_aabb.Combine(b,e);c=F.SubtractVV(g.position,c.position);a.MoveProxy(this.m_proxy,this.m_aabb,c)}};aa.b2FixtureDef=function(){this.filter=new N};aa.prototype.b2FixtureDef=function(){this.userData=this.shape=null;this.friction=0.2;this.density=this.restitution=0;this.filter.categoryBits=1;this.filter.maskBits=65535;this.filter.groupIndex=0;this.isSensor=false};Z.b2Island=function(){};Z.prototype.b2Island=function(){this.m_bodies=new Vector;this.m_contacts=new Vector;this.m_joints=new Vector};
Z.prototype.Initialize=function(a,c,g,b,e,f){if(a===undefined)a=0;if(c===undefined)c=0;if(g===undefined)g=0;var m=0;this.m_bodyCapacity=a;this.m_contactCapacity=c;this.m_jointCapacity=g;this.m_jointCount=this.m_contactCount=this.m_bodyCount=0;this.m_allocator=b;this.m_listener=e;this.m_contactSolver=f;for(m=this.m_bodies.length;m<a;m++)this.m_bodies[m]=null;for(m=this.m_contacts.length;m<c;m++)this.m_contacts[m]=null;for(m=this.m_joints.length;m<g;m++)this.m_joints[m]=null};Z.prototype.Clear=function(){this.m_jointCount=
this.m_contactCount=this.m_bodyCount=0};Z.prototype.Solve=function(a,c,g){var b=0,e=0,f;for(b=0;b<this.m_bodyCount;++b){e=this.m_bodies[b];if(e.GetType()==k.b2_dynamicBody){e.m_linearVelocity.x+=a.dt*(c.x+e.m_invMass*e.m_force.x);e.m_linearVelocity.y+=a.dt*(c.y+e.m_invMass*e.m_force.y);e.m_angularVelocity+=a.dt*e.m_invI*e.m_torque;e.m_linearVelocity.Multiply(F.Clamp(1-a.dt*e.m_linearDamping,0,1));e.m_angularVelocity*=F.Clamp(1-a.dt*e.m_angularDamping,0,1)}}this.m_contactSolver.Initialize(a,this.m_contacts,
this.m_contactCount,this.m_allocator);c=this.m_contactSolver;c.InitVelocityConstraints(a);for(b=0;b<this.m_jointCount;++b){f=this.m_joints[b];f.InitVelocityConstraints(a)}for(b=0;b<a.velocityIterations;++b){for(e=0;e<this.m_jointCount;++e){f=this.m_joints[e];f.SolveVelocityConstraints(a)}c.SolveVelocityConstraints()}for(b=0;b<this.m_jointCount;++b){f=this.m_joints[b];f.FinalizeVelocityConstraints()}c.FinalizeVelocityConstraints();for(b=0;b<this.m_bodyCount;++b){e=this.m_bodies[b];if(e.GetType()!=
k.b2_staticBody){var m=a.dt*e.m_linearVelocity.x,r=a.dt*e.m_linearVelocity.y;if(m*m+r*r>A.b2_maxTranslationSquared){e.m_linearVelocity.Normalize();e.m_linearVelocity.x*=A.b2_maxTranslation*a.inv_dt;e.m_linearVelocity.y*=A.b2_maxTranslation*a.inv_dt}m=a.dt*e.m_angularVelocity;if(m*m>A.b2_maxRotationSquared)e.m_angularVelocity=e.m_angularVelocity<0?-A.b2_maxRotation*a.inv_dt:A.b2_maxRotation*a.inv_dt;e.m_sweep.c0.SetV(e.m_sweep.c);e.m_sweep.a0=e.m_sweep.a;e.m_sweep.c.x+=a.dt*e.m_linearVelocity.x;e.m_sweep.c.y+=
a.dt*e.m_linearVelocity.y;e.m_sweep.a+=a.dt*e.m_angularVelocity;e.SynchronizeTransform()}}for(b=0;b<a.positionIterations;++b){m=c.SolvePositionConstraints(A.b2_contactBaumgarte);r=true;for(e=0;e<this.m_jointCount;++e){f=this.m_joints[e];f=f.SolvePositionConstraints(A.b2_contactBaumgarte);r=r&&f}if(m&&r)break}this.Report(c.m_constraints);if(g){g=Number.MAX_VALUE;c=A.b2_linearSleepTolerance*A.b2_linearSleepTolerance;m=A.b2_angularSleepTolerance*A.b2_angularSleepTolerance;for(b=0;b<this.m_bodyCount;++b){e=
this.m_bodies[b];if(e.GetType()!=k.b2_staticBody){if((e.m_flags&k.e_allowSleepFlag)==0)g=e.m_sleepTime=0;if((e.m_flags&k.e_allowSleepFlag)==0||e.m_angularVelocity*e.m_angularVelocity>m||F.Dot(e.m_linearVelocity,e.m_linearVelocity)>c)g=e.m_sleepTime=0;else{e.m_sleepTime+=a.dt;g=F.Min(g,e.m_sleepTime)}}}if(g>=A.b2_timeToSleep)for(b=0;b<this.m_bodyCount;++b){e=this.m_bodies[b];e.SetAwake(false)}}};Z.prototype.SolveTOI=function(a){var c=0,g=0;this.m_contactSolver.Initialize(a,this.m_contacts,this.m_contactCount,
this.m_allocator);var b=this.m_contactSolver;for(c=0;c<this.m_jointCount;++c)this.m_joints[c].InitVelocityConstraints(a);for(c=0;c<a.velocityIterations;++c){b.SolveVelocityConstraints();for(g=0;g<this.m_jointCount;++g)this.m_joints[g].SolveVelocityConstraints(a)}for(c=0;c<this.m_bodyCount;++c){g=this.m_bodies[c];if(g.GetType()!=k.b2_staticBody){var e=a.dt*g.m_linearVelocity.x,f=a.dt*g.m_linearVelocity.y;if(e*e+f*f>A.b2_maxTranslationSquared){g.m_linearVelocity.Normalize();g.m_linearVelocity.x*=A.b2_maxTranslation*
a.inv_dt;g.m_linearVelocity.y*=A.b2_maxTranslation*a.inv_dt}e=a.dt*g.m_angularVelocity;if(e*e>A.b2_maxRotationSquared)g.m_angularVelocity=g.m_angularVelocity<0?-A.b2_maxRotation*a.inv_dt:A.b2_maxRotation*a.inv_dt;g.m_sweep.c0.SetV(g.m_sweep.c);g.m_sweep.a0=g.m_sweep.a;g.m_sweep.c.x+=a.dt*g.m_linearVelocity.x;g.m_sweep.c.y+=a.dt*g.m_linearVelocity.y;g.m_sweep.a+=a.dt*g.m_angularVelocity;g.SynchronizeTransform()}}for(c=0;c<a.positionIterations;++c){e=b.SolvePositionConstraints(0.75);f=true;for(g=0;g<
this.m_jointCount;++g){var m=this.m_joints[g].SolvePositionConstraints(A.b2_contactBaumgarte);f=f&&m}if(e&&f)break}this.Report(b.m_constraints)};Z.prototype.Report=function(a){if(this.m_listener!=null)for(var c=0;c<this.m_contactCount;++c){for(var g=this.m_contacts[c],b=a[c],e=0;e<b.pointCount;++e){Z.s_impulse.normalImpulses[e]=b.points[e].normalImpulse;Z.s_impulse.tangentImpulses[e]=b.points[e].tangentImpulse}this.m_listener.PostSolve(g,Z.s_impulse)}};Z.prototype.AddBody=function(a){a.m_islandIndex=
this.m_bodyCount;this.m_bodies[this.m_bodyCount++]=a};Z.prototype.AddContact=function(a){this.m_contacts[this.m_contactCount++]=a};Z.prototype.AddJoint=function(a){this.m_joints[this.m_jointCount++]=a};Box2D.postDefs.push(function(){Box2D.Dynamics.b2Island.s_impulse=new D});d.b2TimeStep=function(){};d.prototype.Set=function(a){this.dt=a.dt;this.inv_dt=a.inv_dt;this.positionIterations=a.positionIterations;this.velocityIterations=a.velocityIterations;this.warmStarting=a.warmStarting};h.b2World=function(){this.s_stack=
new Vector;this.m_contactManager=new O;this.m_contactSolver=new o;this.m_island=new Z};h.prototype.b2World=function(a,c){this.m_controllerList=this.m_jointList=this.m_contactList=this.m_bodyList=this.m_debugDraw=this.m_destructionListener=null;this.m_controllerCount=this.m_jointCount=this.m_contactCount=this.m_bodyCount=0;h.m_warmStarting=true;h.m_continuousPhysics=true;this.m_allowSleep=c;this.m_gravity=a;this.m_inv_dt0=0;this.m_contactManager.m_world=this;this.m_groundBody=this.CreateBody(new z)};
h.prototype.SetDestructionListener=function(a){this.m_destructionListener=a};h.prototype.SetContactFilter=function(a){this.m_contactManager.m_contactFilter=a};h.prototype.SetContactListener=function(a){this.m_contactManager.m_contactListener=a};h.prototype.SetDebugDraw=function(a){this.m_debugDraw=a};h.prototype.SetBroadPhase=function(a){var c=this.m_contactManager.m_broadPhase;this.m_contactManager.m_broadPhase=a;for(var g=this.m_bodyList;g;g=g.m_next)for(var b=g.m_fixtureList;b;b=b.m_next)b.m_proxy=
a.CreateProxy(c.GetFatAABB(b.m_proxy),b)};h.prototype.Validate=function(){this.m_contactManager.m_broadPhase.Validate()};h.prototype.GetProxyCount=function(){return this.m_contactManager.m_broadPhase.GetProxyCount()};h.prototype.CreateBody=function(a){if(this.IsLocked()==true)return null;a=new k(a,this);a.m_prev=null;if(a.m_next=this.m_bodyList)this.m_bodyList.m_prev=a;this.m_bodyList=a;++this.m_bodyCount;return a};h.prototype.DestroyBody=function(a){if(this.IsLocked()!=true){for(var c=a.m_jointList;c;){var g=
c;c=c.next;this.m_destructionListener&&this.m_destructionListener.SayGoodbyeJoint(g.joint);this.DestroyJoint(g.joint)}for(c=a.m_controllerList;c;){g=c;c=c.nextController;g.controller.RemoveBody(a)}for(c=a.m_contactList;c;){g=c;c=c.next;this.m_contactManager.Destroy(g.contact)}a.m_contactList=null;for(c=a.m_fixtureList;c;){g=c;c=c.m_next;this.m_destructionListener&&this.m_destructionListener.SayGoodbyeFixture(g);g.DestroyProxy(this.m_contactManager.m_broadPhase);g.Destroy()}a.m_fixtureList=null;a.m_fixtureCount=
0;if(a.m_prev)a.m_prev.m_next=a.m_next;if(a.m_next)a.m_next.m_prev=a.m_prev;if(a==this.m_bodyList)this.m_bodyList=a.m_next;--this.m_bodyCount}};h.prototype.CreateJoint=function(a){var c=q.Create(a,null);c.m_prev=null;if(c.m_next=this.m_jointList)this.m_jointList.m_prev=c;this.m_jointList=c;++this.m_jointCount;c.m_edgeA.joint=c;c.m_edgeA.other=c.m_bodyB;c.m_edgeA.prev=null;if(c.m_edgeA.next=c.m_bodyA.m_jointList)c.m_bodyA.m_jointList.prev=c.m_edgeA;c.m_bodyA.m_jointList=c.m_edgeA;c.m_edgeB.joint=c;
c.m_edgeB.other=c.m_bodyA;c.m_edgeB.prev=null;if(c.m_edgeB.next=c.m_bodyB.m_jointList)c.m_bodyB.m_jointList.prev=c.m_edgeB;c.m_bodyB.m_jointList=c.m_edgeB;var g=a.bodyA,b=a.bodyB;if(a.collideConnected==false)for(a=b.GetContactList();a;){a.other==g&&a.contact.FlagForFiltering();a=a.next}return c};h.prototype.DestroyJoint=function(a){var c=a.m_collideConnected;if(a.m_prev)a.m_prev.m_next=a.m_next;if(a.m_next)a.m_next.m_prev=a.m_prev;if(a==this.m_jointList)this.m_jointList=a.m_next;var g=a.m_bodyA,b=
a.m_bodyB;g.SetAwake(true);b.SetAwake(true);if(a.m_edgeA.prev)a.m_edgeA.prev.next=a.m_edgeA.next;if(a.m_edgeA.next)a.m_edgeA.next.prev=a.m_edgeA.prev;if(a.m_edgeA==g.m_jointList)g.m_jointList=a.m_edgeA.next;a.m_edgeA.prev=null;a.m_edgeA.next=null;if(a.m_edgeB.prev)a.m_edgeB.prev.next=a.m_edgeB.next;if(a.m_edgeB.next)a.m_edgeB.next.prev=a.m_edgeB.prev;if(a.m_edgeB==b.m_jointList)b.m_jointList=a.m_edgeB.next;a.m_edgeB.prev=null;a.m_edgeB.next=null;q.Destroy(a,null);--this.m_jointCount;if(c==false)for(a=
b.GetContactList();a;){a.other==g&&a.contact.FlagForFiltering();a=a.next}};h.prototype.AddController=function(a){a.m_next=this.m_controllerList;a.m_prev=null;this.m_controllerList=a;a.m_world=this;this.m_controllerCount++;return a};h.prototype.RemoveController=function(a){if(a.m_prev)a.m_prev.m_next=a.m_next;if(a.m_next)a.m_next.m_prev=a.m_prev;if(this.m_controllerList==a)this.m_controllerList=a.m_next;this.m_controllerCount--};h.prototype.CreateController=function(a){if(a.m_world!=this)throw Error("Controller can only be a member of one world");
a.m_next=this.m_controllerList;a.m_prev=null;if(this.m_controllerList)this.m_controllerList.m_prev=a;this.m_controllerList=a;++this.m_controllerCount;a.m_world=this;return a};h.prototype.DestroyController=function(a){a.Clear();if(a.m_next)a.m_next.m_prev=a.m_prev;if(a.m_prev)a.m_prev.m_next=a.m_next;if(a==this.m_controllerList)this.m_controllerList=a.m_next;--this.m_controllerCount};h.prototype.SetWarmStarting=function(a){h.m_warmStarting=a};h.prototype.SetContinuousPhysics=function(a){h.m_continuousPhysics=
a};h.prototype.GetBodyCount=function(){return this.m_bodyCount};h.prototype.GetJointCount=function(){return this.m_jointCount};h.prototype.GetContactCount=function(){return this.m_contactCount};h.prototype.SetGravity=function(a){this.m_gravity=a};h.prototype.GetGravity=function(){return this.m_gravity};h.prototype.GetGroundBody=function(){return this.m_groundBody};h.prototype.Step=function(a,c,g){if(a===undefined)a=0;if(c===undefined)c=0;if(g===undefined)g=0;if(this.m_flags&h.e_newFixture){this.m_contactManager.FindNewContacts();
this.m_flags&=~h.e_newFixture}this.m_flags|=h.e_locked;var b=h.s_timestep2;b.dt=a;b.velocityIterations=c;b.positionIterations=g;b.inv_dt=a>0?1/a:0;b.dtRatio=this.m_inv_dt0*a;b.warmStarting=h.m_warmStarting;this.m_contactManager.Collide();b.dt>0&&this.Solve(b);h.m_continuousPhysics&&b.dt>0&&this.SolveTOI(b);if(b.dt>0)this.m_inv_dt0=b.inv_dt;this.m_flags&=~h.e_locked};h.prototype.ClearForces=function(){for(var a=this.m_bodyList;a;a=a.m_next){a.m_force.SetZero();a.m_torque=0}};h.prototype.DrawDebugData=
function(){if(this.m_debugDraw!=null){this.m_debugDraw.m_sprite.graphics.clear();var a=this.m_debugDraw.GetFlags(),c,g,b;new y;new y;new y;var e;new U;new U;e=[new y,new y,new y,new y];var f=new w(0,0,0);if(a&E.e_shapeBit)for(c=this.m_bodyList;c;c=c.m_next){e=c.m_xf;for(g=c.GetFixtureList();g;g=g.m_next){b=g.GetShape();if(c.IsActive()==false)f.Set(0.5,0.5,0.3);else if(c.GetType()==k.b2_staticBody)f.Set(0.5,0.9,0.5);else if(c.GetType()==k.b2_kinematicBody)f.Set(0.5,0.5,0.9);else c.IsAwake()==false?
f.Set(0.6,0.6,0.6):f.Set(0.9,0.7,0.7);this.DrawShape(b,e,f)}}if(a&E.e_jointBit)for(c=this.m_jointList;c;c=c.m_next)this.DrawJoint(c);if(a&E.e_controllerBit)for(c=this.m_controllerList;c;c=c.m_next)c.Draw(this.m_debugDraw);if(a&E.e_pairBit){f.Set(0.3,0.9,0.9);for(c=this.m_contactManager.m_contactList;c;c=c.GetNext()){b=c.GetFixtureA();g=c.GetFixtureB();b=b.GetAABB().GetCenter();g=g.GetAABB().GetCenter();this.m_debugDraw.DrawSegment(b,g,f)}}if(a&E.e_aabbBit){b=this.m_contactManager.m_broadPhase;e=[new y,
new y,new y,new y];for(c=this.m_bodyList;c;c=c.GetNext())if(c.IsActive()!=false)for(g=c.GetFixtureList();g;g=g.GetNext()){var m=b.GetFatAABB(g.m_proxy);e[0].Set(m.lowerBound.x,m.lowerBound.y);e[1].Set(m.upperBound.x,m.lowerBound.y);e[2].Set(m.upperBound.x,m.upperBound.y);e[3].Set(m.lowerBound.x,m.upperBound.y);this.m_debugDraw.DrawPolygon(e,4,f)}}if(a&E.e_centerOfMassBit)for(c=this.m_bodyList;c;c=c.m_next){e=h.s_xf;e.R=c.m_xf.R;e.position=c.GetWorldCenter();this.m_debugDraw.DrawTransform(e)}}};h.prototype.QueryAABB=
function(a,c){var g=this.m_contactManager.m_broadPhase;g.Query(function(b){return a(g.GetUserData(b))},c)};h.prototype.QueryShape=function(a,c,g){if(g===undefined)g=null;if(g==null){g=new K;g.SetIdentity()}var b=this.m_contactManager.m_broadPhase,e=new U;c.ComputeAABB(e,g);b.Query(function(f){f=b.GetUserData(f)instanceof S?b.GetUserData(f):null;if(Y.TestOverlap(c,g,f.GetShape(),f.GetBody().GetTransform()))return a(f);return true},e)};h.prototype.QueryPoint=function(a,c){var g=this.m_contactManager.m_broadPhase,
b=new U;b.lowerBound.Set(c.x-A.b2_linearSlop,c.y-A.b2_linearSlop);b.upperBound.Set(c.x+A.b2_linearSlop,c.y+A.b2_linearSlop);g.Query(function(e){e=g.GetUserData(e)instanceof S?g.GetUserData(e):null;if(e.TestPoint(c))return a(e);return true},b)};h.prototype.RayCast=function(a,c,g){var b=this.m_contactManager.m_broadPhase,e=new V,f=new Q(c,g);b.RayCast(function(m,r){var s=b.GetUserData(r);s=s instanceof S?s:null;if(s.RayCast(e,m)){var v=e.fraction,t=new y((1-v)*c.x+v*g.x,(1-v)*c.y+v*g.y);return a(s,
t,e.normal,v)}return m.maxFraction},f)};h.prototype.RayCastOne=function(a,c){var g;this.RayCast(function(b,e,f,m){if(m===undefined)m=0;g=b;return m},a,c);return g};h.prototype.RayCastAll=function(a,c){var g=new Vector;this.RayCast(function(b){g[g.length]=b;return 1},a,c);return g};h.prototype.GetBodyList=function(){return this.m_bodyList};h.prototype.GetJointList=function(){return this.m_jointList};h.prototype.GetContactList=function(){return this.m_contactList};h.prototype.IsLocked=function(){return(this.m_flags&
h.e_locked)>0};h.prototype.Solve=function(a){for(var c,g=this.m_controllerList;g;g=g.m_next)g.Step(a);g=this.m_island;g.Initialize(this.m_bodyCount,this.m_contactCount,this.m_jointCount,null,this.m_contactManager.m_contactListener,this.m_contactSolver);for(c=this.m_bodyList;c;c=c.m_next)c.m_flags&=~k.e_islandFlag;for(var b=this.m_contactList;b;b=b.m_next)b.m_flags&=~l.e_islandFlag;for(b=this.m_jointList;b;b=b.m_next)b.m_islandFlag=false;parseInt(this.m_bodyCount);b=this.s_stack;for(var e=this.m_bodyList;e;e=
e.m_next)if(!(e.m_flags&k.e_islandFlag))if(!(e.IsAwake()==false||e.IsActive()==false))if(e.GetType()!=k.b2_staticBody){g.Clear();var f=0;b[f++]=e;for(e.m_flags|=k.e_islandFlag;f>0;){c=b[--f];g.AddBody(c);c.IsAwake()==false&&c.SetAwake(true);if(c.GetType()!=k.b2_staticBody){for(var m,r=c.m_contactList;r;r=r.next)if(!(r.contact.m_flags&l.e_islandFlag))if(!(r.contact.IsSensor()==true||r.contact.IsEnabled()==false||r.contact.IsTouching()==false)){g.AddContact(r.contact);r.contact.m_flags|=l.e_islandFlag;
m=r.other;if(!(m.m_flags&k.e_islandFlag)){b[f++]=m;m.m_flags|=k.e_islandFlag}}for(c=c.m_jointList;c;c=c.next)if(c.joint.m_islandFlag!=true){m=c.other;if(m.IsActive()!=false){g.AddJoint(c.joint);c.joint.m_islandFlag=true;if(!(m.m_flags&k.e_islandFlag)){b[f++]=m;m.m_flags|=k.e_islandFlag}}}}}g.Solve(a,this.m_gravity,this.m_allowSleep);for(f=0;f<g.m_bodyCount;++f){c=g.m_bodies[f];if(c.GetType()==k.b2_staticBody)c.m_flags&=~k.e_islandFlag}}for(f=0;f<b.length;++f){if(!b[f])break;b[f]=null}for(c=this.m_bodyList;c;c=
c.m_next)c.IsAwake()==false||c.IsActive()==false||c.GetType()!=k.b2_staticBody&&c.SynchronizeFixtures();this.m_contactManager.FindNewContacts()};h.prototype.SolveTOI=function(a){var c,g,b,e=this.m_island;e.Initialize(this.m_bodyCount,A.b2_maxTOIContactsPerIsland,A.b2_maxTOIJointsPerIsland,null,this.m_contactManager.m_contactListener,this.m_contactSolver);var f=h.s_queue;for(c=this.m_bodyList;c;c=c.m_next){c.m_flags&=~k.e_islandFlag;c.m_sweep.t0=0}for(b=this.m_contactList;b;b=b.m_next)b.m_flags&=~(l.e_toiFlag|
l.e_islandFlag);for(b=this.m_jointList;b;b=b.m_next)b.m_islandFlag=false;for(;;){var m=null,r=1;for(b=this.m_contactList;b;b=b.m_next)if(!(b.IsSensor()==true||b.IsEnabled()==false||b.IsContinuous()==false)){c=1;if(b.m_flags&l.e_toiFlag)c=b.m_toi;else{c=b.m_fixtureA;g=b.m_fixtureB;c=c.m_body;g=g.m_body;if((c.GetType()!=k.b2_dynamicBody||c.IsAwake()==false)&&(g.GetType()!=k.b2_dynamicBody||g.IsAwake()==false))continue;var s=c.m_sweep.t0;if(c.m_sweep.t0<g.m_sweep.t0){s=g.m_sweep.t0;c.m_sweep.Advance(s)}else if(g.m_sweep.t0<
c.m_sweep.t0){s=c.m_sweep.t0;g.m_sweep.Advance(s)}c=b.ComputeTOI(c.m_sweep,g.m_sweep);A.b2Assert(0<=c&&c<=1);if(c>0&&c<1){c=(1-c)*s+c;if(c>1)c=1}b.m_toi=c;b.m_flags|=l.e_toiFlag}if(Number.MIN_VALUE<c&&c<r){m=b;r=c}}if(m==null||1-100*Number.MIN_VALUE<r)break;c=m.m_fixtureA;g=m.m_fixtureB;c=c.m_body;g=g.m_body;h.s_backupA.Set(c.m_sweep);h.s_backupB.Set(g.m_sweep);c.Advance(r);g.Advance(r);m.Update(this.m_contactManager.m_contactListener);m.m_flags&=~l.e_toiFlag;if(m.IsSensor()==true||m.IsEnabled()==
false){c.m_sweep.Set(h.s_backupA);g.m_sweep.Set(h.s_backupB);c.SynchronizeTransform();g.SynchronizeTransform()}else if(m.IsTouching()!=false){c=c;if(c.GetType()!=k.b2_dynamicBody)c=g;e.Clear();m=b=0;f[b+m++]=c;for(c.m_flags|=k.e_islandFlag;m>0;){c=f[b++];--m;e.AddBody(c);c.IsAwake()==false&&c.SetAwake(true);if(c.GetType()==k.b2_dynamicBody){for(g=c.m_contactList;g;g=g.next){if(e.m_contactCount==e.m_contactCapacity)break;if(!(g.contact.m_flags&l.e_islandFlag))if(!(g.contact.IsSensor()==true||g.contact.IsEnabled()==
false||g.contact.IsTouching()==false)){e.AddContact(g.contact);g.contact.m_flags|=l.e_islandFlag;s=g.other;if(!(s.m_flags&k.e_islandFlag)){if(s.GetType()!=k.b2_staticBody){s.Advance(r);s.SetAwake(true)}f[b+m]=s;++m;s.m_flags|=k.e_islandFlag}}}for(c=c.m_jointList;c;c=c.next)if(e.m_jointCount!=e.m_jointCapacity)if(c.joint.m_islandFlag!=true){s=c.other;if(s.IsActive()!=false){e.AddJoint(c.joint);c.joint.m_islandFlag=true;if(!(s.m_flags&k.e_islandFlag)){if(s.GetType()!=k.b2_staticBody){s.Advance(r);s.SetAwake(true)}f[b+
m]=s;++m;s.m_flags|=k.e_islandFlag}}}}}b=h.s_timestep;b.warmStarting=false;b.dt=(1-r)*a.dt;b.inv_dt=1/b.dt;b.dtRatio=0;b.velocityIterations=a.velocityIterations;b.positionIterations=a.positionIterations;e.SolveTOI(b);for(r=r=0;r<e.m_bodyCount;++r){c=e.m_bodies[r];c.m_flags&=~k.e_islandFlag;if(c.IsAwake()!=false)if(c.GetType()==k.b2_dynamicBody){c.SynchronizeFixtures();for(g=c.m_contactList;g;g=g.next)g.contact.m_flags&=~l.e_toiFlag}}for(r=0;r<e.m_contactCount;++r){b=e.m_contacts[r];b.m_flags&=~(l.e_toiFlag|
l.e_islandFlag)}for(r=0;r<e.m_jointCount;++r){b=e.m_joints[r];b.m_islandFlag=false}this.m_contactManager.FindNewContacts()}}};h.prototype.DrawJoint=function(a){var c=a.GetBodyA(),g=a.GetBodyB(),b=c.m_xf.position,e=g.m_xf.position,f=a.GetAnchorA(),m=a.GetAnchorB(),r=h.s_jointColor;switch(a.m_type){case q.e_distanceJoint:this.m_debugDraw.DrawSegment(f,m,r);break;case q.e_pulleyJoint:c=a instanceof n?a:null;a=c.GetGroundAnchorA();c=c.GetGroundAnchorB();this.m_debugDraw.DrawSegment(a,f,r);this.m_debugDraw.DrawSegment(c,
m,r);this.m_debugDraw.DrawSegment(a,c,r);break;case q.e_mouseJoint:this.m_debugDraw.DrawSegment(f,m,r);break;default:c!=this.m_groundBody&&this.m_debugDraw.DrawSegment(b,f,r);this.m_debugDraw.DrawSegment(f,m,r);g!=this.m_groundBody&&this.m_debugDraw.DrawSegment(e,m,r)}};h.prototype.DrawShape=function(a,c,g){switch(a.m_type){case Y.e_circleShape:var b=a instanceof M?a:null;this.m_debugDraw.DrawSolidCircle(F.MulX(c,b.m_p),b.m_radius,c.R.col1,g);break;case Y.e_polygonShape:b=0;b=a instanceof W?a:null;
a=parseInt(b.GetVertexCount());var e=b.GetVertices(),f=new Vector(a);for(b=0;b<a;++b)f[b]=F.MulX(c,e[b]);this.m_debugDraw.DrawSolidPolygon(f,a,g);break;case Y.e_edgeShape:b=a instanceof L?a:null;this.m_debugDraw.DrawSegment(F.MulX(c,b.GetVertex1()),F.MulX(c,b.GetVertex2()),g)}};Box2D.postDefs.push(function(){Box2D.Dynamics.b2World.s_timestep2=new d;Box2D.Dynamics.b2World.s_xf=new K;Box2D.Dynamics.b2World.s_backupA=new G;Box2D.Dynamics.b2World.s_backupB=new G;Box2D.Dynamics.b2World.s_timestep=new d;
Box2D.Dynamics.b2World.s_queue=new Vector;Box2D.Dynamics.b2World.s_jointColor=new w(0.5,0.8,0.8);Box2D.Dynamics.b2World.e_newFixture=1;Box2D.Dynamics.b2World.e_locked=2})})();
(function(){var F=Box2D.Collision.Shapes.b2CircleShape,G=Box2D.Collision.Shapes.b2EdgeShape,K=Box2D.Collision.Shapes.b2PolygonShape,y=Box2D.Collision.Shapes.b2Shape,w=Box2D.Dynamics.Contacts.b2CircleContact,A=Box2D.Dynamics.Contacts.b2Contact,U=Box2D.Dynamics.Contacts.b2ContactConstraint,p=Box2D.Dynamics.Contacts.b2ContactConstraintPoint,B=Box2D.Dynamics.Contacts.b2ContactEdge,Q=Box2D.Dynamics.Contacts.b2ContactFactory,V=Box2D.Dynamics.Contacts.b2ContactRegister,M=Box2D.Dynamics.Contacts.b2ContactResult,
L=Box2D.Dynamics.Contacts.b2ContactSolver,I=Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,W=Box2D.Dynamics.Contacts.b2NullContact,Y=Box2D.Dynamics.Contacts.b2PolyAndCircleContact,k=Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,z=Box2D.Dynamics.Contacts.b2PolygonContact,u=Box2D.Dynamics.Contacts.b2PositionSolverManifold,D=Box2D.Dynamics.b2Body,H=Box2D.Dynamics.b2TimeStep,O=Box2D.Common.b2Settings,E=Box2D.Common.Math.b2Mat22,R=Box2D.Common.Math.b2Math,N=Box2D.Common.Math.b2Vec2,S=Box2D.Collision.b2Collision,
aa=Box2D.Collision.b2ContactID,Z=Box2D.Collision.b2Manifold,d=Box2D.Collision.b2TimeOfImpact,h=Box2D.Collision.b2TOIInput,l=Box2D.Collision.b2WorldManifold;Box2D.inherit(w,Box2D.Dynamics.Contacts.b2Contact);w.prototype.__super=Box2D.Dynamics.Contacts.b2Contact.prototype;w.b2CircleContact=function(){Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,arguments)};w.Create=function(){return new w};w.Destroy=function(){};w.prototype.Reset=function(j,o){this.__super.Reset.call(this,j,o)};w.prototype.Evaluate=
function(){var j=this.m_fixtureA.GetBody(),o=this.m_fixtureB.GetBody();S.CollideCircles(this.m_manifold,this.m_fixtureA.GetShape()instanceof F?this.m_fixtureA.GetShape():null,j.m_xf,this.m_fixtureB.GetShape()instanceof F?this.m_fixtureB.GetShape():null,o.m_xf)};A.b2Contact=function(){this.m_nodeA=new B;this.m_nodeB=new B;this.m_manifold=new Z;this.m_oldManifold=new Z};A.prototype.GetManifold=function(){return this.m_manifold};A.prototype.GetWorldManifold=function(j){var o=this.m_fixtureA.GetBody(),
q=this.m_fixtureB.GetBody(),n=this.m_fixtureA.GetShape(),a=this.m_fixtureB.GetShape();j.Initialize(this.m_manifold,o.GetTransform(),n.m_radius,q.GetTransform(),a.m_radius)};A.prototype.IsTouching=function(){return(this.m_flags&A.e_touchingFlag)==A.e_touchingFlag};A.prototype.IsContinuous=function(){return(this.m_flags&A.e_continuousFlag)==A.e_continuousFlag};A.prototype.SetSensor=function(j){if(j)this.m_flags|=A.e_sensorFlag;else this.m_flags&=~A.e_sensorFlag};A.prototype.IsSensor=function(){return(this.m_flags&
A.e_sensorFlag)==A.e_sensorFlag};A.prototype.SetEnabled=function(j){if(j)this.m_flags|=A.e_enabledFlag;else this.m_flags&=~A.e_enabledFlag};A.prototype.IsEnabled=function(){return(this.m_flags&A.e_enabledFlag)==A.e_enabledFlag};A.prototype.GetNext=function(){return this.m_next};A.prototype.GetFixtureA=function(){return this.m_fixtureA};A.prototype.GetFixtureB=function(){return this.m_fixtureB};A.prototype.FlagForFiltering=function(){this.m_flags|=A.e_filterFlag};A.prototype.b2Contact=function(){};
A.prototype.Reset=function(j,o){if(j===undefined)j=null;if(o===undefined)o=null;this.m_flags=A.e_enabledFlag;if(!j||!o)this.m_fixtureB=this.m_fixtureA=null;else{if(j.IsSensor()||o.IsSensor())this.m_flags|=A.e_sensorFlag;var q=j.GetBody(),n=o.GetBody();if(q.GetType()!=D.b2_dynamicBody||q.IsBullet()||n.GetType()!=D.b2_dynamicBody||n.IsBullet())this.m_flags|=A.e_continuousFlag;this.m_fixtureA=j;this.m_fixtureB=o;this.m_manifold.m_pointCount=0;this.m_next=this.m_prev=null;this.m_nodeA.contact=null;this.m_nodeA.prev=
null;this.m_nodeA.next=null;this.m_nodeA.other=null;this.m_nodeB.contact=null;this.m_nodeB.prev=null;this.m_nodeB.next=null;this.m_nodeB.other=null}};A.prototype.Update=function(j){var o=this.m_oldManifold;this.m_oldManifold=this.m_manifold;this.m_manifold=o;this.m_flags|=A.e_enabledFlag;var q=false;o=(this.m_flags&A.e_touchingFlag)==A.e_touchingFlag;var n=this.m_fixtureA.m_body,a=this.m_fixtureB.m_body,c=this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);if(this.m_flags&A.e_sensorFlag){if(c){q=
this.m_fixtureA.GetShape();c=this.m_fixtureB.GetShape();n=n.GetTransform();a=a.GetTransform();q=y.TestOverlap(q,n,c,a)}this.m_manifold.m_pointCount=0}else{if(n.GetType()!=D.b2_dynamicBody||n.IsBullet()||a.GetType()!=D.b2_dynamicBody||a.IsBullet())this.m_flags|=A.e_continuousFlag;else this.m_flags&=~A.e_continuousFlag;if(c){this.Evaluate();q=this.m_manifold.m_pointCount>0;for(c=0;c<this.m_manifold.m_pointCount;++c){var g=this.m_manifold.m_points[c];g.m_normalImpulse=0;g.m_tangentImpulse=0;for(var b=
g.m_id,e=0;e<this.m_oldManifold.m_pointCount;++e){var f=this.m_oldManifold.m_points[e];if(f.m_id.key==b.key){g.m_normalImpulse=f.m_normalImpulse;g.m_tangentImpulse=f.m_tangentImpulse;break}}}}else this.m_manifold.m_pointCount=0;if(q!=o){n.SetAwake(true);a.SetAwake(true)}}if(q)this.m_flags|=A.e_touchingFlag;else this.m_flags&=~A.e_touchingFlag;o==false&&q==true&&j.BeginContact(this);o==true&&q==false&&j.EndContact(this);(this.m_flags&A.e_sensorFlag)==0&&j.PreSolve(this,this.m_oldManifold)};A.prototype.Evaluate=
function(){};A.prototype.ComputeTOI=function(j,o){A.s_input.proxyA.Set(this.m_fixtureA.GetShape());A.s_input.proxyB.Set(this.m_fixtureB.GetShape());A.s_input.sweepA=j;A.s_input.sweepB=o;A.s_input.tolerance=O.b2_linearSlop;return d.TimeOfImpact(A.s_input)};Box2D.postDefs.push(function(){Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag=1;Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag=2;Box2D.Dynamics.Contacts.b2Contact.e_islandFlag=4;Box2D.Dynamics.Contacts.b2Contact.e_toiFlag=8;Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag=
16;Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag=32;Box2D.Dynamics.Contacts.b2Contact.e_filterFlag=64;Box2D.Dynamics.Contacts.b2Contact.s_input=new h});U.b2ContactConstraint=function(){this.localPlaneNormal=new N;this.localPoint=new N;this.normal=new N;this.normalMass=new E;this.K=new E};U.prototype.b2ContactConstraint=function(){this.points=new Vector(O.b2_maxManifoldPoints);for(var j=0;j<O.b2_maxManifoldPoints;j++)this.points[j]=new p};p.b2ContactConstraintPoint=function(){this.localPoint=new N;
this.rA=new N;this.rB=new N};B.b2ContactEdge=function(){};Q.b2ContactFactory=function(){};Q.prototype.b2ContactFactory=function(j){this.m_allocator=j;this.InitializeRegisters()};Q.prototype.AddType=function(j,o,q,n){if(q===undefined)q=0;if(n===undefined)n=0;this.m_registers[q][n].createFcn=j;this.m_registers[q][n].destroyFcn=o;this.m_registers[q][n].primary=true;if(q!=n){this.m_registers[n][q].createFcn=j;this.m_registers[n][q].destroyFcn=o;this.m_registers[n][q].primary=false}};Q.prototype.InitializeRegisters=
function(){this.m_registers=new Vector(y.e_shapeTypeCount);for(var j=0;j<y.e_shapeTypeCount;j++){this.m_registers[j]=new Vector(y.e_shapeTypeCount);for(var o=0;o<y.e_shapeTypeCount;o++)this.m_registers[j][o]=new V}this.AddType(w.Create,w.Destroy,y.e_circleShape,y.e_circleShape);this.AddType(Y.Create,Y.Destroy,y.e_polygonShape,y.e_circleShape);this.AddType(z.Create,z.Destroy,y.e_polygonShape,y.e_polygonShape);this.AddType(I.Create,I.Destroy,y.e_edgeShape,y.e_circleShape);this.AddType(k.Create,k.Destroy,
y.e_polygonShape,y.e_edgeShape)};Q.prototype.Create=function(j,o){var q=parseInt(j.GetType()),n=parseInt(o.GetType());q=this.m_registers[q][n];if(q.pool){n=q.pool;q.pool=n.m_next;q.poolCount--;n.Reset(j,o);return n}n=q.createFcn;if(n!=null){if(q.primary){n=n(this.m_allocator);n.Reset(j,o)}else{n=n(this.m_allocator);n.Reset(o,j)}return n}else return null};Q.prototype.Destroy=function(j){if(j.m_manifold.m_pointCount>0){j.m_fixtureA.m_body.SetAwake(true);j.m_fixtureB.m_body.SetAwake(true)}var o=parseInt(j.m_fixtureA.GetType()),
q=parseInt(j.m_fixtureB.GetType());o=this.m_registers[o][q];o.poolCount++;j.m_next=o.pool;o.pool=j;o=o.destroyFcn;o(j,this.m_allocator)};V.b2ContactRegister=function(){};M.b2ContactResult=function(){this.position=new N;this.normal=new N;this.id=new aa};L.b2ContactSolver=function(){this.m_step=new H;this.m_constraints=new Vector};L.prototype.b2ContactSolver=function(){};L.prototype.Initialize=function(j,o,q,n){if(q===undefined)q=0;var a;this.m_step.Set(j);this.m_allocator=n;j=0;for(this.m_constraintCount=
q;this.m_constraints.length<this.m_constraintCount;)this.m_constraints[this.m_constraints.length]=new U;for(j=0;j<q;++j){a=o[j];n=a.m_fixtureA;var c=a.m_fixtureB,g=n.m_shape.m_radius,b=c.m_shape.m_radius,e=n.m_body,f=c.m_body,m=a.GetManifold(),r=O.b2MixFriction(n.GetFriction(),c.GetFriction()),s=O.b2MixRestitution(n.GetRestitution(),c.GetRestitution()),v=e.m_linearVelocity.x,t=e.m_linearVelocity.y,x=f.m_linearVelocity.x,C=f.m_linearVelocity.y,J=e.m_angularVelocity,T=f.m_angularVelocity;O.b2Assert(m.m_pointCount>
0);L.s_worldManifold.Initialize(m,e.m_xf,g,f.m_xf,b);c=L.s_worldManifold.m_normal.x;a=L.s_worldManifold.m_normal.y;n=this.m_constraints[j];n.bodyA=e;n.bodyB=f;n.manifold=m;n.normal.x=c;n.normal.y=a;n.pointCount=m.m_pointCount;n.friction=r;n.restitution=s;n.localPlaneNormal.x=m.m_localPlaneNormal.x;n.localPlaneNormal.y=m.m_localPlaneNormal.y;n.localPoint.x=m.m_localPoint.x;n.localPoint.y=m.m_localPoint.y;n.radius=g+b;n.type=m.m_type;for(g=0;g<n.pointCount;++g){r=m.m_points[g];b=n.points[g];b.normalImpulse=
r.m_normalImpulse;b.tangentImpulse=r.m_tangentImpulse;b.localPoint.SetV(r.m_localPoint);r=b.rA.x=L.s_worldManifold.m_points[g].x-e.m_sweep.c.x;s=b.rA.y=L.s_worldManifold.m_points[g].y-e.m_sweep.c.y;var P=b.rB.x=L.s_worldManifold.m_points[g].x-f.m_sweep.c.x,X=b.rB.y=L.s_worldManifold.m_points[g].y-f.m_sweep.c.y,$=r*a-s*c,ba=P*a-X*c;$*=$;ba*=ba;b.normalMass=1/(e.m_invMass+f.m_invMass+e.m_invI*$+f.m_invI*ba);var ca=e.m_mass*e.m_invMass+f.m_mass*f.m_invMass;ca+=e.m_mass*e.m_invI*$+f.m_mass*f.m_invI*ba;
b.equalizedMass=1/ca;ba=a;ca=-c;$=r*ca-s*ba;ba=P*ca-X*ba;$*=$;ba*=ba;b.tangentMass=1/(e.m_invMass+f.m_invMass+e.m_invI*$+f.m_invI*ba);b.velocityBias=0;r=n.normal.x*(x+-T*X-v- -J*s)+n.normal.y*(C+T*P-t-J*r);if(r<-O.b2_velocityThreshold)b.velocityBias+=-n.restitution*r}if(n.pointCount==2){C=n.points[0];x=n.points[1];m=e.m_invMass;e=e.m_invI;v=f.m_invMass;f=f.m_invI;t=C.rA.x*a-C.rA.y*c;C=C.rB.x*a-C.rB.y*c;J=x.rA.x*a-x.rA.y*c;x=x.rB.x*a-x.rB.y*c;c=m+v+e*t*t+f*C*C;a=m+v+e*J*J+f*x*x;f=m+v+e*t*J+f*C*x;if(c*
c<100*(c*a-f*f)){n.K.col1.Set(c,f);n.K.col2.Set(f,a);n.K.GetInverse(n.normalMass)}else n.pointCount=1}}};L.prototype.InitVelocityConstraints=function(j){for(var o=0;o<this.m_constraintCount;++o){var q=this.m_constraints[o],n=q.bodyA,a=q.bodyB,c=n.m_invMass,g=n.m_invI,b=a.m_invMass,e=a.m_invI,f=q.normal.x,m=q.normal.y,r=m,s=-f,v=0,t=0;if(j.warmStarting){t=q.pointCount;for(v=0;v<t;++v){var x=q.points[v];x.normalImpulse*=j.dtRatio;x.tangentImpulse*=j.dtRatio;var C=x.normalImpulse*f+x.tangentImpulse*
r,J=x.normalImpulse*m+x.tangentImpulse*s;n.m_angularVelocity-=g*(x.rA.x*J-x.rA.y*C);n.m_linearVelocity.x-=c*C;n.m_linearVelocity.y-=c*J;a.m_angularVelocity+=e*(x.rB.x*J-x.rB.y*C);a.m_linearVelocity.x+=b*C;a.m_linearVelocity.y+=b*J}}else{t=q.pointCount;for(v=0;v<t;++v){n=q.points[v];n.normalImpulse=0;n.tangentImpulse=0}}}};L.prototype.SolveVelocityConstraints=function(){for(var j=0,o,q=0,n=0,a=0,c=n=n=q=q=0,g=q=q=0,b=q=a=0,e=0,f,m=0;m<this.m_constraintCount;++m){a=this.m_constraints[m];var r=a.bodyA,
s=a.bodyB,v=r.m_angularVelocity,t=s.m_angularVelocity,x=r.m_linearVelocity,C=s.m_linearVelocity,J=r.m_invMass,T=r.m_invI,P=s.m_invMass,X=s.m_invI;b=a.normal.x;var $=e=a.normal.y;f=-b;g=a.friction;for(j=0;j<a.pointCount;j++){o=a.points[j];q=C.x-t*o.rB.y-x.x+v*o.rA.y;n=C.y+t*o.rB.x-x.y-v*o.rA.x;q=q*$+n*f;q=o.tangentMass*-q;n=g*o.normalImpulse;n=R.Clamp(o.tangentImpulse+q,-n,n);q=n-o.tangentImpulse;c=q*$;q=q*f;x.x-=J*c;x.y-=J*q;v-=T*(o.rA.x*q-o.rA.y*c);C.x+=P*c;C.y+=P*q;t+=X*(o.rB.x*q-o.rB.y*c);o.tangentImpulse=
n}parseInt(a.pointCount);if(a.pointCount==1){o=a.points[0];q=C.x+-t*o.rB.y-x.x- -v*o.rA.y;n=C.y+t*o.rB.x-x.y-v*o.rA.x;a=q*b+n*e;q=-o.normalMass*(a-o.velocityBias);n=o.normalImpulse+q;n=n>0?n:0;q=n-o.normalImpulse;c=q*b;q=q*e;x.x-=J*c;x.y-=J*q;v-=T*(o.rA.x*q-o.rA.y*c);C.x+=P*c;C.y+=P*q;t+=X*(o.rB.x*q-o.rB.y*c);o.normalImpulse=n}else{o=a.points[0];j=a.points[1];q=o.normalImpulse;g=j.normalImpulse;var ba=(C.x-t*o.rB.y-x.x+v*o.rA.y)*b+(C.y+t*o.rB.x-x.y-v*o.rA.x)*e,ca=(C.x-t*j.rB.y-x.x+v*j.rA.y)*b+(C.y+
t*j.rB.x-x.y-v*j.rA.x)*e;n=ba-o.velocityBias;c=ca-j.velocityBias;f=a.K;n-=f.col1.x*q+f.col2.x*g;for(c-=f.col1.y*q+f.col2.y*g;;){f=a.normalMass;$=-(f.col1.x*n+f.col2.x*c);f=-(f.col1.y*n+f.col2.y*c);if($>=0&&f>=0){q=$-q;g=f-g;a=q*b;q=q*e;b=g*b;e=g*e;x.x-=J*(a+b);x.y-=J*(q+e);v-=T*(o.rA.x*q-o.rA.y*a+j.rA.x*e-j.rA.y*b);C.x+=P*(a+b);C.y+=P*(q+e);t+=X*(o.rB.x*q-o.rB.y*a+j.rB.x*e-j.rB.y*b);o.normalImpulse=$;j.normalImpulse=f;break}$=-o.normalMass*n;f=0;ca=a.K.col1.y*$+c;if($>=0&&ca>=0){q=$-q;g=f-g;a=q*b;
q=q*e;b=g*b;e=g*e;x.x-=J*(a+b);x.y-=J*(q+e);v-=T*(o.rA.x*q-o.rA.y*a+j.rA.x*e-j.rA.y*b);C.x+=P*(a+b);C.y+=P*(q+e);t+=X*(o.rB.x*q-o.rB.y*a+j.rB.x*e-j.rB.y*b);o.normalImpulse=$;j.normalImpulse=f;break}$=0;f=-j.normalMass*c;ba=a.K.col2.x*f+n;if(f>=0&&ba>=0){q=$-q;g=f-g;a=q*b;q=q*e;b=g*b;e=g*e;x.x-=J*(a+b);x.y-=J*(q+e);v-=T*(o.rA.x*q-o.rA.y*a+j.rA.x*e-j.rA.y*b);C.x+=P*(a+b);C.y+=P*(q+e);t+=X*(o.rB.x*q-o.rB.y*a+j.rB.x*e-j.rB.y*b);o.normalImpulse=$;j.normalImpulse=f;break}f=$=0;ba=n;ca=c;if(ba>=0&&ca>=0){q=
$-q;g=f-g;a=q*b;q=q*e;b=g*b;e=g*e;x.x-=J*(a+b);x.y-=J*(q+e);v-=T*(o.rA.x*q-o.rA.y*a+j.rA.x*e-j.rA.y*b);C.x+=P*(a+b);C.y+=P*(q+e);t+=X*(o.rB.x*q-o.rB.y*a+j.rB.x*e-j.rB.y*b);o.normalImpulse=$;j.normalImpulse=f;break}break}}r.m_angularVelocity=v;s.m_angularVelocity=t}};L.prototype.FinalizeVelocityConstraints=function(){for(var j=0;j<this.m_constraintCount;++j)for(var o=this.m_constraints[j],q=o.manifold,n=0;n<o.pointCount;++n){var a=q.m_points[n],c=o.points[n];a.m_normalImpulse=c.normalImpulse;a.m_tangentImpulse=
c.tangentImpulse}};L.prototype.SolvePositionConstraints=function(j){if(j===undefined)j=0;for(var o=0,q=0;q<this.m_constraintCount;q++){var n=this.m_constraints[q],a=n.bodyA,c=n.bodyB,g=a.m_mass*a.m_invMass,b=a.m_mass*a.m_invI,e=c.m_mass*c.m_invMass,f=c.m_mass*c.m_invI;L.s_psm.Initialize(n);for(var m=L.s_psm.m_normal,r=0;r<n.pointCount;r++){var s=n.points[r],v=L.s_psm.m_points[r],t=L.s_psm.m_separations[r],x=v.x-a.m_sweep.c.x,C=v.y-a.m_sweep.c.y,J=v.x-c.m_sweep.c.x;v=v.y-c.m_sweep.c.y;o=o<t?o:t;t=
R.Clamp(j*(t+O.b2_linearSlop),-O.b2_maxLinearCorrection,0);t=-s.equalizedMass*t;s=t*m.x;t=t*m.y;a.m_sweep.c.x-=g*s;a.m_sweep.c.y-=g*t;a.m_sweep.a-=b*(x*t-C*s);a.SynchronizeTransform();c.m_sweep.c.x+=e*s;c.m_sweep.c.y+=e*t;c.m_sweep.a+=f*(J*t-v*s);c.SynchronizeTransform()}}return o>-1.5*O.b2_linearSlop};Box2D.postDefs.push(function(){Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold=new l;Box2D.Dynamics.Contacts.b2ContactSolver.s_psm=new u});Box2D.inherit(I,Box2D.Dynamics.Contacts.b2Contact);
I.prototype.__super=Box2D.Dynamics.Contacts.b2Contact.prototype;I.b2EdgeAndCircleContact=function(){Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,arguments)};I.Create=function(){return new I};I.Destroy=function(){};I.prototype.Reset=function(j,o){this.__super.Reset.call(this,j,o)};I.prototype.Evaluate=function(){var j=this.m_fixtureA.GetBody(),o=this.m_fixtureB.GetBody();this.b2CollideEdgeAndCircle(this.m_manifold,this.m_fixtureA.GetShape()instanceof G?this.m_fixtureA.GetShape():null,j.m_xf,
this.m_fixtureB.GetShape()instanceof F?this.m_fixtureB.GetShape():null,o.m_xf)};I.prototype.b2CollideEdgeAndCircle=function(){};Box2D.inherit(W,Box2D.Dynamics.Contacts.b2Contact);W.prototype.__super=Box2D.Dynamics.Contacts.b2Contact.prototype;W.b2NullContact=function(){Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,arguments)};W.prototype.b2NullContact=function(){this.__super.b2Contact.call(this)};W.prototype.Evaluate=function(){};Box2D.inherit(Y,Box2D.Dynamics.Contacts.b2Contact);Y.prototype.__super=
Box2D.Dynamics.Contacts.b2Contact.prototype;Y.b2PolyAndCircleContact=function(){Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,arguments)};Y.Create=function(){return new Y};Y.Destroy=function(){};Y.prototype.Reset=function(j,o){this.__super.Reset.call(this,j,o);O.b2Assert(j.GetType()==y.e_polygonShape);O.b2Assert(o.GetType()==y.e_circleShape)};Y.prototype.Evaluate=function(){var j=this.m_fixtureA.m_body,o=this.m_fixtureB.m_body;S.CollidePolygonAndCircle(this.m_manifold,this.m_fixtureA.GetShape()instanceof
K?this.m_fixtureA.GetShape():null,j.m_xf,this.m_fixtureB.GetShape()instanceof F?this.m_fixtureB.GetShape():null,o.m_xf)};Box2D.inherit(k,Box2D.Dynamics.Contacts.b2Contact);k.prototype.__super=Box2D.Dynamics.Contacts.b2Contact.prototype;k.b2PolyAndEdgeContact=function(){Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,arguments)};k.Create=function(){return new k};k.Destroy=function(){};k.prototype.Reset=function(j,o){this.__super.Reset.call(this,j,o);O.b2Assert(j.GetType()==y.e_polygonShape);
O.b2Assert(o.GetType()==y.e_edgeShape)};k.prototype.Evaluate=function(){var j=this.m_fixtureA.GetBody(),o=this.m_fixtureB.GetBody();this.b2CollidePolyAndEdge(this.m_manifold,this.m_fixtureA.GetShape()instanceof K?this.m_fixtureA.GetShape():null,j.m_xf,this.m_fixtureB.GetShape()instanceof G?this.m_fixtureB.GetShape():null,o.m_xf)};k.prototype.b2CollidePolyAndEdge=function(){};Box2D.inherit(z,Box2D.Dynamics.Contacts.b2Contact);z.prototype.__super=Box2D.Dynamics.Contacts.b2Contact.prototype;z.b2PolygonContact=
function(){Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,arguments)};z.Create=function(){return new z};z.Destroy=function(){};z.prototype.Reset=function(j,o){this.__super.Reset.call(this,j,o)};z.prototype.Evaluate=function(){var j=this.m_fixtureA.GetBody(),o=this.m_fixtureB.GetBody();S.CollidePolygons(this.m_manifold,this.m_fixtureA.GetShape()instanceof K?this.m_fixtureA.GetShape():null,j.m_xf,this.m_fixtureB.GetShape()instanceof K?this.m_fixtureB.GetShape():null,o.m_xf)};u.b2PositionSolverManifold=
function(){};u.prototype.b2PositionSolverManifold=function(){this.m_normal=new N;this.m_separations=new Vector_a2j_Number(O.b2_maxManifoldPoints);this.m_points=new Vector(O.b2_maxManifoldPoints);for(var j=0;j<O.b2_maxManifoldPoints;j++)this.m_points[j]=new N};u.prototype.Initialize=function(j){O.b2Assert(j.pointCount>0);var o=0,q=0,n=0,a,c=0,g=0;switch(j.type){case Z.e_circles:a=j.bodyA.m_xf.R;n=j.localPoint;o=j.bodyA.m_xf.position.x+(a.col1.x*n.x+a.col2.x*n.y);q=j.bodyA.m_xf.position.y+(a.col1.y*
n.x+a.col2.y*n.y);a=j.bodyB.m_xf.R;n=j.points[0].localPoint;c=j.bodyB.m_xf.position.x+(a.col1.x*n.x+a.col2.x*n.y);a=j.bodyB.m_xf.position.y+(a.col1.y*n.x+a.col2.y*n.y);n=c-o;g=a-q;var b=n*n+g*g;if(b>Number.MIN_VALUE*Number.MIN_VALUE){b=Math.sqrt(b);this.m_normal.x=n/b;this.m_normal.y=g/b}else{this.m_normal.x=1;this.m_normal.y=0}this.m_points[0].x=0.5*(o+c);this.m_points[0].y=0.5*(q+a);this.m_separations[0]=n*this.m_normal.x+g*this.m_normal.y-j.radius;break;case Z.e_faceA:a=j.bodyA.m_xf.R;n=j.localPlaneNormal;
this.m_normal.x=a.col1.x*n.x+a.col2.x*n.y;this.m_normal.y=a.col1.y*n.x+a.col2.y*n.y;a=j.bodyA.m_xf.R;n=j.localPoint;c=j.bodyA.m_xf.position.x+(a.col1.x*n.x+a.col2.x*n.y);g=j.bodyA.m_xf.position.y+(a.col1.y*n.x+a.col2.y*n.y);a=j.bodyB.m_xf.R;for(o=0;o<j.pointCount;++o){n=j.points[o].localPoint;q=j.bodyB.m_xf.position.x+(a.col1.x*n.x+a.col2.x*n.y);n=j.bodyB.m_xf.position.y+(a.col1.y*n.x+a.col2.y*n.y);this.m_separations[o]=(q-c)*this.m_normal.x+(n-g)*this.m_normal.y-j.radius;this.m_points[o].x=q;this.m_points[o].y=
n}break;case Z.e_faceB:a=j.bodyB.m_xf.R;n=j.localPlaneNormal;this.m_normal.x=a.col1.x*n.x+a.col2.x*n.y;this.m_normal.y=a.col1.y*n.x+a.col2.y*n.y;a=j.bodyB.m_xf.R;n=j.localPoint;c=j.bodyB.m_xf.position.x+(a.col1.x*n.x+a.col2.x*n.y);g=j.bodyB.m_xf.position.y+(a.col1.y*n.x+a.col2.y*n.y);a=j.bodyA.m_xf.R;for(o=0;o<j.pointCount;++o){n=j.points[o].localPoint;q=j.bodyA.m_xf.position.x+(a.col1.x*n.x+a.col2.x*n.y);n=j.bodyA.m_xf.position.y+(a.col1.y*n.x+a.col2.y*n.y);this.m_separations[o]=(q-c)*this.m_normal.x+
(n-g)*this.m_normal.y-j.radius;this.m_points[o].Set(q,n)}this.m_normal.x*=-1;this.m_normal.y*=-1}};Box2D.postDefs.push(function(){Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA=new N;Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB=new N})})();
(function(){var F=Box2D.Common.Math.b2Mat22,G=Box2D.Common.Math.b2Math,K=Box2D.Common.Math.b2Vec2,y=Box2D.Common.b2Color,w=Box2D.Dynamics.Controllers.b2BuoyancyController,A=Box2D.Dynamics.Controllers.b2ConstantAccelController,U=Box2D.Dynamics.Controllers.b2ConstantForceController,p=Box2D.Dynamics.Controllers.b2Controller,B=Box2D.Dynamics.Controllers.b2ControllerEdge,Q=Box2D.Dynamics.Controllers.b2GravityController,V=Box2D.Dynamics.Controllers.b2TensorDampingController;Box2D.inherit(w,Box2D.Dynamics.Controllers.b2Controller);
w.prototype.__super=Box2D.Dynamics.Controllers.b2Controller.prototype;w.b2BuoyancyController=function(){Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this,arguments);this.normal=new K(0,-1);this.density=this.offset=0;this.velocity=new K(0,0);this.linearDrag=2;this.angularDrag=1;this.useDensity=false;this.useWorldGravity=true;this.gravity=null};w.prototype.Step=function(){if(this.m_bodyList){if(this.useWorldGravity)this.gravity=this.GetWorld().GetGravity().Copy();for(var M=this.m_bodyList;M;M=
M.nextBody){var L=M.body;if(L.IsAwake()!=false){for(var I=new K,W=new K,Y=0,k=0,z=L.GetFixtureList();z;z=z.GetNext()){var u=new K,D=z.GetShape().ComputeSubmergedArea(this.normal,this.offset,L.GetTransform(),u);Y+=D;I.x+=D*u.x;I.y+=D*u.y;var H=0;H=1;k+=D*H;W.x+=D*u.x*H;W.y+=D*u.y*H}I.x/=Y;I.y/=Y;W.x/=k;W.y/=k;if(!(Y<Number.MIN_VALUE)){k=this.gravity.GetNegative();k.Multiply(this.density*Y);L.ApplyForce(k,W);W=L.GetLinearVelocityFromWorldPoint(I);W.Subtract(this.velocity);W.Multiply(-this.linearDrag*
Y);L.ApplyForce(W,I);L.ApplyTorque(-L.GetInertia()/L.GetMass()*Y*L.GetAngularVelocity()*this.angularDrag)}}}}};w.prototype.Draw=function(M){var L=new K,I=new K;L.x=this.normal.x*this.offset+this.normal.y*1E3;L.y=this.normal.y*this.offset-this.normal.x*1E3;I.x=this.normal.x*this.offset-this.normal.y*1E3;I.y=this.normal.y*this.offset+this.normal.x*1E3;var W=new y(0,0,1);M.DrawSegment(L,I,W)};Box2D.inherit(A,Box2D.Dynamics.Controllers.b2Controller);A.prototype.__super=Box2D.Dynamics.Controllers.b2Controller.prototype;
A.b2ConstantAccelController=function(){Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this,arguments);this.A=new K(0,0)};A.prototype.Step=function(M){M=new K(this.A.x*M.dt,this.A.y*M.dt);for(var L=this.m_bodyList;L;L=L.nextBody){var I=L.body;I.IsAwake()&&I.SetLinearVelocity(new K(I.GetLinearVelocity().x+M.x,I.GetLinearVelocity().y+M.y))}};Box2D.inherit(U,Box2D.Dynamics.Controllers.b2Controller);U.prototype.__super=Box2D.Dynamics.Controllers.b2Controller.prototype;U.b2ConstantForceController=
function(){Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this,arguments);this.F=new K(0,0)};U.prototype.Step=function(){for(var M=this.m_bodyList;M;M=M.nextBody){var L=M.body;L.IsAwake()&&L.ApplyForce(this.F,L.GetWorldCenter())}};p.b2Controller=function(){};p.prototype.Step=function(){};p.prototype.Draw=function(){};p.prototype.AddBody=function(M){var L=new B;L.controller=this;L.body=M;L.nextBody=this.m_bodyList;L.prevBody=null;this.m_bodyList=L;if(L.nextBody)L.nextBody.prevBody=L;this.m_bodyCount++;
L.nextController=M.m_controllerList;L.prevController=null;M.m_controllerList=L;if(L.nextController)L.nextController.prevController=L;M.m_controllerCount++};p.prototype.RemoveBody=function(M){for(var L=M.m_controllerList;L&&L.controller!=this;)L=L.nextController;if(L.prevBody)L.prevBody.nextBody=L.nextBody;if(L.nextBody)L.nextBody.prevBody=L.prevBody;if(L.nextController)L.nextController.prevController=L.prevController;if(L.prevController)L.prevController.nextController=L.nextController;if(this.m_bodyList==
L)this.m_bodyList=L.nextBody;if(M.m_controllerList==L)M.m_controllerList=L.nextController;M.m_controllerCount--;this.m_bodyCount--};p.prototype.Clear=function(){for(;this.m_bodyList;)this.RemoveBody(this.m_bodyList.body)};p.prototype.GetNext=function(){return this.m_next};p.prototype.GetWorld=function(){return this.m_world};p.prototype.GetBodyList=function(){return this.m_bodyList};B.b2ControllerEdge=function(){};Box2D.inherit(Q,Box2D.Dynamics.Controllers.b2Controller);Q.prototype.__super=Box2D.Dynamics.Controllers.b2Controller.prototype;
Q.b2GravityController=function(){Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this,arguments);this.G=1;this.invSqr=true};Q.prototype.Step=function(){var M=null,L=null,I=null,W=0,Y=null,k=null,z=null,u=0,D=0,H=0;u=null;if(this.invSqr)for(M=this.m_bodyList;M;M=M.nextBody){L=M.body;I=L.GetWorldCenter();W=L.GetMass();for(Y=this.m_bodyList;Y!=M;Y=Y.nextBody){k=Y.body;z=k.GetWorldCenter();u=z.x-I.x;D=z.y-I.y;H=u*u+D*D;if(!(H<Number.MIN_VALUE)){u=new K(u,D);u.Multiply(this.G/H/Math.sqrt(H)*
W*k.GetMass());L.IsAwake()&&L.ApplyForce(u,I);u.Multiply(-1);k.IsAwake()&&k.ApplyForce(u,z)}}}else for(M=this.m_bodyList;M;M=M.nextBody){L=M.body;I=L.GetWorldCenter();W=L.GetMass();for(Y=this.m_bodyList;Y!=M;Y=Y.nextBody){k=Y.body;z=k.GetWorldCenter();u=z.x-I.x;D=z.y-I.y;H=u*u+D*D;if(!(H<Number.MIN_VALUE)){u=new K(u,D);u.Multiply(this.G/H*W*k.GetMass());L.IsAwake()&&L.ApplyForce(u,I);u.Multiply(-1);k.IsAwake()&&k.ApplyForce(u,z)}}}};Box2D.inherit(V,Box2D.Dynamics.Controllers.b2Controller);V.prototype.__super=
Box2D.Dynamics.Controllers.b2Controller.prototype;V.b2TensorDampingController=function(){Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this,arguments);this.T=new F;this.maxTimestep=0};V.prototype.SetAxisAligned=function(M,L){if(M===undefined)M=0;if(L===undefined)L=0;this.T.col1.x=-M;this.T.col1.y=0;this.T.col2.x=0;this.T.col2.y=-L;this.maxTimestep=M>0||L>0?1/Math.max(M,L):0};V.prototype.Step=function(M){M=M.dt;if(!(M<=Number.MIN_VALUE)){if(M>this.maxTimestep&&this.maxTimestep>0)M=this.maxTimestep;
for(var L=this.m_bodyList;L;L=L.nextBody){var I=L.body;if(I.IsAwake()){var W=I.GetWorldVector(G.MulMV(this.T,I.GetLocalVector(I.GetLinearVelocity())));I.SetLinearVelocity(new K(I.GetLinearVelocity().x+W.x*M,I.GetLinearVelocity().y+W.y*M))}}}}})();
(function(){var F=Box2D.Common.b2Settings,G=Box2D.Common.Math.b2Mat22,K=Box2D.Common.Math.b2Mat33,y=Box2D.Common.Math.b2Math,w=Box2D.Common.Math.b2Vec2,A=Box2D.Common.Math.b2Vec3,U=Box2D.Dynamics.Joints.b2DistanceJoint,p=Box2D.Dynamics.Joints.b2DistanceJointDef,B=Box2D.Dynamics.Joints.b2FrictionJoint,Q=Box2D.Dynamics.Joints.b2FrictionJointDef,V=Box2D.Dynamics.Joints.b2GearJoint,M=Box2D.Dynamics.Joints.b2GearJointDef,L=Box2D.Dynamics.Joints.b2Jacobian,I=Box2D.Dynamics.Joints.b2Joint,W=Box2D.Dynamics.Joints.b2JointDef,
Y=Box2D.Dynamics.Joints.b2JointEdge,k=Box2D.Dynamics.Joints.b2LineJoint,z=Box2D.Dynamics.Joints.b2LineJointDef,u=Box2D.Dynamics.Joints.b2MouseJoint,D=Box2D.Dynamics.Joints.b2MouseJointDef,H=Box2D.Dynamics.Joints.b2PrismaticJoint,O=Box2D.Dynamics.Joints.b2PrismaticJointDef,E=Box2D.Dynamics.Joints.b2PulleyJoint,R=Box2D.Dynamics.Joints.b2PulleyJointDef,N=Box2D.Dynamics.Joints.b2RevoluteJoint,S=Box2D.Dynamics.Joints.b2RevoluteJointDef,aa=Box2D.Dynamics.Joints.b2WeldJoint,Z=Box2D.Dynamics.Joints.b2WeldJointDef;
Box2D.inherit(U,Box2D.Dynamics.Joints.b2Joint);U.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;U.b2DistanceJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_localAnchor1=new w;this.m_localAnchor2=new w;this.m_u=new w};U.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)};U.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)};U.prototype.GetReactionForce=function(d){if(d===undefined)d=
0;return new w(d*this.m_impulse*this.m_u.x,d*this.m_impulse*this.m_u.y)};U.prototype.GetReactionTorque=function(){return 0};U.prototype.GetLength=function(){return this.m_length};U.prototype.SetLength=function(d){if(d===undefined)d=0;this.m_length=d};U.prototype.GetFrequency=function(){return this.m_frequencyHz};U.prototype.SetFrequency=function(d){if(d===undefined)d=0;this.m_frequencyHz=d};U.prototype.GetDampingRatio=function(){return this.m_dampingRatio};U.prototype.SetDampingRatio=function(d){if(d===
undefined)d=0;this.m_dampingRatio=d};U.prototype.b2DistanceJoint=function(d){this.__super.b2Joint.call(this,d);this.m_localAnchor1.SetV(d.localAnchorA);this.m_localAnchor2.SetV(d.localAnchorB);this.m_length=d.length;this.m_frequencyHz=d.frequencyHz;this.m_dampingRatio=d.dampingRatio;this.m_bias=this.m_gamma=this.m_impulse=0};U.prototype.InitVelocityConstraints=function(d){var h,l=0,j=this.m_bodyA,o=this.m_bodyB;h=j.m_xf.R;var q=this.m_localAnchor1.x-j.m_sweep.localCenter.x,n=this.m_localAnchor1.y-
j.m_sweep.localCenter.y;l=h.col1.x*q+h.col2.x*n;n=h.col1.y*q+h.col2.y*n;q=l;h=o.m_xf.R;var a=this.m_localAnchor2.x-o.m_sweep.localCenter.x,c=this.m_localAnchor2.y-o.m_sweep.localCenter.y;l=h.col1.x*a+h.col2.x*c;c=h.col1.y*a+h.col2.y*c;a=l;this.m_u.x=o.m_sweep.c.x+a-j.m_sweep.c.x-q;this.m_u.y=o.m_sweep.c.y+c-j.m_sweep.c.y-n;l=Math.sqrt(this.m_u.x*this.m_u.x+this.m_u.y*this.m_u.y);l>F.b2_linearSlop?this.m_u.Multiply(1/l):this.m_u.SetZero();h=q*this.m_u.y-n*this.m_u.x;var g=a*this.m_u.y-c*this.m_u.x;
h=j.m_invMass+j.m_invI*h*h+o.m_invMass+o.m_invI*g*g;this.m_mass=h!=0?1/h:0;if(this.m_frequencyHz>0){l=l-this.m_length;g=2*Math.PI*this.m_frequencyHz;var b=this.m_mass*g*g;this.m_gamma=d.dt*(2*this.m_mass*this.m_dampingRatio*g+d.dt*b);this.m_gamma=this.m_gamma!=0?1/this.m_gamma:0;this.m_bias=l*d.dt*b*this.m_gamma;this.m_mass=h+this.m_gamma;this.m_mass=this.m_mass!=0?1/this.m_mass:0}if(d.warmStarting){this.m_impulse*=d.dtRatio;d=this.m_impulse*this.m_u.x;h=this.m_impulse*this.m_u.y;j.m_linearVelocity.x-=
j.m_invMass*d;j.m_linearVelocity.y-=j.m_invMass*h;j.m_angularVelocity-=j.m_invI*(q*h-n*d);o.m_linearVelocity.x+=o.m_invMass*d;o.m_linearVelocity.y+=o.m_invMass*h;o.m_angularVelocity+=o.m_invI*(a*h-c*d)}else this.m_impulse=0};U.prototype.SolveVelocityConstraints=function(){var d,h=this.m_bodyA,l=this.m_bodyB;d=h.m_xf.R;var j=this.m_localAnchor1.x-h.m_sweep.localCenter.x,o=this.m_localAnchor1.y-h.m_sweep.localCenter.y,q=d.col1.x*j+d.col2.x*o;o=d.col1.y*j+d.col2.y*o;j=q;d=l.m_xf.R;var n=this.m_localAnchor2.x-
l.m_sweep.localCenter.x,a=this.m_localAnchor2.y-l.m_sweep.localCenter.y;q=d.col1.x*n+d.col2.x*a;a=d.col1.y*n+d.col2.y*a;n=q;q=-this.m_mass*(this.m_u.x*(l.m_linearVelocity.x+-l.m_angularVelocity*a-(h.m_linearVelocity.x+-h.m_angularVelocity*o))+this.m_u.y*(l.m_linearVelocity.y+l.m_angularVelocity*n-(h.m_linearVelocity.y+h.m_angularVelocity*j))+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=q;d=q*this.m_u.x;q=q*this.m_u.y;h.m_linearVelocity.x-=h.m_invMass*d;h.m_linearVelocity.y-=h.m_invMass*
q;h.m_angularVelocity-=h.m_invI*(j*q-o*d);l.m_linearVelocity.x+=l.m_invMass*d;l.m_linearVelocity.y+=l.m_invMass*q;l.m_angularVelocity+=l.m_invI*(n*q-a*d)};U.prototype.SolvePositionConstraints=function(){var d;if(this.m_frequencyHz>0)return true;var h=this.m_bodyA,l=this.m_bodyB;d=h.m_xf.R;var j=this.m_localAnchor1.x-h.m_sweep.localCenter.x,o=this.m_localAnchor1.y-h.m_sweep.localCenter.y,q=d.col1.x*j+d.col2.x*o;o=d.col1.y*j+d.col2.y*o;j=q;d=l.m_xf.R;var n=this.m_localAnchor2.x-l.m_sweep.localCenter.x,
a=this.m_localAnchor2.y-l.m_sweep.localCenter.y;q=d.col1.x*n+d.col2.x*a;a=d.col1.y*n+d.col2.y*a;n=q;q=l.m_sweep.c.x+n-h.m_sweep.c.x-j;var c=l.m_sweep.c.y+a-h.m_sweep.c.y-o;d=Math.sqrt(q*q+c*c);q/=d;c/=d;d=d-this.m_length;d=y.Clamp(d,-F.b2_maxLinearCorrection,F.b2_maxLinearCorrection);var g=-this.m_mass*d;this.m_u.Set(q,c);q=g*this.m_u.x;c=g*this.m_u.y;h.m_sweep.c.x-=h.m_invMass*q;h.m_sweep.c.y-=h.m_invMass*c;h.m_sweep.a-=h.m_invI*(j*c-o*q);l.m_sweep.c.x+=l.m_invMass*q;l.m_sweep.c.y+=l.m_invMass*c;
l.m_sweep.a+=l.m_invI*(n*c-a*q);h.SynchronizeTransform();l.SynchronizeTransform();return y.Abs(d)<F.b2_linearSlop};Box2D.inherit(p,Box2D.Dynamics.Joints.b2JointDef);p.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;p.b2DistanceJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.localAnchorA=new w;this.localAnchorB=new w};p.prototype.b2DistanceJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_distanceJoint;this.length=1;this.dampingRatio=
this.frequencyHz=0};p.prototype.Initialize=function(d,h,l,j){this.bodyA=d;this.bodyB=h;this.localAnchorA.SetV(this.bodyA.GetLocalPoint(l));this.localAnchorB.SetV(this.bodyB.GetLocalPoint(j));d=j.x-l.x;l=j.y-l.y;this.length=Math.sqrt(d*d+l*l);this.dampingRatio=this.frequencyHz=0};Box2D.inherit(B,Box2D.Dynamics.Joints.b2Joint);B.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;B.b2FrictionJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_localAnchorA=new w;
this.m_localAnchorB=new w;this.m_linearMass=new G;this.m_linearImpulse=new w};B.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)};B.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)};B.prototype.GetReactionForce=function(d){if(d===undefined)d=0;return new w(d*this.m_linearImpulse.x,d*this.m_linearImpulse.y)};B.prototype.GetReactionTorque=function(d){if(d===undefined)d=0;return d*this.m_angularImpulse};B.prototype.SetMaxForce=
function(d){if(d===undefined)d=0;this.m_maxForce=d};B.prototype.GetMaxForce=function(){return this.m_maxForce};B.prototype.SetMaxTorque=function(d){if(d===undefined)d=0;this.m_maxTorque=d};B.prototype.GetMaxTorque=function(){return this.m_maxTorque};B.prototype.b2FrictionJoint=function(d){this.__super.b2Joint.call(this,d);this.m_localAnchorA.SetV(d.localAnchorA);this.m_localAnchorB.SetV(d.localAnchorB);this.m_linearMass.SetZero();this.m_angularMass=0;this.m_linearImpulse.SetZero();this.m_angularImpulse=
0;this.m_maxForce=d.maxForce;this.m_maxTorque=d.maxTorque};B.prototype.InitVelocityConstraints=function(d){var h,l=0,j=this.m_bodyA,o=this.m_bodyB;h=j.m_xf.R;var q=this.m_localAnchorA.x-j.m_sweep.localCenter.x,n=this.m_localAnchorA.y-j.m_sweep.localCenter.y;l=h.col1.x*q+h.col2.x*n;n=h.col1.y*q+h.col2.y*n;q=l;h=o.m_xf.R;var a=this.m_localAnchorB.x-o.m_sweep.localCenter.x,c=this.m_localAnchorB.y-o.m_sweep.localCenter.y;l=h.col1.x*a+h.col2.x*c;c=h.col1.y*a+h.col2.y*c;a=l;h=j.m_invMass;l=o.m_invMass;
var g=j.m_invI,b=o.m_invI,e=new G;e.col1.x=h+l;e.col2.x=0;e.col1.y=0;e.col2.y=h+l;e.col1.x+=g*n*n;e.col2.x+=-g*q*n;e.col1.y+=-g*q*n;e.col2.y+=g*q*q;e.col1.x+=b*c*c;e.col2.x+=-b*a*c;e.col1.y+=-b*a*c;e.col2.y+=b*a*a;e.GetInverse(this.m_linearMass);this.m_angularMass=g+b;if(this.m_angularMass>0)this.m_angularMass=1/this.m_angularMass;if(d.warmStarting){this.m_linearImpulse.x*=d.dtRatio;this.m_linearImpulse.y*=d.dtRatio;this.m_angularImpulse*=d.dtRatio;d=this.m_linearImpulse;j.m_linearVelocity.x-=h*d.x;
j.m_linearVelocity.y-=h*d.y;j.m_angularVelocity-=g*(q*d.y-n*d.x+this.m_angularImpulse);o.m_linearVelocity.x+=l*d.x;o.m_linearVelocity.y+=l*d.y;o.m_angularVelocity+=b*(a*d.y-c*d.x+this.m_angularImpulse)}else{this.m_linearImpulse.SetZero();this.m_angularImpulse=0}};B.prototype.SolveVelocityConstraints=function(d){var h,l=0,j=this.m_bodyA,o=this.m_bodyB,q=j.m_linearVelocity,n=j.m_angularVelocity,a=o.m_linearVelocity,c=o.m_angularVelocity,g=j.m_invMass,b=o.m_invMass,e=j.m_invI,f=o.m_invI;h=j.m_xf.R;var m=
this.m_localAnchorA.x-j.m_sweep.localCenter.x,r=this.m_localAnchorA.y-j.m_sweep.localCenter.y;l=h.col1.x*m+h.col2.x*r;r=h.col1.y*m+h.col2.y*r;m=l;h=o.m_xf.R;var s=this.m_localAnchorB.x-o.m_sweep.localCenter.x,v=this.m_localAnchorB.y-o.m_sweep.localCenter.y;l=h.col1.x*s+h.col2.x*v;v=h.col1.y*s+h.col2.y*v;s=l;h=0;l=-this.m_angularMass*(c-n);var t=this.m_angularImpulse;h=d.dt*this.m_maxTorque;this.m_angularImpulse=y.Clamp(this.m_angularImpulse+l,-h,h);l=this.m_angularImpulse-t;n-=e*l;c+=f*l;h=y.MulMV(this.m_linearMass,
new w(-(a.x-c*v-q.x+n*r),-(a.y+c*s-q.y-n*m)));l=this.m_linearImpulse.Copy();this.m_linearImpulse.Add(h);h=d.dt*this.m_maxForce;if(this.m_linearImpulse.LengthSquared()>h*h){this.m_linearImpulse.Normalize();this.m_linearImpulse.Multiply(h)}h=y.SubtractVV(this.m_linearImpulse,l);q.x-=g*h.x;q.y-=g*h.y;n-=e*(m*h.y-r*h.x);a.x+=b*h.x;a.y+=b*h.y;c+=f*(s*h.y-v*h.x);j.m_angularVelocity=n;o.m_angularVelocity=c};B.prototype.SolvePositionConstraints=function(){return true};Box2D.inherit(Q,Box2D.Dynamics.Joints.b2JointDef);
Q.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;Q.b2FrictionJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.localAnchorA=new w;this.localAnchorB=new w};Q.prototype.b2FrictionJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_frictionJoint;this.maxTorque=this.maxForce=0};Q.prototype.Initialize=function(d,h,l){this.bodyA=d;this.bodyB=h;this.localAnchorA.SetV(this.bodyA.GetLocalPoint(l));this.localAnchorB.SetV(this.bodyB.GetLocalPoint(l))};
Box2D.inherit(V,Box2D.Dynamics.Joints.b2Joint);V.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;V.b2GearJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_groundAnchor1=new w;this.m_groundAnchor2=new w;this.m_localAnchor1=new w;this.m_localAnchor2=new w;this.m_J=new L};V.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)};V.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)};V.prototype.GetReactionForce=
function(d){if(d===undefined)d=0;return new w(d*this.m_impulse*this.m_J.linearB.x,d*this.m_impulse*this.m_J.linearB.y)};V.prototype.GetReactionTorque=function(d){if(d===undefined)d=0;var h=this.m_bodyB.m_xf.R,l=this.m_localAnchor1.x-this.m_bodyB.m_sweep.localCenter.x,j=this.m_localAnchor1.y-this.m_bodyB.m_sweep.localCenter.y,o=h.col1.x*l+h.col2.x*j;j=h.col1.y*l+h.col2.y*j;l=o;return d*(this.m_impulse*this.m_J.angularB-l*this.m_impulse*this.m_J.linearB.y+j*this.m_impulse*this.m_J.linearB.x)};V.prototype.GetRatio=
function(){return this.m_ratio};V.prototype.SetRatio=function(d){if(d===undefined)d=0;this.m_ratio=d};V.prototype.b2GearJoint=function(d){this.__super.b2Joint.call(this,d);var h=parseInt(d.joint1.m_type),l=parseInt(d.joint2.m_type);this.m_prismatic2=this.m_revolute2=this.m_prismatic1=this.m_revolute1=null;var j=0,o=0;this.m_ground1=d.joint1.GetBodyA();this.m_bodyA=d.joint1.GetBodyB();if(h==I.e_revoluteJoint){this.m_revolute1=d.joint1 instanceof N?d.joint1:null;this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);j=this.m_revolute1.GetJointAngle()}else{this.m_prismatic1=d.joint1 instanceof H?d.joint1:null;this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);j=this.m_prismatic1.GetJointTranslation()}this.m_ground2=d.joint2.GetBodyA();this.m_bodyB=d.joint2.GetBodyB();if(l==I.e_revoluteJoint){this.m_revolute2=d.joint2 instanceof N?d.joint2:null;this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);o=this.m_revolute2.GetJointAngle()}else{this.m_prismatic2=d.joint2 instanceof H?d.joint2:null;this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);o=this.m_prismatic2.GetJointTranslation()}this.m_ratio=d.ratio;this.m_constant=j+this.m_ratio*o;this.m_impulse=0};V.prototype.InitVelocityConstraints=function(d){var h=this.m_ground1,l=this.m_ground2,j=this.m_bodyA,o=this.m_bodyB,
q=0,n=0,a=0,c=0,g=a=0,b=0;this.m_J.SetZero();if(this.m_revolute1){this.m_J.angularA=-1;b+=j.m_invI}else{h=h.m_xf.R;n=this.m_prismatic1.m_localXAxis1;q=h.col1.x*n.x+h.col2.x*n.y;n=h.col1.y*n.x+h.col2.y*n.y;h=j.m_xf.R;a=this.m_localAnchor1.x-j.m_sweep.localCenter.x;c=this.m_localAnchor1.y-j.m_sweep.localCenter.y;g=h.col1.x*a+h.col2.x*c;c=h.col1.y*a+h.col2.y*c;a=g;a=a*n-c*q;this.m_J.linearA.Set(-q,-n);this.m_J.angularA=-a;b+=j.m_invMass+j.m_invI*a*a}if(this.m_revolute2){this.m_J.angularB=-this.m_ratio;
b+=this.m_ratio*this.m_ratio*o.m_invI}else{h=l.m_xf.R;n=this.m_prismatic2.m_localXAxis1;q=h.col1.x*n.x+h.col2.x*n.y;n=h.col1.y*n.x+h.col2.y*n.y;h=o.m_xf.R;a=this.m_localAnchor2.x-o.m_sweep.localCenter.x;c=this.m_localAnchor2.y-o.m_sweep.localCenter.y;g=h.col1.x*a+h.col2.x*c;c=h.col1.y*a+h.col2.y*c;a=g;a=a*n-c*q;this.m_J.linearB.Set(-this.m_ratio*q,-this.m_ratio*n);this.m_J.angularB=-this.m_ratio*a;b+=this.m_ratio*this.m_ratio*(o.m_invMass+o.m_invI*a*a)}this.m_mass=b>0?1/b:0;if(d.warmStarting){j.m_linearVelocity.x+=
j.m_invMass*this.m_impulse*this.m_J.linearA.x;j.m_linearVelocity.y+=j.m_invMass*this.m_impulse*this.m_J.linearA.y;j.m_angularVelocity+=j.m_invI*this.m_impulse*this.m_J.angularA;o.m_linearVelocity.x+=o.m_invMass*this.m_impulse*this.m_J.linearB.x;o.m_linearVelocity.y+=o.m_invMass*this.m_impulse*this.m_J.linearB.y;o.m_angularVelocity+=o.m_invI*this.m_impulse*this.m_J.angularB}else this.m_impulse=0};V.prototype.SolveVelocityConstraints=function(){var d=this.m_bodyA,h=this.m_bodyB,l=-this.m_mass*this.m_J.Compute(d.m_linearVelocity,
d.m_angularVelocity,h.m_linearVelocity,h.m_angularVelocity);this.m_impulse+=l;d.m_linearVelocity.x+=d.m_invMass*l*this.m_J.linearA.x;d.m_linearVelocity.y+=d.m_invMass*l*this.m_J.linearA.y;d.m_angularVelocity+=d.m_invI*l*this.m_J.angularA;h.m_linearVelocity.x+=h.m_invMass*l*this.m_J.linearB.x;h.m_linearVelocity.y+=h.m_invMass*l*this.m_J.linearB.y;h.m_angularVelocity+=h.m_invI*l*this.m_J.angularB};V.prototype.SolvePositionConstraints=function(){var d=this.m_bodyA,h=this.m_bodyB,l=0,j=0;l=this.m_revolute1?
this.m_revolute1.GetJointAngle():this.m_prismatic1.GetJointTranslation();j=this.m_revolute2?this.m_revolute2.GetJointAngle():this.m_prismatic2.GetJointTranslation();l=-this.m_mass*(this.m_constant-(l+this.m_ratio*j));d.m_sweep.c.x+=d.m_invMass*l*this.m_J.linearA.x;d.m_sweep.c.y+=d.m_invMass*l*this.m_J.linearA.y;d.m_sweep.a+=d.m_invI*l*this.m_J.angularA;h.m_sweep.c.x+=h.m_invMass*l*this.m_J.linearB.x;h.m_sweep.c.y+=h.m_invMass*l*this.m_J.linearB.y;h.m_sweep.a+=h.m_invI*l*this.m_J.angularB;d.SynchronizeTransform();
h.SynchronizeTransform();return 0<F.b2_linearSlop};Box2D.inherit(M,Box2D.Dynamics.Joints.b2JointDef);M.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;M.b2GearJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments)};M.prototype.b2GearJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_gearJoint;this.joint2=this.joint1=null;this.ratio=1};L.b2Jacobian=function(){this.linearA=new w;this.linearB=new w};L.prototype.SetZero=function(){this.linearA.SetZero();
this.angularA=0;this.linearB.SetZero();this.angularB=0};L.prototype.Set=function(d,h,l,j){if(h===undefined)h=0;if(j===undefined)j=0;this.linearA.SetV(d);this.angularA=h;this.linearB.SetV(l);this.angularB=j};L.prototype.Compute=function(d,h,l,j){if(h===undefined)h=0;if(j===undefined)j=0;return this.linearA.x*d.x+this.linearA.y*d.y+this.angularA*h+(this.linearB.x*l.x+this.linearB.y*l.y)+this.angularB*j};I.b2Joint=function(){this.m_edgeA=new Y;this.m_edgeB=new Y;this.m_localCenterA=new w;this.m_localCenterB=
new w};I.prototype.GetType=function(){return this.m_type};I.prototype.GetAnchorA=function(){return null};I.prototype.GetAnchorB=function(){return null};I.prototype.GetReactionForce=function(){return null};I.prototype.GetReactionTorque=function(){return 0};I.prototype.GetBodyA=function(){return this.m_bodyA};I.prototype.GetBodyB=function(){return this.m_bodyB};I.prototype.GetNext=function(){return this.m_next};I.prototype.GetUserData=function(){return this.m_userData};I.prototype.SetUserData=function(d){this.m_userData=
d};I.prototype.IsActive=function(){return this.m_bodyA.IsActive()&&this.m_bodyB.IsActive()};I.Create=function(d){var h=null;switch(d.type){case I.e_distanceJoint:h=new U(d instanceof p?d:null);break;case I.e_mouseJoint:h=new u(d instanceof D?d:null);break;case I.e_prismaticJoint:h=new H(d instanceof O?d:null);break;case I.e_revoluteJoint:h=new N(d instanceof S?d:null);break;case I.e_pulleyJoint:h=new E(d instanceof R?d:null);break;case I.e_gearJoint:h=new V(d instanceof M?d:null);break;case I.e_lineJoint:h=
new k(d instanceof z?d:null);break;case I.e_weldJoint:h=new aa(d instanceof Z?d:null);break;case I.e_frictionJoint:h=new B(d instanceof Q?d:null)}return h};I.Destroy=function(){};I.prototype.b2Joint=function(d){F.b2Assert(d.bodyA!=d.bodyB);this.m_type=d.type;this.m_next=this.m_prev=null;this.m_bodyA=d.bodyA;this.m_bodyB=d.bodyB;this.m_collideConnected=d.collideConnected;this.m_islandFlag=false;this.m_userData=d.userData};I.prototype.InitVelocityConstraints=function(){};I.prototype.SolveVelocityConstraints=
function(){};I.prototype.FinalizeVelocityConstraints=function(){};I.prototype.SolvePositionConstraints=function(){return false};Box2D.postDefs.push(function(){Box2D.Dynamics.Joints.b2Joint.e_unknownJoint=0;Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint=1;Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint=2;Box2D.Dynamics.Joints.b2Joint.e_distanceJoint=3;Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint=4;Box2D.Dynamics.Joints.b2Joint.e_mouseJoint=5;Box2D.Dynamics.Joints.b2Joint.e_gearJoint=6;Box2D.Dynamics.Joints.b2Joint.e_lineJoint=
7;Box2D.Dynamics.Joints.b2Joint.e_weldJoint=8;Box2D.Dynamics.Joints.b2Joint.e_frictionJoint=9;Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit=0;Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit=1;Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit=2;Box2D.Dynamics.Joints.b2Joint.e_equalLimits=3});W.b2JointDef=function(){};W.prototype.b2JointDef=function(){this.type=I.e_unknownJoint;this.bodyB=this.bodyA=this.userData=null;this.collideConnected=false};Y.b2JointEdge=function(){};Box2D.inherit(k,Box2D.Dynamics.Joints.b2Joint);
k.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;k.b2LineJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_localAnchor1=new w;this.m_localAnchor2=new w;this.m_localXAxis1=new w;this.m_localYAxis1=new w;this.m_axis=new w;this.m_perp=new w;this.m_K=new G;this.m_impulse=new w};k.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)};k.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)};k.prototype.GetReactionForce=
function(d){if(d===undefined)d=0;return new w(d*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.x),d*(this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.y))};k.prototype.GetReactionTorque=function(d){if(d===undefined)d=0;return d*this.m_impulse.y};k.prototype.GetJointTranslation=function(){var d=this.m_bodyA,h=this.m_bodyB,l=d.GetWorldPoint(this.m_localAnchor1),j=h.GetWorldPoint(this.m_localAnchor2);h=j.x-l.x;l=j.y-l.y;d=d.GetWorldVector(this.m_localXAxis1);
return d.x*h+d.y*l};k.prototype.GetJointSpeed=function(){var d=this.m_bodyA,h=this.m_bodyB,l;l=d.m_xf.R;var j=this.m_localAnchor1.x-d.m_sweep.localCenter.x,o=this.m_localAnchor1.y-d.m_sweep.localCenter.y,q=l.col1.x*j+l.col2.x*o;o=l.col1.y*j+l.col2.y*o;j=q;l=h.m_xf.R;var n=this.m_localAnchor2.x-h.m_sweep.localCenter.x,a=this.m_localAnchor2.y-h.m_sweep.localCenter.y;q=l.col1.x*n+l.col2.x*a;a=l.col1.y*n+l.col2.y*a;n=q;l=h.m_sweep.c.x+n-(d.m_sweep.c.x+j);q=h.m_sweep.c.y+a-(d.m_sweep.c.y+o);var c=d.GetWorldVector(this.m_localXAxis1),
g=d.m_linearVelocity,b=h.m_linearVelocity;d=d.m_angularVelocity;h=h.m_angularVelocity;return l*-d*c.y+q*d*c.x+(c.x*(b.x+-h*a-g.x- -d*o)+c.y*(b.y+h*n-g.y-d*j))};k.prototype.IsLimitEnabled=function(){return this.m_enableLimit};k.prototype.EnableLimit=function(d){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableLimit=d};k.prototype.GetLowerLimit=function(){return this.m_lowerTranslation};k.prototype.GetUpperLimit=function(){return this.m_upperTranslation};k.prototype.SetLimits=function(d,
h){if(d===undefined)d=0;if(h===undefined)h=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_lowerTranslation=d;this.m_upperTranslation=h};k.prototype.IsMotorEnabled=function(){return this.m_enableMotor};k.prototype.EnableMotor=function(d){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableMotor=d};k.prototype.SetMotorSpeed=function(d){if(d===undefined)d=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_motorSpeed=d};k.prototype.GetMotorSpeed=function(){return this.m_motorSpeed};
k.prototype.SetMaxMotorForce=function(d){if(d===undefined)d=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_maxMotorForce=d};k.prototype.GetMaxMotorForce=function(){return this.m_maxMotorForce};k.prototype.GetMotorForce=function(){return this.m_motorImpulse};k.prototype.b2LineJoint=function(d){this.__super.b2Joint.call(this,d);this.m_localAnchor1.SetV(d.localAnchorA);this.m_localAnchor2.SetV(d.localAnchorB);this.m_localXAxis1.SetV(d.localAxisA);this.m_localYAxis1.x=-this.m_localXAxis1.y;
this.m_localYAxis1.y=this.m_localXAxis1.x;this.m_impulse.SetZero();this.m_motorImpulse=this.m_motorMass=0;this.m_lowerTranslation=d.lowerTranslation;this.m_upperTranslation=d.upperTranslation;this.m_maxMotorForce=d.maxMotorForce;this.m_motorSpeed=d.motorSpeed;this.m_enableLimit=d.enableLimit;this.m_enableMotor=d.enableMotor;this.m_limitState=I.e_inactiveLimit;this.m_axis.SetZero();this.m_perp.SetZero()};k.prototype.InitVelocityConstraints=function(d){var h=this.m_bodyA,l=this.m_bodyB,j,o=0;this.m_localCenterA.SetV(h.GetLocalCenter());
this.m_localCenterB.SetV(l.GetLocalCenter());var q=h.GetTransform();l.GetTransform();j=h.m_xf.R;var n=this.m_localAnchor1.x-this.m_localCenterA.x,a=this.m_localAnchor1.y-this.m_localCenterA.y;o=j.col1.x*n+j.col2.x*a;a=j.col1.y*n+j.col2.y*a;n=o;j=l.m_xf.R;var c=this.m_localAnchor2.x-this.m_localCenterB.x,g=this.m_localAnchor2.y-this.m_localCenterB.y;o=j.col1.x*c+j.col2.x*g;g=j.col1.y*c+j.col2.y*g;c=o;j=l.m_sweep.c.x+c-h.m_sweep.c.x-n;o=l.m_sweep.c.y+g-h.m_sweep.c.y-a;this.m_invMassA=h.m_invMass;this.m_invMassB=
l.m_invMass;this.m_invIA=h.m_invI;this.m_invIB=l.m_invI;this.m_axis.SetV(y.MulMV(q.R,this.m_localXAxis1));this.m_a1=(j+n)*this.m_axis.y-(o+a)*this.m_axis.x;this.m_a2=c*this.m_axis.y-g*this.m_axis.x;this.m_motorMass=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_a1*this.m_a1+this.m_invIB*this.m_a2*this.m_a2;this.m_motorMass=this.m_motorMass>Number.MIN_VALUE?1/this.m_motorMass:0;this.m_perp.SetV(y.MulMV(q.R,this.m_localYAxis1));this.m_s1=(j+n)*this.m_perp.y-(o+a)*this.m_perp.x;this.m_s2=c*this.m_perp.y-
g*this.m_perp.x;q=this.m_invMassA;n=this.m_invMassB;a=this.m_invIA;c=this.m_invIB;this.m_K.col1.x=q+n+a*this.m_s1*this.m_s1+c*this.m_s2*this.m_s2;this.m_K.col1.y=a*this.m_s1*this.m_a1+c*this.m_s2*this.m_a2;this.m_K.col2.x=this.m_K.col1.y;this.m_K.col2.y=q+n+a*this.m_a1*this.m_a1+c*this.m_a2*this.m_a2;if(this.m_enableLimit){j=this.m_axis.x*j+this.m_axis.y*o;if(y.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2*F.b2_linearSlop)this.m_limitState=I.e_equalLimits;else if(j<=this.m_lowerTranslation){if(this.m_limitState!=
I.e_atLowerLimit){this.m_limitState=I.e_atLowerLimit;this.m_impulse.y=0}}else if(j>=this.m_upperTranslation){if(this.m_limitState!=I.e_atUpperLimit){this.m_limitState=I.e_atUpperLimit;this.m_impulse.y=0}}else{this.m_limitState=I.e_inactiveLimit;this.m_impulse.y=0}}else this.m_limitState=I.e_inactiveLimit;if(this.m_enableMotor==false)this.m_motorImpulse=0;if(d.warmStarting){this.m_impulse.x*=d.dtRatio;this.m_impulse.y*=d.dtRatio;this.m_motorImpulse*=d.dtRatio;d=this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+
this.m_impulse.y)*this.m_axis.x;j=this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.y)*this.m_axis.y;o=this.m_impulse.x*this.m_s1+(this.m_motorImpulse+this.m_impulse.y)*this.m_a1;q=this.m_impulse.x*this.m_s2+(this.m_motorImpulse+this.m_impulse.y)*this.m_a2;h.m_linearVelocity.x-=this.m_invMassA*d;h.m_linearVelocity.y-=this.m_invMassA*j;h.m_angularVelocity-=this.m_invIA*o;l.m_linearVelocity.x+=this.m_invMassB*d;l.m_linearVelocity.y+=this.m_invMassB*j;l.m_angularVelocity+=this.m_invIB*
q}else{this.m_impulse.SetZero();this.m_motorImpulse=0}};k.prototype.SolveVelocityConstraints=function(d){var h=this.m_bodyA,l=this.m_bodyB,j=h.m_linearVelocity,o=h.m_angularVelocity,q=l.m_linearVelocity,n=l.m_angularVelocity,a=0,c=0,g=0,b=0;if(this.m_enableMotor&&this.m_limitState!=I.e_equalLimits){b=this.m_motorMass*(this.m_motorSpeed-(this.m_axis.x*(q.x-j.x)+this.m_axis.y*(q.y-j.y)+this.m_a2*n-this.m_a1*o));a=this.m_motorImpulse;c=d.dt*this.m_maxMotorForce;this.m_motorImpulse=y.Clamp(this.m_motorImpulse+
b,-c,c);b=this.m_motorImpulse-a;a=b*this.m_axis.x;c=b*this.m_axis.y;g=b*this.m_a1;b=b*this.m_a2;j.x-=this.m_invMassA*a;j.y-=this.m_invMassA*c;o-=this.m_invIA*g;q.x+=this.m_invMassB*a;q.y+=this.m_invMassB*c;n+=this.m_invIB*b}c=this.m_perp.x*(q.x-j.x)+this.m_perp.y*(q.y-j.y)+this.m_s2*n-this.m_s1*o;if(this.m_enableLimit&&this.m_limitState!=I.e_inactiveLimit){g=this.m_axis.x*(q.x-j.x)+this.m_axis.y*(q.y-j.y)+this.m_a2*n-this.m_a1*o;a=this.m_impulse.Copy();d=this.m_K.Solve(new w,-c,-g);this.m_impulse.Add(d);
if(this.m_limitState==I.e_atLowerLimit)this.m_impulse.y=y.Max(this.m_impulse.y,0);else if(this.m_limitState==I.e_atUpperLimit)this.m_impulse.y=y.Min(this.m_impulse.y,0);c=-c-(this.m_impulse.y-a.y)*this.m_K.col2.x;g=0;g=this.m_K.col1.x!=0?c/this.m_K.col1.x+a.x:a.x;this.m_impulse.x=g;d.x=this.m_impulse.x-a.x;d.y=this.m_impulse.y-a.y;a=d.x*this.m_perp.x+d.y*this.m_axis.x;c=d.x*this.m_perp.y+d.y*this.m_axis.y;g=d.x*this.m_s1+d.y*this.m_a1;b=d.x*this.m_s2+d.y*this.m_a2}else{d=0;d=this.m_K.col1.x!=0?-c/
this.m_K.col1.x:0;this.m_impulse.x+=d;a=d*this.m_perp.x;c=d*this.m_perp.y;g=d*this.m_s1;b=d*this.m_s2}j.x-=this.m_invMassA*a;j.y-=this.m_invMassA*c;o-=this.m_invIA*g;q.x+=this.m_invMassB*a;q.y+=this.m_invMassB*c;n+=this.m_invIB*b;h.m_linearVelocity.SetV(j);h.m_angularVelocity=o;l.m_linearVelocity.SetV(q);l.m_angularVelocity=n};k.prototype.SolvePositionConstraints=function(){var d=this.m_bodyA,h=this.m_bodyB,l=d.m_sweep.c,j=d.m_sweep.a,o=h.m_sweep.c,q=h.m_sweep.a,n,a=0,c=0,g=0,b=0,e=n=0,f=0;c=false;
var m=0,r=G.FromAngle(j);g=G.FromAngle(q);n=r;f=this.m_localAnchor1.x-this.m_localCenterA.x;var s=this.m_localAnchor1.y-this.m_localCenterA.y;a=n.col1.x*f+n.col2.x*s;s=n.col1.y*f+n.col2.y*s;f=a;n=g;g=this.m_localAnchor2.x-this.m_localCenterB.x;b=this.m_localAnchor2.y-this.m_localCenterB.y;a=n.col1.x*g+n.col2.x*b;b=n.col1.y*g+n.col2.y*b;g=a;n=o.x+g-l.x-f;a=o.y+b-l.y-s;if(this.m_enableLimit){this.m_axis=y.MulMV(r,this.m_localXAxis1);this.m_a1=(n+f)*this.m_axis.y-(a+s)*this.m_axis.x;this.m_a2=g*this.m_axis.y-
b*this.m_axis.x;var v=this.m_axis.x*n+this.m_axis.y*a;if(y.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2*F.b2_linearSlop){m=y.Clamp(v,-F.b2_maxLinearCorrection,F.b2_maxLinearCorrection);e=y.Abs(v);c=true}else if(v<=this.m_lowerTranslation){m=y.Clamp(v-this.m_lowerTranslation+F.b2_linearSlop,-F.b2_maxLinearCorrection,0);e=this.m_lowerTranslation-v;c=true}else if(v>=this.m_upperTranslation){m=y.Clamp(v-this.m_upperTranslation+F.b2_linearSlop,0,F.b2_maxLinearCorrection);e=v-this.m_upperTranslation;
c=true}}this.m_perp=y.MulMV(r,this.m_localYAxis1);this.m_s1=(n+f)*this.m_perp.y-(a+s)*this.m_perp.x;this.m_s2=g*this.m_perp.y-b*this.m_perp.x;r=new w;s=this.m_perp.x*n+this.m_perp.y*a;e=y.Max(e,y.Abs(s));f=0;if(c){c=this.m_invMassA;g=this.m_invMassB;b=this.m_invIA;n=this.m_invIB;this.m_K.col1.x=c+g+b*this.m_s1*this.m_s1+n*this.m_s2*this.m_s2;this.m_K.col1.y=b*this.m_s1*this.m_a1+n*this.m_s2*this.m_a2;this.m_K.col2.x=this.m_K.col1.y;this.m_K.col2.y=c+g+b*this.m_a1*this.m_a1+n*this.m_a2*this.m_a2;this.m_K.Solve(r,
-s,-m)}else{c=this.m_invMassA;g=this.m_invMassB;b=this.m_invIA;n=this.m_invIB;m=c+g+b*this.m_s1*this.m_s1+n*this.m_s2*this.m_s2;c=0;c=m!=0?-s/m:0;r.x=c;r.y=0}m=r.x*this.m_perp.x+r.y*this.m_axis.x;c=r.x*this.m_perp.y+r.y*this.m_axis.y;s=r.x*this.m_s1+r.y*this.m_a1;r=r.x*this.m_s2+r.y*this.m_a2;l.x-=this.m_invMassA*m;l.y-=this.m_invMassA*c;j-=this.m_invIA*s;o.x+=this.m_invMassB*m;o.y+=this.m_invMassB*c;q+=this.m_invIB*r;d.m_sweep.a=j;h.m_sweep.a=q;d.SynchronizeTransform();h.SynchronizeTransform();return e<=
F.b2_linearSlop&&f<=F.b2_angularSlop};Box2D.inherit(z,Box2D.Dynamics.Joints.b2JointDef);z.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;z.b2LineJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.localAnchorA=new w;this.localAnchorB=new w;this.localAxisA=new w};z.prototype.b2LineJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_lineJoint;this.localAxisA.Set(1,0);this.enableLimit=false;this.upperTranslation=this.lowerTranslation=
0;this.enableMotor=false;this.motorSpeed=this.maxMotorForce=0};z.prototype.Initialize=function(d,h,l,j){this.bodyA=d;this.bodyB=h;this.localAnchorA=this.bodyA.GetLocalPoint(l);this.localAnchorB=this.bodyB.GetLocalPoint(l);this.localAxisA=this.bodyA.GetLocalVector(j)};Box2D.inherit(u,Box2D.Dynamics.Joints.b2Joint);u.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;u.b2MouseJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.K=new G;this.K1=new G;this.K2=new G;
this.m_localAnchor=new w;this.m_target=new w;this.m_impulse=new w;this.m_mass=new G;this.m_C=new w};u.prototype.GetAnchorA=function(){return this.m_target};u.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor)};u.prototype.GetReactionForce=function(d){if(d===undefined)d=0;return new w(d*this.m_impulse.x,d*this.m_impulse.y)};u.prototype.GetReactionTorque=function(){return 0};u.prototype.GetTarget=function(){return this.m_target};u.prototype.SetTarget=function(d){this.m_bodyB.IsAwake()==
false&&this.m_bodyB.SetAwake(true);this.m_target=d};u.prototype.GetMaxForce=function(){return this.m_maxForce};u.prototype.SetMaxForce=function(d){if(d===undefined)d=0;this.m_maxForce=d};u.prototype.GetFrequency=function(){return this.m_frequencyHz};u.prototype.SetFrequency=function(d){if(d===undefined)d=0;this.m_frequencyHz=d};u.prototype.GetDampingRatio=function(){return this.m_dampingRatio};u.prototype.SetDampingRatio=function(d){if(d===undefined)d=0;this.m_dampingRatio=d};u.prototype.b2MouseJoint=
function(d){this.__super.b2Joint.call(this,d);this.m_target.SetV(d.target);var h=this.m_target.x-this.m_bodyB.m_xf.position.x,l=this.m_target.y-this.m_bodyB.m_xf.position.y,j=this.m_bodyB.m_xf.R;this.m_localAnchor.x=h*j.col1.x+l*j.col1.y;this.m_localAnchor.y=h*j.col2.x+l*j.col2.y;this.m_maxForce=d.maxForce;this.m_impulse.SetZero();this.m_frequencyHz=d.frequencyHz;this.m_dampingRatio=d.dampingRatio;this.m_gamma=this.m_beta=0};u.prototype.InitVelocityConstraints=function(d){var h=this.m_bodyB,l=h.GetMass(),
j=2*Math.PI*this.m_frequencyHz,o=l*j*j;this.m_gamma=d.dt*(2*l*this.m_dampingRatio*j+d.dt*o);this.m_gamma=this.m_gamma!=0?1/this.m_gamma:0;this.m_beta=d.dt*o*this.m_gamma;o=h.m_xf.R;l=this.m_localAnchor.x-h.m_sweep.localCenter.x;j=this.m_localAnchor.y-h.m_sweep.localCenter.y;var q=o.col1.x*l+o.col2.x*j;j=o.col1.y*l+o.col2.y*j;l=q;o=h.m_invMass;q=h.m_invI;this.K1.col1.x=o;this.K1.col2.x=0;this.K1.col1.y=0;this.K1.col2.y=o;this.K2.col1.x=q*j*j;this.K2.col2.x=-q*l*j;this.K2.col1.y=-q*l*j;this.K2.col2.y=
q*l*l;this.K.SetM(this.K1);this.K.AddM(this.K2);this.K.col1.x+=this.m_gamma;this.K.col2.y+=this.m_gamma;this.K.GetInverse(this.m_mass);this.m_C.x=h.m_sweep.c.x+l-this.m_target.x;this.m_C.y=h.m_sweep.c.y+j-this.m_target.y;h.m_angularVelocity*=0.98;this.m_impulse.x*=d.dtRatio;this.m_impulse.y*=d.dtRatio;h.m_linearVelocity.x+=o*this.m_impulse.x;h.m_linearVelocity.y+=o*this.m_impulse.y;h.m_angularVelocity+=q*(l*this.m_impulse.y-j*this.m_impulse.x)};u.prototype.SolveVelocityConstraints=function(d){var h=
this.m_bodyB,l,j=0,o=0;l=h.m_xf.R;var q=this.m_localAnchor.x-h.m_sweep.localCenter.x,n=this.m_localAnchor.y-h.m_sweep.localCenter.y;j=l.col1.x*q+l.col2.x*n;n=l.col1.y*q+l.col2.y*n;q=j;j=h.m_linearVelocity.x+-h.m_angularVelocity*n;var a=h.m_linearVelocity.y+h.m_angularVelocity*q;l=this.m_mass;j=j+this.m_beta*this.m_C.x+this.m_gamma*this.m_impulse.x;o=a+this.m_beta*this.m_C.y+this.m_gamma*this.m_impulse.y;a=-(l.col1.x*j+l.col2.x*o);o=-(l.col1.y*j+l.col2.y*o);l=this.m_impulse.x;j=this.m_impulse.y;this.m_impulse.x+=
a;this.m_impulse.y+=o;d=d.dt*this.m_maxForce;this.m_impulse.LengthSquared()>d*d&&this.m_impulse.Multiply(d/this.m_impulse.Length());a=this.m_impulse.x-l;o=this.m_impulse.y-j;h.m_linearVelocity.x+=h.m_invMass*a;h.m_linearVelocity.y+=h.m_invMass*o;h.m_angularVelocity+=h.m_invI*(q*o-n*a)};u.prototype.SolvePositionConstraints=function(){return true};Box2D.inherit(D,Box2D.Dynamics.Joints.b2JointDef);D.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;D.b2MouseJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,
arguments);this.target=new w};D.prototype.b2MouseJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_mouseJoint;this.maxForce=0;this.frequencyHz=5;this.dampingRatio=0.7};Box2D.inherit(H,Box2D.Dynamics.Joints.b2Joint);H.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;H.b2PrismaticJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_localAnchor1=new w;this.m_localAnchor2=new w;this.m_localXAxis1=new w;this.m_localYAxis1=new w;this.m_axis=new w;
this.m_perp=new w;this.m_K=new K;this.m_impulse=new A};H.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)};H.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)};H.prototype.GetReactionForce=function(d){if(d===undefined)d=0;return new w(d*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.x),d*(this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.y))};H.prototype.GetReactionTorque=
function(d){if(d===undefined)d=0;return d*this.m_impulse.y};H.prototype.GetJointTranslation=function(){var d=this.m_bodyA,h=this.m_bodyB,l=d.GetWorldPoint(this.m_localAnchor1),j=h.GetWorldPoint(this.m_localAnchor2);h=j.x-l.x;l=j.y-l.y;d=d.GetWorldVector(this.m_localXAxis1);return d.x*h+d.y*l};H.prototype.GetJointSpeed=function(){var d=this.m_bodyA,h=this.m_bodyB,l;l=d.m_xf.R;var j=this.m_localAnchor1.x-d.m_sweep.localCenter.x,o=this.m_localAnchor1.y-d.m_sweep.localCenter.y,q=l.col1.x*j+l.col2.x*o;
o=l.col1.y*j+l.col2.y*o;j=q;l=h.m_xf.R;var n=this.m_localAnchor2.x-h.m_sweep.localCenter.x,a=this.m_localAnchor2.y-h.m_sweep.localCenter.y;q=l.col1.x*n+l.col2.x*a;a=l.col1.y*n+l.col2.y*a;n=q;l=h.m_sweep.c.x+n-(d.m_sweep.c.x+j);q=h.m_sweep.c.y+a-(d.m_sweep.c.y+o);var c=d.GetWorldVector(this.m_localXAxis1),g=d.m_linearVelocity,b=h.m_linearVelocity;d=d.m_angularVelocity;h=h.m_angularVelocity;return l*-d*c.y+q*d*c.x+(c.x*(b.x+-h*a-g.x- -d*o)+c.y*(b.y+h*n-g.y-d*j))};H.prototype.IsLimitEnabled=function(){return this.m_enableLimit};
H.prototype.EnableLimit=function(d){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableLimit=d};H.prototype.GetLowerLimit=function(){return this.m_lowerTranslation};H.prototype.GetUpperLimit=function(){return this.m_upperTranslation};H.prototype.SetLimits=function(d,h){if(d===undefined)d=0;if(h===undefined)h=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_lowerTranslation=d;this.m_upperTranslation=h};H.prototype.IsMotorEnabled=function(){return this.m_enableMotor};
H.prototype.EnableMotor=function(d){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableMotor=d};H.prototype.SetMotorSpeed=function(d){if(d===undefined)d=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_motorSpeed=d};H.prototype.GetMotorSpeed=function(){return this.m_motorSpeed};H.prototype.SetMaxMotorForce=function(d){if(d===undefined)d=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_maxMotorForce=d};H.prototype.GetMotorForce=function(){return this.m_motorImpulse};
H.prototype.b2PrismaticJoint=function(d){this.__super.b2Joint.call(this,d);this.m_localAnchor1.SetV(d.localAnchorA);this.m_localAnchor2.SetV(d.localAnchorB);this.m_localXAxis1.SetV(d.localAxisA);this.m_localYAxis1.x=-this.m_localXAxis1.y;this.m_localYAxis1.y=this.m_localXAxis1.x;this.m_refAngle=d.referenceAngle;this.m_impulse.SetZero();this.m_motorImpulse=this.m_motorMass=0;this.m_lowerTranslation=d.lowerTranslation;this.m_upperTranslation=d.upperTranslation;this.m_maxMotorForce=d.maxMotorForce;this.m_motorSpeed=
d.motorSpeed;this.m_enableLimit=d.enableLimit;this.m_enableMotor=d.enableMotor;this.m_limitState=I.e_inactiveLimit;this.m_axis.SetZero();this.m_perp.SetZero()};H.prototype.InitVelocityConstraints=function(d){var h=this.m_bodyA,l=this.m_bodyB,j,o=0;this.m_localCenterA.SetV(h.GetLocalCenter());this.m_localCenterB.SetV(l.GetLocalCenter());var q=h.GetTransform();l.GetTransform();j=h.m_xf.R;var n=this.m_localAnchor1.x-this.m_localCenterA.x,a=this.m_localAnchor1.y-this.m_localCenterA.y;o=j.col1.x*n+j.col2.x*
a;a=j.col1.y*n+j.col2.y*a;n=o;j=l.m_xf.R;var c=this.m_localAnchor2.x-this.m_localCenterB.x,g=this.m_localAnchor2.y-this.m_localCenterB.y;o=j.col1.x*c+j.col2.x*g;g=j.col1.y*c+j.col2.y*g;c=o;j=l.m_sweep.c.x+c-h.m_sweep.c.x-n;o=l.m_sweep.c.y+g-h.m_sweep.c.y-a;this.m_invMassA=h.m_invMass;this.m_invMassB=l.m_invMass;this.m_invIA=h.m_invI;this.m_invIB=l.m_invI;this.m_axis.SetV(y.MulMV(q.R,this.m_localXAxis1));this.m_a1=(j+n)*this.m_axis.y-(o+a)*this.m_axis.x;this.m_a2=c*this.m_axis.y-g*this.m_axis.x;this.m_motorMass=
this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_a1*this.m_a1+this.m_invIB*this.m_a2*this.m_a2;if(this.m_motorMass>Number.MIN_VALUE)this.m_motorMass=1/this.m_motorMass;this.m_perp.SetV(y.MulMV(q.R,this.m_localYAxis1));this.m_s1=(j+n)*this.m_perp.y-(o+a)*this.m_perp.x;this.m_s2=c*this.m_perp.y-g*this.m_perp.x;q=this.m_invMassA;n=this.m_invMassB;a=this.m_invIA;c=this.m_invIB;this.m_K.col1.x=q+n+a*this.m_s1*this.m_s1+c*this.m_s2*this.m_s2;this.m_K.col1.y=a*this.m_s1+c*this.m_s2;this.m_K.col1.z=a*
this.m_s1*this.m_a1+c*this.m_s2*this.m_a2;this.m_K.col2.x=this.m_K.col1.y;this.m_K.col2.y=a+c;this.m_K.col2.z=a*this.m_a1+c*this.m_a2;this.m_K.col3.x=this.m_K.col1.z;this.m_K.col3.y=this.m_K.col2.z;this.m_K.col3.z=q+n+a*this.m_a1*this.m_a1+c*this.m_a2*this.m_a2;if(this.m_enableLimit){j=this.m_axis.x*j+this.m_axis.y*o;if(y.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2*F.b2_linearSlop)this.m_limitState=I.e_equalLimits;else if(j<=this.m_lowerTranslation){if(this.m_limitState!=I.e_atLowerLimit){this.m_limitState=
I.e_atLowerLimit;this.m_impulse.z=0}}else if(j>=this.m_upperTranslation){if(this.m_limitState!=I.e_atUpperLimit){this.m_limitState=I.e_atUpperLimit;this.m_impulse.z=0}}else{this.m_limitState=I.e_inactiveLimit;this.m_impulse.z=0}}else this.m_limitState=I.e_inactiveLimit;if(this.m_enableMotor==false)this.m_motorImpulse=0;if(d.warmStarting){this.m_impulse.x*=d.dtRatio;this.m_impulse.y*=d.dtRatio;this.m_motorImpulse*=d.dtRatio;d=this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.x;
j=this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.y;o=this.m_impulse.x*this.m_s1+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a1;q=this.m_impulse.x*this.m_s2+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a2;h.m_linearVelocity.x-=this.m_invMassA*d;h.m_linearVelocity.y-=this.m_invMassA*j;h.m_angularVelocity-=this.m_invIA*o;l.m_linearVelocity.x+=this.m_invMassB*d;l.m_linearVelocity.y+=this.m_invMassB*j;l.m_angularVelocity+=this.m_invIB*
q}else{this.m_impulse.SetZero();this.m_motorImpulse=0}};H.prototype.SolveVelocityConstraints=function(d){var h=this.m_bodyA,l=this.m_bodyB,j=h.m_linearVelocity,o=h.m_angularVelocity,q=l.m_linearVelocity,n=l.m_angularVelocity,a=0,c=0,g=0,b=0;if(this.m_enableMotor&&this.m_limitState!=I.e_equalLimits){b=this.m_motorMass*(this.m_motorSpeed-(this.m_axis.x*(q.x-j.x)+this.m_axis.y*(q.y-j.y)+this.m_a2*n-this.m_a1*o));a=this.m_motorImpulse;d=d.dt*this.m_maxMotorForce;this.m_motorImpulse=y.Clamp(this.m_motorImpulse+
b,-d,d);b=this.m_motorImpulse-a;a=b*this.m_axis.x;c=b*this.m_axis.y;g=b*this.m_a1;b=b*this.m_a2;j.x-=this.m_invMassA*a;j.y-=this.m_invMassA*c;o-=this.m_invIA*g;q.x+=this.m_invMassB*a;q.y+=this.m_invMassB*c;n+=this.m_invIB*b}g=this.m_perp.x*(q.x-j.x)+this.m_perp.y*(q.y-j.y)+this.m_s2*n-this.m_s1*o;c=n-o;if(this.m_enableLimit&&this.m_limitState!=I.e_inactiveLimit){d=this.m_axis.x*(q.x-j.x)+this.m_axis.y*(q.y-j.y)+this.m_a2*n-this.m_a1*o;a=this.m_impulse.Copy();d=this.m_K.Solve33(new A,-g,-c,-d);this.m_impulse.Add(d);
if(this.m_limitState==I.e_atLowerLimit)this.m_impulse.z=y.Max(this.m_impulse.z,0);else if(this.m_limitState==I.e_atUpperLimit)this.m_impulse.z=y.Min(this.m_impulse.z,0);g=-g-(this.m_impulse.z-a.z)*this.m_K.col3.x;c=-c-(this.m_impulse.z-a.z)*this.m_K.col3.y;c=this.m_K.Solve22(new w,g,c);c.x+=a.x;c.y+=a.y;this.m_impulse.x=c.x;this.m_impulse.y=c.y;d.x=this.m_impulse.x-a.x;d.y=this.m_impulse.y-a.y;d.z=this.m_impulse.z-a.z;a=d.x*this.m_perp.x+d.z*this.m_axis.x;c=d.x*this.m_perp.y+d.z*this.m_axis.y;g=d.x*
this.m_s1+d.y+d.z*this.m_a1;b=d.x*this.m_s2+d.y+d.z*this.m_a2}else{d=this.m_K.Solve22(new w,-g,-c);this.m_impulse.x+=d.x;this.m_impulse.y+=d.y;a=d.x*this.m_perp.x;c=d.x*this.m_perp.y;g=d.x*this.m_s1+d.y;b=d.x*this.m_s2+d.y}j.x-=this.m_invMassA*a;j.y-=this.m_invMassA*c;o-=this.m_invIA*g;q.x+=this.m_invMassB*a;q.y+=this.m_invMassB*c;n+=this.m_invIB*b;h.m_linearVelocity.SetV(j);h.m_angularVelocity=o;l.m_linearVelocity.SetV(q);l.m_angularVelocity=n};H.prototype.SolvePositionConstraints=function(){var d=
this.m_bodyA,h=this.m_bodyB,l=d.m_sweep.c,j=d.m_sweep.a,o=h.m_sweep.c,q=h.m_sweep.a,n,a=0,c=0,g=0,b=a=n=0,e=0;c=false;var f=0,m=G.FromAngle(j),r=G.FromAngle(q);n=m;e=this.m_localAnchor1.x-this.m_localCenterA.x;var s=this.m_localAnchor1.y-this.m_localCenterA.y;a=n.col1.x*e+n.col2.x*s;s=n.col1.y*e+n.col2.y*s;e=a;n=r;r=this.m_localAnchor2.x-this.m_localCenterB.x;g=this.m_localAnchor2.y-this.m_localCenterB.y;a=n.col1.x*r+n.col2.x*g;g=n.col1.y*r+n.col2.y*g;r=a;n=o.x+r-l.x-e;a=o.y+g-l.y-s;if(this.m_enableLimit){this.m_axis=
y.MulMV(m,this.m_localXAxis1);this.m_a1=(n+e)*this.m_axis.y-(a+s)*this.m_axis.x;this.m_a2=r*this.m_axis.y-g*this.m_axis.x;var v=this.m_axis.x*n+this.m_axis.y*a;if(y.Abs(this.m_upperTranslation-this.m_lowerTranslation)<2*F.b2_linearSlop){f=y.Clamp(v,-F.b2_maxLinearCorrection,F.b2_maxLinearCorrection);b=y.Abs(v);c=true}else if(v<=this.m_lowerTranslation){f=y.Clamp(v-this.m_lowerTranslation+F.b2_linearSlop,-F.b2_maxLinearCorrection,0);b=this.m_lowerTranslation-v;c=true}else if(v>=this.m_upperTranslation){f=
y.Clamp(v-this.m_upperTranslation+F.b2_linearSlop,0,F.b2_maxLinearCorrection);b=v-this.m_upperTranslation;c=true}}this.m_perp=y.MulMV(m,this.m_localYAxis1);this.m_s1=(n+e)*this.m_perp.y-(a+s)*this.m_perp.x;this.m_s2=r*this.m_perp.y-g*this.m_perp.x;m=new A;s=this.m_perp.x*n+this.m_perp.y*a;r=q-j-this.m_refAngle;b=y.Max(b,y.Abs(s));e=y.Abs(r);if(c){c=this.m_invMassA;g=this.m_invMassB;n=this.m_invIA;a=this.m_invIB;this.m_K.col1.x=c+g+n*this.m_s1*this.m_s1+a*this.m_s2*this.m_s2;this.m_K.col1.y=n*this.m_s1+
a*this.m_s2;this.m_K.col1.z=n*this.m_s1*this.m_a1+a*this.m_s2*this.m_a2;this.m_K.col2.x=this.m_K.col1.y;this.m_K.col2.y=n+a;this.m_K.col2.z=n*this.m_a1+a*this.m_a2;this.m_K.col3.x=this.m_K.col1.z;this.m_K.col3.y=this.m_K.col2.z;this.m_K.col3.z=c+g+n*this.m_a1*this.m_a1+a*this.m_a2*this.m_a2;this.m_K.Solve33(m,-s,-r,-f)}else{c=this.m_invMassA;g=this.m_invMassB;n=this.m_invIA;a=this.m_invIB;f=n*this.m_s1+a*this.m_s2;v=n+a;this.m_K.col1.Set(c+g+n*this.m_s1*this.m_s1+a*this.m_s2*this.m_s2,f,0);this.m_K.col2.Set(f,
v,0);f=this.m_K.Solve22(new w,-s,-r);m.x=f.x;m.y=f.y;m.z=0}f=m.x*this.m_perp.x+m.z*this.m_axis.x;c=m.x*this.m_perp.y+m.z*this.m_axis.y;s=m.x*this.m_s1+m.y+m.z*this.m_a1;m=m.x*this.m_s2+m.y+m.z*this.m_a2;l.x-=this.m_invMassA*f;l.y-=this.m_invMassA*c;j-=this.m_invIA*s;o.x+=this.m_invMassB*f;o.y+=this.m_invMassB*c;q+=this.m_invIB*m;d.m_sweep.a=j;h.m_sweep.a=q;d.SynchronizeTransform();h.SynchronizeTransform();return b<=F.b2_linearSlop&&e<=F.b2_angularSlop};Box2D.inherit(O,Box2D.Dynamics.Joints.b2JointDef);
O.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;O.b2PrismaticJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.localAnchorA=new w;this.localAnchorB=new w;this.localAxisA=new w};O.prototype.b2PrismaticJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_prismaticJoint;this.localAxisA.Set(1,0);this.referenceAngle=0;this.enableLimit=false;this.upperTranslation=this.lowerTranslation=0;this.enableMotor=false;this.motorSpeed=this.maxMotorForce=
0};O.prototype.Initialize=function(d,h,l,j){this.bodyA=d;this.bodyB=h;this.localAnchorA=this.bodyA.GetLocalPoint(l);this.localAnchorB=this.bodyB.GetLocalPoint(l);this.localAxisA=this.bodyA.GetLocalVector(j);this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()};Box2D.inherit(E,Box2D.Dynamics.Joints.b2Joint);E.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;E.b2PulleyJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_groundAnchor1=new w;this.m_groundAnchor2=
new w;this.m_localAnchor1=new w;this.m_localAnchor2=new w;this.m_u1=new w;this.m_u2=new w};E.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)};E.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)};E.prototype.GetReactionForce=function(d){if(d===undefined)d=0;return new w(d*this.m_impulse*this.m_u2.x,d*this.m_impulse*this.m_u2.y)};E.prototype.GetReactionTorque=function(){return 0};E.prototype.GetGroundAnchorA=function(){var d=
this.m_ground.m_xf.position.Copy();d.Add(this.m_groundAnchor1);return d};E.prototype.GetGroundAnchorB=function(){var d=this.m_ground.m_xf.position.Copy();d.Add(this.m_groundAnchor2);return d};E.prototype.GetLength1=function(){var d=this.m_bodyA.GetWorldPoint(this.m_localAnchor1),h=d.x-(this.m_ground.m_xf.position.x+this.m_groundAnchor1.x);d=d.y-(this.m_ground.m_xf.position.y+this.m_groundAnchor1.y);return Math.sqrt(h*h+d*d)};E.prototype.GetLength2=function(){var d=this.m_bodyB.GetWorldPoint(this.m_localAnchor2),
h=d.x-(this.m_ground.m_xf.position.x+this.m_groundAnchor2.x);d=d.y-(this.m_ground.m_xf.position.y+this.m_groundAnchor2.y);return Math.sqrt(h*h+d*d)};E.prototype.GetRatio=function(){return this.m_ratio};E.prototype.b2PulleyJoint=function(d){this.__super.b2Joint.call(this,d);this.m_ground=this.m_bodyA.m_world.m_groundBody;this.m_groundAnchor1.x=d.groundAnchorA.x-this.m_ground.m_xf.position.x;this.m_groundAnchor1.y=d.groundAnchorA.y-this.m_ground.m_xf.position.y;this.m_groundAnchor2.x=d.groundAnchorB.x-
this.m_ground.m_xf.position.x;this.m_groundAnchor2.y=d.groundAnchorB.y-this.m_ground.m_xf.position.y;this.m_localAnchor1.SetV(d.localAnchorA);this.m_localAnchor2.SetV(d.localAnchorB);this.m_ratio=d.ratio;this.m_constant=d.lengthA+this.m_ratio*d.lengthB;this.m_maxLength1=y.Min(d.maxLengthA,this.m_constant-this.m_ratio*E.b2_minPulleyLength);this.m_maxLength2=y.Min(d.maxLengthB,(this.m_constant-E.b2_minPulleyLength)/this.m_ratio);this.m_limitImpulse2=this.m_limitImpulse1=this.m_impulse=0};E.prototype.InitVelocityConstraints=
function(d){var h=this.m_bodyA,l=this.m_bodyB,j;j=h.m_xf.R;var o=this.m_localAnchor1.x-h.m_sweep.localCenter.x,q=this.m_localAnchor1.y-h.m_sweep.localCenter.y,n=j.col1.x*o+j.col2.x*q;q=j.col1.y*o+j.col2.y*q;o=n;j=l.m_xf.R;var a=this.m_localAnchor2.x-l.m_sweep.localCenter.x,c=this.m_localAnchor2.y-l.m_sweep.localCenter.y;n=j.col1.x*a+j.col2.x*c;c=j.col1.y*a+j.col2.y*c;a=n;j=l.m_sweep.c.x+a;n=l.m_sweep.c.y+c;var g=this.m_ground.m_xf.position.x+this.m_groundAnchor2.x,b=this.m_ground.m_xf.position.y+
this.m_groundAnchor2.y;this.m_u1.Set(h.m_sweep.c.x+o-(this.m_ground.m_xf.position.x+this.m_groundAnchor1.x),h.m_sweep.c.y+q-(this.m_ground.m_xf.position.y+this.m_groundAnchor1.y));this.m_u2.Set(j-g,n-b);j=this.m_u1.Length();n=this.m_u2.Length();j>F.b2_linearSlop?this.m_u1.Multiply(1/j):this.m_u1.SetZero();n>F.b2_linearSlop?this.m_u2.Multiply(1/n):this.m_u2.SetZero();if(this.m_constant-j-this.m_ratio*n>0){this.m_state=I.e_inactiveLimit;this.m_impulse=0}else this.m_state=I.e_atUpperLimit;if(j<this.m_maxLength1){this.m_limitState1=
I.e_inactiveLimit;this.m_limitImpulse1=0}else this.m_limitState1=I.e_atUpperLimit;if(n<this.m_maxLength2){this.m_limitState2=I.e_inactiveLimit;this.m_limitImpulse2=0}else this.m_limitState2=I.e_atUpperLimit;j=o*this.m_u1.y-q*this.m_u1.x;n=a*this.m_u2.y-c*this.m_u2.x;this.m_limitMass1=h.m_invMass+h.m_invI*j*j;this.m_limitMass2=l.m_invMass+l.m_invI*n*n;this.m_pulleyMass=this.m_limitMass1+this.m_ratio*this.m_ratio*this.m_limitMass2;this.m_limitMass1=1/this.m_limitMass1;this.m_limitMass2=1/this.m_limitMass2;
this.m_pulleyMass=1/this.m_pulleyMass;if(d.warmStarting){this.m_impulse*=d.dtRatio;this.m_limitImpulse1*=d.dtRatio;this.m_limitImpulse2*=d.dtRatio;d=(-this.m_impulse-this.m_limitImpulse1)*this.m_u1.x;j=(-this.m_impulse-this.m_limitImpulse1)*this.m_u1.y;n=(-this.m_ratio*this.m_impulse-this.m_limitImpulse2)*this.m_u2.x;g=(-this.m_ratio*this.m_impulse-this.m_limitImpulse2)*this.m_u2.y;h.m_linearVelocity.x+=h.m_invMass*d;h.m_linearVelocity.y+=h.m_invMass*j;h.m_angularVelocity+=h.m_invI*(o*j-q*d);l.m_linearVelocity.x+=
l.m_invMass*n;l.m_linearVelocity.y+=l.m_invMass*g;l.m_angularVelocity+=l.m_invI*(a*g-c*n)}else this.m_limitImpulse2=this.m_limitImpulse1=this.m_impulse=0};E.prototype.SolveVelocityConstraints=function(){var d=this.m_bodyA,h=this.m_bodyB,l;l=d.m_xf.R;var j=this.m_localAnchor1.x-d.m_sweep.localCenter.x,o=this.m_localAnchor1.y-d.m_sweep.localCenter.y,q=l.col1.x*j+l.col2.x*o;o=l.col1.y*j+l.col2.y*o;j=q;l=h.m_xf.R;var n=this.m_localAnchor2.x-h.m_sweep.localCenter.x,a=this.m_localAnchor2.y-h.m_sweep.localCenter.y;
q=l.col1.x*n+l.col2.x*a;a=l.col1.y*n+l.col2.y*a;n=q;var c=q=l=0,g=0;l=g=l=g=c=q=l=0;if(this.m_state==I.e_atUpperLimit){l=d.m_linearVelocity.x+-d.m_angularVelocity*o;q=d.m_linearVelocity.y+d.m_angularVelocity*j;c=h.m_linearVelocity.x+-h.m_angularVelocity*a;g=h.m_linearVelocity.y+h.m_angularVelocity*n;l=-(this.m_u1.x*l+this.m_u1.y*q)-this.m_ratio*(this.m_u2.x*c+this.m_u2.y*g);g=this.m_pulleyMass*-l;l=this.m_impulse;this.m_impulse=y.Max(0,this.m_impulse+g);g=this.m_impulse-l;l=-g*this.m_u1.x;q=-g*this.m_u1.y;
c=-this.m_ratio*g*this.m_u2.x;g=-this.m_ratio*g*this.m_u2.y;d.m_linearVelocity.x+=d.m_invMass*l;d.m_linearVelocity.y+=d.m_invMass*q;d.m_angularVelocity+=d.m_invI*(j*q-o*l);h.m_linearVelocity.x+=h.m_invMass*c;h.m_linearVelocity.y+=h.m_invMass*g;h.m_angularVelocity+=h.m_invI*(n*g-a*c)}if(this.m_limitState1==I.e_atUpperLimit){l=d.m_linearVelocity.x+-d.m_angularVelocity*o;q=d.m_linearVelocity.y+d.m_angularVelocity*j;l=-(this.m_u1.x*l+this.m_u1.y*q);g=-this.m_limitMass1*l;l=this.m_limitImpulse1;this.m_limitImpulse1=
y.Max(0,this.m_limitImpulse1+g);g=this.m_limitImpulse1-l;l=-g*this.m_u1.x;q=-g*this.m_u1.y;d.m_linearVelocity.x+=d.m_invMass*l;d.m_linearVelocity.y+=d.m_invMass*q;d.m_angularVelocity+=d.m_invI*(j*q-o*l)}if(this.m_limitState2==I.e_atUpperLimit){c=h.m_linearVelocity.x+-h.m_angularVelocity*a;g=h.m_linearVelocity.y+h.m_angularVelocity*n;l=-(this.m_u2.x*c+this.m_u2.y*g);g=-this.m_limitMass2*l;l=this.m_limitImpulse2;this.m_limitImpulse2=y.Max(0,this.m_limitImpulse2+g);g=this.m_limitImpulse2-l;c=-g*this.m_u2.x;
g=-g*this.m_u2.y;h.m_linearVelocity.x+=h.m_invMass*c;h.m_linearVelocity.y+=h.m_invMass*g;h.m_angularVelocity+=h.m_invI*(n*g-a*c)}};E.prototype.SolvePositionConstraints=function(){var d=this.m_bodyA,h=this.m_bodyB,l,j=this.m_ground.m_xf.position.x+this.m_groundAnchor1.x,o=this.m_ground.m_xf.position.y+this.m_groundAnchor1.y,q=this.m_ground.m_xf.position.x+this.m_groundAnchor2.x,n=this.m_ground.m_xf.position.y+this.m_groundAnchor2.y,a=0,c=0,g=0,b=0,e=l=0,f=0,m=0,r=e=m=l=e=l=0;if(this.m_state==I.e_atUpperLimit){l=
d.m_xf.R;a=this.m_localAnchor1.x-d.m_sweep.localCenter.x;c=this.m_localAnchor1.y-d.m_sweep.localCenter.y;e=l.col1.x*a+l.col2.x*c;c=l.col1.y*a+l.col2.y*c;a=e;l=h.m_xf.R;g=this.m_localAnchor2.x-h.m_sweep.localCenter.x;b=this.m_localAnchor2.y-h.m_sweep.localCenter.y;e=l.col1.x*g+l.col2.x*b;b=l.col1.y*g+l.col2.y*b;g=e;l=d.m_sweep.c.x+a;e=d.m_sweep.c.y+c;f=h.m_sweep.c.x+g;m=h.m_sweep.c.y+b;this.m_u1.Set(l-j,e-o);this.m_u2.Set(f-q,m-n);l=this.m_u1.Length();e=this.m_u2.Length();l>F.b2_linearSlop?this.m_u1.Multiply(1/
l):this.m_u1.SetZero();e>F.b2_linearSlop?this.m_u2.Multiply(1/e):this.m_u2.SetZero();l=this.m_constant-l-this.m_ratio*e;r=y.Max(r,-l);l=y.Clamp(l+F.b2_linearSlop,-F.b2_maxLinearCorrection,0);m=-this.m_pulleyMass*l;l=-m*this.m_u1.x;e=-m*this.m_u1.y;f=-this.m_ratio*m*this.m_u2.x;m=-this.m_ratio*m*this.m_u2.y;d.m_sweep.c.x+=d.m_invMass*l;d.m_sweep.c.y+=d.m_invMass*e;d.m_sweep.a+=d.m_invI*(a*e-c*l);h.m_sweep.c.x+=h.m_invMass*f;h.m_sweep.c.y+=h.m_invMass*m;h.m_sweep.a+=h.m_invI*(g*m-b*f);d.SynchronizeTransform();
h.SynchronizeTransform()}if(this.m_limitState1==I.e_atUpperLimit){l=d.m_xf.R;a=this.m_localAnchor1.x-d.m_sweep.localCenter.x;c=this.m_localAnchor1.y-d.m_sweep.localCenter.y;e=l.col1.x*a+l.col2.x*c;c=l.col1.y*a+l.col2.y*c;a=e;l=d.m_sweep.c.x+a;e=d.m_sweep.c.y+c;this.m_u1.Set(l-j,e-o);l=this.m_u1.Length();if(l>F.b2_linearSlop){this.m_u1.x*=1/l;this.m_u1.y*=1/l}else this.m_u1.SetZero();l=this.m_maxLength1-l;r=y.Max(r,-l);l=y.Clamp(l+F.b2_linearSlop,-F.b2_maxLinearCorrection,0);m=-this.m_limitMass1*l;
l=-m*this.m_u1.x;e=-m*this.m_u1.y;d.m_sweep.c.x+=d.m_invMass*l;d.m_sweep.c.y+=d.m_invMass*e;d.m_sweep.a+=d.m_invI*(a*e-c*l);d.SynchronizeTransform()}if(this.m_limitState2==I.e_atUpperLimit){l=h.m_xf.R;g=this.m_localAnchor2.x-h.m_sweep.localCenter.x;b=this.m_localAnchor2.y-h.m_sweep.localCenter.y;e=l.col1.x*g+l.col2.x*b;b=l.col1.y*g+l.col2.y*b;g=e;f=h.m_sweep.c.x+g;m=h.m_sweep.c.y+b;this.m_u2.Set(f-q,m-n);e=this.m_u2.Length();if(e>F.b2_linearSlop){this.m_u2.x*=1/e;this.m_u2.y*=1/e}else this.m_u2.SetZero();
l=this.m_maxLength2-e;r=y.Max(r,-l);l=y.Clamp(l+F.b2_linearSlop,-F.b2_maxLinearCorrection,0);m=-this.m_limitMass2*l;f=-m*this.m_u2.x;m=-m*this.m_u2.y;h.m_sweep.c.x+=h.m_invMass*f;h.m_sweep.c.y+=h.m_invMass*m;h.m_sweep.a+=h.m_invI*(g*m-b*f);h.SynchronizeTransform()}return r<F.b2_linearSlop};Box2D.postDefs.push(function(){Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength=2});Box2D.inherit(R,Box2D.Dynamics.Joints.b2JointDef);R.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;R.b2PulleyJointDef=
function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.groundAnchorA=new w;this.groundAnchorB=new w;this.localAnchorA=new w;this.localAnchorB=new w};R.prototype.b2PulleyJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_pulleyJoint;this.groundAnchorA.Set(-1,1);this.groundAnchorB.Set(1,1);this.localAnchorA.Set(-1,0);this.localAnchorB.Set(1,0);this.maxLengthB=this.lengthB=this.maxLengthA=this.lengthA=0;this.ratio=1;this.collideConnected=true};R.prototype.Initialize=
function(d,h,l,j,o,q,n){if(n===undefined)n=0;this.bodyA=d;this.bodyB=h;this.groundAnchorA.SetV(l);this.groundAnchorB.SetV(j);this.localAnchorA=this.bodyA.GetLocalPoint(o);this.localAnchorB=this.bodyB.GetLocalPoint(q);d=o.x-l.x;l=o.y-l.y;this.lengthA=Math.sqrt(d*d+l*l);l=q.x-j.x;j=q.y-j.y;this.lengthB=Math.sqrt(l*l+j*j);this.ratio=n;n=this.lengthA+this.ratio*this.lengthB;this.maxLengthA=n-this.ratio*E.b2_minPulleyLength;this.maxLengthB=(n-E.b2_minPulleyLength)/this.ratio};Box2D.inherit(N,Box2D.Dynamics.Joints.b2Joint);
N.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;N.b2RevoluteJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.K=new G;this.K1=new G;this.K2=new G;this.K3=new G;this.impulse3=new A;this.impulse2=new w;this.reduced=new w;this.m_localAnchor1=new w;this.m_localAnchor2=new w;this.m_impulse=new A;this.m_mass=new K};N.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)};N.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)};
N.prototype.GetReactionForce=function(d){if(d===undefined)d=0;return new w(d*this.m_impulse.x,d*this.m_impulse.y)};N.prototype.GetReactionTorque=function(d){if(d===undefined)d=0;return d*this.m_impulse.z};N.prototype.GetJointAngle=function(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle};N.prototype.GetJointSpeed=function(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity};N.prototype.IsLimitEnabled=function(){return this.m_enableLimit};N.prototype.EnableLimit=
function(d){this.m_enableLimit=d};N.prototype.GetLowerLimit=function(){return this.m_lowerAngle};N.prototype.GetUpperLimit=function(){return this.m_upperAngle};N.prototype.SetLimits=function(d,h){if(d===undefined)d=0;if(h===undefined)h=0;this.m_lowerAngle=d;this.m_upperAngle=h};N.prototype.IsMotorEnabled=function(){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);return this.m_enableMotor};N.prototype.EnableMotor=function(d){this.m_enableMotor=d};N.prototype.SetMotorSpeed=function(d){if(d===
undefined)d=0;this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_motorSpeed=d};N.prototype.GetMotorSpeed=function(){return this.m_motorSpeed};N.prototype.SetMaxMotorTorque=function(d){if(d===undefined)d=0;this.m_maxMotorTorque=d};N.prototype.GetMotorTorque=function(){return this.m_maxMotorTorque};N.prototype.b2RevoluteJoint=function(d){this.__super.b2Joint.call(this,d);this.m_localAnchor1.SetV(d.localAnchorA);this.m_localAnchor2.SetV(d.localAnchorB);this.m_referenceAngle=d.referenceAngle;
this.m_impulse.SetZero();this.m_motorImpulse=0;this.m_lowerAngle=d.lowerAngle;this.m_upperAngle=d.upperAngle;this.m_maxMotorTorque=d.maxMotorTorque;this.m_motorSpeed=d.motorSpeed;this.m_enableLimit=d.enableLimit;this.m_enableMotor=d.enableMotor;this.m_limitState=I.e_inactiveLimit};N.prototype.InitVelocityConstraints=function(d){var h=this.m_bodyA,l=this.m_bodyB,j,o=0;j=h.m_xf.R;var q=this.m_localAnchor1.x-h.m_sweep.localCenter.x,n=this.m_localAnchor1.y-h.m_sweep.localCenter.y;o=j.col1.x*q+j.col2.x*
n;n=j.col1.y*q+j.col2.y*n;q=o;j=l.m_xf.R;var a=this.m_localAnchor2.x-l.m_sweep.localCenter.x,c=this.m_localAnchor2.y-l.m_sweep.localCenter.y;o=j.col1.x*a+j.col2.x*c;c=j.col1.y*a+j.col2.y*c;a=o;j=h.m_invMass;o=l.m_invMass;var g=h.m_invI,b=l.m_invI;this.m_mass.col1.x=j+o+n*n*g+c*c*b;this.m_mass.col2.x=-n*q*g-c*a*b;this.m_mass.col3.x=-n*g-c*b;this.m_mass.col1.y=this.m_mass.col2.x;this.m_mass.col2.y=j+o+q*q*g+a*a*b;this.m_mass.col3.y=q*g+a*b;this.m_mass.col1.z=this.m_mass.col3.x;this.m_mass.col2.z=this.m_mass.col3.y;
this.m_mass.col3.z=g+b;this.m_motorMass=1/(g+b);if(this.m_enableMotor==false)this.m_motorImpulse=0;if(this.m_enableLimit){var e=l.m_sweep.a-h.m_sweep.a-this.m_referenceAngle;if(y.Abs(this.m_upperAngle-this.m_lowerAngle)<2*F.b2_angularSlop)this.m_limitState=I.e_equalLimits;else if(e<=this.m_lowerAngle){if(this.m_limitState!=I.e_atLowerLimit)this.m_impulse.z=0;this.m_limitState=I.e_atLowerLimit}else if(e>=this.m_upperAngle){if(this.m_limitState!=I.e_atUpperLimit)this.m_impulse.z=0;this.m_limitState=
I.e_atUpperLimit}else{this.m_limitState=I.e_inactiveLimit;this.m_impulse.z=0}}else this.m_limitState=I.e_inactiveLimit;if(d.warmStarting){this.m_impulse.x*=d.dtRatio;this.m_impulse.y*=d.dtRatio;this.m_motorImpulse*=d.dtRatio;d=this.m_impulse.x;e=this.m_impulse.y;h.m_linearVelocity.x-=j*d;h.m_linearVelocity.y-=j*e;h.m_angularVelocity-=g*(q*e-n*d+this.m_motorImpulse+this.m_impulse.z);l.m_linearVelocity.x+=o*d;l.m_linearVelocity.y+=o*e;l.m_angularVelocity+=b*(a*e-c*d+this.m_motorImpulse+this.m_impulse.z)}else{this.m_impulse.SetZero();
this.m_motorImpulse=0}};N.prototype.SolveVelocityConstraints=function(d){var h=this.m_bodyA,l=this.m_bodyB,j=0,o=j=0,q=0,n=0,a=0,c=h.m_linearVelocity,g=h.m_angularVelocity,b=l.m_linearVelocity,e=l.m_angularVelocity,f=h.m_invMass,m=l.m_invMass,r=h.m_invI,s=l.m_invI;if(this.m_enableMotor&&this.m_limitState!=I.e_equalLimits){o=this.m_motorMass*-(e-g-this.m_motorSpeed);q=this.m_motorImpulse;n=d.dt*this.m_maxMotorTorque;this.m_motorImpulse=y.Clamp(this.m_motorImpulse+o,-n,n);o=this.m_motorImpulse-q;g-=
r*o;e+=s*o}if(this.m_enableLimit&&this.m_limitState!=I.e_inactiveLimit){d=h.m_xf.R;o=this.m_localAnchor1.x-h.m_sweep.localCenter.x;q=this.m_localAnchor1.y-h.m_sweep.localCenter.y;j=d.col1.x*o+d.col2.x*q;q=d.col1.y*o+d.col2.y*q;o=j;d=l.m_xf.R;n=this.m_localAnchor2.x-l.m_sweep.localCenter.x;a=this.m_localAnchor2.y-l.m_sweep.localCenter.y;j=d.col1.x*n+d.col2.x*a;a=d.col1.y*n+d.col2.y*a;n=j;d=b.x+-e*a-c.x- -g*q;var v=b.y+e*n-c.y-g*o;this.m_mass.Solve33(this.impulse3,-d,-v,-(e-g));if(this.m_limitState==
I.e_equalLimits)this.m_impulse.Add(this.impulse3);else if(this.m_limitState==I.e_atLowerLimit){j=this.m_impulse.z+this.impulse3.z;if(j<0){this.m_mass.Solve22(this.reduced,-d,-v);this.impulse3.x=this.reduced.x;this.impulse3.y=this.reduced.y;this.impulse3.z=-this.m_impulse.z;this.m_impulse.x+=this.reduced.x;this.m_impulse.y+=this.reduced.y;this.m_impulse.z=0}}else if(this.m_limitState==I.e_atUpperLimit){j=this.m_impulse.z+this.impulse3.z;if(j>0){this.m_mass.Solve22(this.reduced,-d,-v);this.impulse3.x=
this.reduced.x;this.impulse3.y=this.reduced.y;this.impulse3.z=-this.m_impulse.z;this.m_impulse.x+=this.reduced.x;this.m_impulse.y+=this.reduced.y;this.m_impulse.z=0}}c.x-=f*this.impulse3.x;c.y-=f*this.impulse3.y;g-=r*(o*this.impulse3.y-q*this.impulse3.x+this.impulse3.z);b.x+=m*this.impulse3.x;b.y+=m*this.impulse3.y;e+=s*(n*this.impulse3.y-a*this.impulse3.x+this.impulse3.z)}else{d=h.m_xf.R;o=this.m_localAnchor1.x-h.m_sweep.localCenter.x;q=this.m_localAnchor1.y-h.m_sweep.localCenter.y;j=d.col1.x*o+
d.col2.x*q;q=d.col1.y*o+d.col2.y*q;o=j;d=l.m_xf.R;n=this.m_localAnchor2.x-l.m_sweep.localCenter.x;a=this.m_localAnchor2.y-l.m_sweep.localCenter.y;j=d.col1.x*n+d.col2.x*a;a=d.col1.y*n+d.col2.y*a;n=j;this.m_mass.Solve22(this.impulse2,-(b.x+-e*a-c.x- -g*q),-(b.y+e*n-c.y-g*o));this.m_impulse.x+=this.impulse2.x;this.m_impulse.y+=this.impulse2.y;c.x-=f*this.impulse2.x;c.y-=f*this.impulse2.y;g-=r*(o*this.impulse2.y-q*this.impulse2.x);b.x+=m*this.impulse2.x;b.y+=m*this.impulse2.y;e+=s*(n*this.impulse2.y-
a*this.impulse2.x)}h.m_linearVelocity.SetV(c);h.m_angularVelocity=g;l.m_linearVelocity.SetV(b);l.m_angularVelocity=e};N.prototype.SolvePositionConstraints=function(){var d=0,h,l=this.m_bodyA,j=this.m_bodyB,o=0,q=h=0,n=0,a=0;if(this.m_enableLimit&&this.m_limitState!=I.e_inactiveLimit){d=j.m_sweep.a-l.m_sweep.a-this.m_referenceAngle;var c=0;if(this.m_limitState==I.e_equalLimits){d=y.Clamp(d-this.m_lowerAngle,-F.b2_maxAngularCorrection,F.b2_maxAngularCorrection);c=-this.m_motorMass*d;o=y.Abs(d)}else if(this.m_limitState==
I.e_atLowerLimit){d=d-this.m_lowerAngle;o=-d;d=y.Clamp(d+F.b2_angularSlop,-F.b2_maxAngularCorrection,0);c=-this.m_motorMass*d}else if(this.m_limitState==I.e_atUpperLimit){o=d=d-this.m_upperAngle;d=y.Clamp(d-F.b2_angularSlop,0,F.b2_maxAngularCorrection);c=-this.m_motorMass*d}l.m_sweep.a-=l.m_invI*c;j.m_sweep.a+=j.m_invI*c;l.SynchronizeTransform();j.SynchronizeTransform()}h=l.m_xf.R;c=this.m_localAnchor1.x-l.m_sweep.localCenter.x;d=this.m_localAnchor1.y-l.m_sweep.localCenter.y;q=h.col1.x*c+h.col2.x*
d;d=h.col1.y*c+h.col2.y*d;c=q;h=j.m_xf.R;var g=this.m_localAnchor2.x-j.m_sweep.localCenter.x,b=this.m_localAnchor2.y-j.m_sweep.localCenter.y;q=h.col1.x*g+h.col2.x*b;b=h.col1.y*g+h.col2.y*b;g=q;n=j.m_sweep.c.x+g-l.m_sweep.c.x-c;a=j.m_sweep.c.y+b-l.m_sweep.c.y-d;var e=n*n+a*a;h=Math.sqrt(e);q=l.m_invMass;var f=j.m_invMass,m=l.m_invI,r=j.m_invI,s=10*F.b2_linearSlop;if(e>s*s){e=1/(q+f);n=e*-n;a=e*-a;l.m_sweep.c.x-=0.5*q*n;l.m_sweep.c.y-=0.5*q*a;j.m_sweep.c.x+=0.5*f*n;j.m_sweep.c.y+=0.5*f*a;n=j.m_sweep.c.x+
g-l.m_sweep.c.x-c;a=j.m_sweep.c.y+b-l.m_sweep.c.y-d}this.K1.col1.x=q+f;this.K1.col2.x=0;this.K1.col1.y=0;this.K1.col2.y=q+f;this.K2.col1.x=m*d*d;this.K2.col2.x=-m*c*d;this.K2.col1.y=-m*c*d;this.K2.col2.y=m*c*c;this.K3.col1.x=r*b*b;this.K3.col2.x=-r*g*b;this.K3.col1.y=-r*g*b;this.K3.col2.y=r*g*g;this.K.SetM(this.K1);this.K.AddM(this.K2);this.K.AddM(this.K3);this.K.Solve(N.tImpulse,-n,-a);n=N.tImpulse.x;a=N.tImpulse.y;l.m_sweep.c.x-=l.m_invMass*n;l.m_sweep.c.y-=l.m_invMass*a;l.m_sweep.a-=l.m_invI*(c*
a-d*n);j.m_sweep.c.x+=j.m_invMass*n;j.m_sweep.c.y+=j.m_invMass*a;j.m_sweep.a+=j.m_invI*(g*a-b*n);l.SynchronizeTransform();j.SynchronizeTransform();return h<=F.b2_linearSlop&&o<=F.b2_angularSlop};Box2D.postDefs.push(function(){Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse=new w});Box2D.inherit(S,Box2D.Dynamics.Joints.b2JointDef);S.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;S.b2RevoluteJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.localAnchorA=
new w;this.localAnchorB=new w};S.prototype.b2RevoluteJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_revoluteJoint;this.localAnchorA.Set(0,0);this.localAnchorB.Set(0,0);this.motorSpeed=this.maxMotorTorque=this.upperAngle=this.lowerAngle=this.referenceAngle=0;this.enableMotor=this.enableLimit=false};S.prototype.Initialize=function(d,h,l){this.bodyA=d;this.bodyB=h;this.localAnchorA=this.bodyA.GetLocalPoint(l);this.localAnchorB=this.bodyB.GetLocalPoint(l);this.referenceAngle=this.bodyB.GetAngle()-
this.bodyA.GetAngle()};Box2D.inherit(aa,Box2D.Dynamics.Joints.b2Joint);aa.prototype.__super=Box2D.Dynamics.Joints.b2Joint.prototype;aa.b2WeldJoint=function(){Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,arguments);this.m_localAnchorA=new w;this.m_localAnchorB=new w;this.m_impulse=new A;this.m_mass=new K};aa.prototype.GetAnchorA=function(){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)};aa.prototype.GetAnchorB=function(){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)};aa.prototype.GetReactionForce=
function(d){if(d===undefined)d=0;return new w(d*this.m_impulse.x,d*this.m_impulse.y)};aa.prototype.GetReactionTorque=function(d){if(d===undefined)d=0;return d*this.m_impulse.z};aa.prototype.b2WeldJoint=function(d){this.__super.b2Joint.call(this,d);this.m_localAnchorA.SetV(d.localAnchorA);this.m_localAnchorB.SetV(d.localAnchorB);this.m_referenceAngle=d.referenceAngle;this.m_impulse.SetZero();this.m_mass=new K};aa.prototype.InitVelocityConstraints=function(d){var h,l=0,j=this.m_bodyA,o=this.m_bodyB;
h=j.m_xf.R;var q=this.m_localAnchorA.x-j.m_sweep.localCenter.x,n=this.m_localAnchorA.y-j.m_sweep.localCenter.y;l=h.col1.x*q+h.col2.x*n;n=h.col1.y*q+h.col2.y*n;q=l;h=o.m_xf.R;var a=this.m_localAnchorB.x-o.m_sweep.localCenter.x,c=this.m_localAnchorB.y-o.m_sweep.localCenter.y;l=h.col1.x*a+h.col2.x*c;c=h.col1.y*a+h.col2.y*c;a=l;h=j.m_invMass;l=o.m_invMass;var g=j.m_invI,b=o.m_invI;this.m_mass.col1.x=h+l+n*n*g+c*c*b;this.m_mass.col2.x=-n*q*g-c*a*b;this.m_mass.col3.x=-n*g-c*b;this.m_mass.col1.y=this.m_mass.col2.x;
this.m_mass.col2.y=h+l+q*q*g+a*a*b;this.m_mass.col3.y=q*g+a*b;this.m_mass.col1.z=this.m_mass.col3.x;this.m_mass.col2.z=this.m_mass.col3.y;this.m_mass.col3.z=g+b;if(d.warmStarting){this.m_impulse.x*=d.dtRatio;this.m_impulse.y*=d.dtRatio;this.m_impulse.z*=d.dtRatio;j.m_linearVelocity.x-=h*this.m_impulse.x;j.m_linearVelocity.y-=h*this.m_impulse.y;j.m_angularVelocity-=g*(q*this.m_impulse.y-n*this.m_impulse.x+this.m_impulse.z);o.m_linearVelocity.x+=l*this.m_impulse.x;o.m_linearVelocity.y+=l*this.m_impulse.y;
o.m_angularVelocity+=b*(a*this.m_impulse.y-c*this.m_impulse.x+this.m_impulse.z)}else this.m_impulse.SetZero()};aa.prototype.SolveVelocityConstraints=function(){var d,h=0,l=this.m_bodyA,j=this.m_bodyB,o=l.m_linearVelocity,q=l.m_angularVelocity,n=j.m_linearVelocity,a=j.m_angularVelocity,c=l.m_invMass,g=j.m_invMass,b=l.m_invI,e=j.m_invI;d=l.m_xf.R;var f=this.m_localAnchorA.x-l.m_sweep.localCenter.x,m=this.m_localAnchorA.y-l.m_sweep.localCenter.y;h=d.col1.x*f+d.col2.x*m;m=d.col1.y*f+d.col2.y*m;f=h;d=
j.m_xf.R;var r=this.m_localAnchorB.x-j.m_sweep.localCenter.x,s=this.m_localAnchorB.y-j.m_sweep.localCenter.y;h=d.col1.x*r+d.col2.x*s;s=d.col1.y*r+d.col2.y*s;r=h;d=n.x-a*s-o.x+q*m;h=n.y+a*r-o.y-q*f;var v=a-q,t=new A;this.m_mass.Solve33(t,-d,-h,-v);this.m_impulse.Add(t);o.x-=c*t.x;o.y-=c*t.y;q-=b*(f*t.y-m*t.x+t.z);n.x+=g*t.x;n.y+=g*t.y;a+=e*(r*t.y-s*t.x+t.z);l.m_angularVelocity=q;j.m_angularVelocity=a};aa.prototype.SolvePositionConstraints=function(){var d,h=0,l=this.m_bodyA,j=this.m_bodyB;d=l.m_xf.R;
var o=this.m_localAnchorA.x-l.m_sweep.localCenter.x,q=this.m_localAnchorA.y-l.m_sweep.localCenter.y;h=d.col1.x*o+d.col2.x*q;q=d.col1.y*o+d.col2.y*q;o=h;d=j.m_xf.R;var n=this.m_localAnchorB.x-j.m_sweep.localCenter.x,a=this.m_localAnchorB.y-j.m_sweep.localCenter.y;h=d.col1.x*n+d.col2.x*a;a=d.col1.y*n+d.col2.y*a;n=h;d=l.m_invMass;h=j.m_invMass;var c=l.m_invI,g=j.m_invI,b=j.m_sweep.c.x+n-l.m_sweep.c.x-o,e=j.m_sweep.c.y+a-l.m_sweep.c.y-q,f=j.m_sweep.a-l.m_sweep.a-this.m_referenceAngle,m=10*F.b2_linearSlop,
r=Math.sqrt(b*b+e*e),s=y.Abs(f);if(r>m){c*=1;g*=1}this.m_mass.col1.x=d+h+q*q*c+a*a*g;this.m_mass.col2.x=-q*o*c-a*n*g;this.m_mass.col3.x=-q*c-a*g;this.m_mass.col1.y=this.m_mass.col2.x;this.m_mass.col2.y=d+h+o*o*c+n*n*g;this.m_mass.col3.y=o*c+n*g;this.m_mass.col1.z=this.m_mass.col3.x;this.m_mass.col2.z=this.m_mass.col3.y;this.m_mass.col3.z=c+g;m=new A;this.m_mass.Solve33(m,-b,-e,-f);l.m_sweep.c.x-=d*m.x;l.m_sweep.c.y-=d*m.y;l.m_sweep.a-=c*(o*m.y-q*m.x+m.z);j.m_sweep.c.x+=h*m.x;j.m_sweep.c.y+=h*m.y;
j.m_sweep.a+=g*(n*m.y-a*m.x+m.z);l.SynchronizeTransform();j.SynchronizeTransform();return r<=F.b2_linearSlop&&s<=F.b2_angularSlop};Box2D.inherit(Z,Box2D.Dynamics.Joints.b2JointDef);Z.prototype.__super=Box2D.Dynamics.Joints.b2JointDef.prototype;Z.b2WeldJointDef=function(){Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,arguments);this.localAnchorA=new w;this.localAnchorB=new w};Z.prototype.b2WeldJointDef=function(){this.__super.b2JointDef.call(this);this.type=I.e_weldJoint;this.referenceAngle=
0};Z.prototype.Initialize=function(d,h,l){this.bodyA=d;this.bodyB=h;this.localAnchorA.SetV(this.bodyA.GetLocalPoint(l));this.localAnchorB.SetV(this.bodyB.GetLocalPoint(l));this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}})();
(function(){var F=Box2D.Dynamics.b2DebugDraw;F.b2DebugDraw=function(){this.m_xformScale=this.m_fillAlpha=this.m_alpha=this.m_lineThickness=this.m_drawScale=1;var G=this;this.m_sprite={graphics:{clear:function(){G.m_ctx.clearRect(0,0,G.m_ctx.canvas.width,G.m_ctx.canvas.height)}}}};F.prototype._color=function(G,K){return"rgba("+((G&16711680)>>16)+","+((G&65280)>>8)+","+(G&255)+","+K+")"};F.prototype.b2DebugDraw=function(){this.m_drawFlags=0};F.prototype.SetFlags=function(G){if(G===undefined)G=0;this.m_drawFlags=
G};F.prototype.GetFlags=function(){return this.m_drawFlags};F.prototype.AppendFlags=function(G){if(G===undefined)G=0;this.m_drawFlags|=G};F.prototype.ClearFlags=function(G){if(G===undefined)G=0;this.m_drawFlags&=~G};F.prototype.SetSprite=function(G){this.m_ctx=G};F.prototype.GetSprite=function(){return this.m_ctx};F.prototype.SetDrawScale=function(G){if(G===undefined)G=0;this.m_drawScale=G};F.prototype.GetDrawScale=function(){return this.m_drawScale};F.prototype.SetLineThickness=function(G){if(G===
undefined)G=0;this.m_lineThickness=G;this.m_ctx.strokeWidth=G};F.prototype.GetLineThickness=function(){return this.m_lineThickness};F.prototype.SetAlpha=function(G){if(G===undefined)G=0;this.m_alpha=G};F.prototype.GetAlpha=function(){return this.m_alpha};F.prototype.SetFillAlpha=function(G){if(G===undefined)G=0;this.m_fillAlpha=G};F.prototype.GetFillAlpha=function(){return this.m_fillAlpha};F.prototype.SetXFormScale=function(G){if(G===undefined)G=0;this.m_xformScale=G};F.prototype.GetXFormScale=function(){return this.m_xformScale};
F.prototype.DrawPolygon=function(G,K,y){if(K){var w=this.m_ctx,A=this.m_drawScale;w.beginPath();w.strokeStyle=this._color(y.color,this.m_alpha);w.moveTo(G[0].x*A,G[0].y*A);for(y=1;y<K;y++)w.lineTo(G[y].x*A,G[y].y*A);w.lineTo(G[0].x*A,G[0].y*A);w.closePath();w.stroke()}};F.prototype.DrawSolidPolygon=function(G,K,y){if(K){var w=this.m_ctx,A=this.m_drawScale;w.beginPath();w.strokeStyle=this._color(y.color,this.m_alpha);w.fillStyle=this._color(y.color,this.m_fillAlpha);w.moveTo(G[0].x*A,G[0].y*A);for(y=
1;y<K;y++)w.lineTo(G[y].x*A,G[y].y*A);w.lineTo(G[0].x*A,G[0].y*A);w.closePath();w.fill();w.stroke()}};F.prototype.DrawCircle=function(G,K,y){if(K){var w=this.m_ctx,A=this.m_drawScale;w.beginPath();w.strokeStyle=this._color(y.color,this.m_alpha);w.arc(G.x*A,G.y*A,K*A,0,Math.PI*2,true);w.closePath();w.stroke()}};F.prototype.DrawSolidCircle=function(G,K,y,w){if(K){var A=this.m_ctx,U=this.m_drawScale,p=G.x*U,B=G.y*U;A.moveTo(0,0);A.beginPath();A.strokeStyle=this._color(w.color,this.m_alpha);A.fillStyle=
this._color(w.color,this.m_fillAlpha);A.arc(p,B,K*U,0,Math.PI*2,true);A.moveTo(p,B);A.lineTo((G.x+y.x*K)*U,(G.y+y.y*K)*U);A.closePath();A.fill();A.stroke()}};F.prototype.DrawSegment=function(G,K,y){var w=this.m_ctx,A=this.m_drawScale;w.strokeStyle=this._color(y.color,this.m_alpha);w.beginPath();w.moveTo(G.x*A,G.y*A);w.lineTo(K.x*A,K.y*A);w.closePath();w.stroke()};F.prototype.DrawTransform=function(G){var K=this.m_ctx,y=this.m_drawScale;K.beginPath();K.strokeStyle=this._color(16711680,this.m_alpha);
K.moveTo(G.position.x*y,G.position.y*y);K.lineTo((G.position.x+this.m_xformScale*G.R.col1.x)*y,(G.position.y+this.m_xformScale*G.R.col1.y)*y);K.strokeStyle=this._color(65280,this.m_alpha);K.moveTo(G.position.x*y,G.position.y*y);K.lineTo((G.position.x+this.m_xformScale*G.R.col2.x)*y,(G.position.y+this.m_xformScale*G.R.col2.y)*y);K.closePath();K.stroke()}})();var i;for(i=0;i<Box2D.postDefs.length;++i)Box2D.postDefs[i]();delete Box2D.postDefs;

var box_2d = {};

box_2d.b2Vec2 = Box2D.Common.Math.b2Vec2
box_2d.b2AABB = Box2D.Collision.b2AABB
box_2d.b2BodyDef = Box2D.Dynamics.b2BodyDef
box_2d.b2Body = Box2D.Dynamics.b2Body
box_2d.b2FixtureDef = Box2D.Dynamics.b2FixtureDef
box_2d.b2Fixture = Box2D.Dynamics.b2Fixture
box_2d.b2World = Box2D.Dynamics.b2World
box_2d.b2MassData = Box2D.Collision.Shapes.b2MassData
box_2d.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
box_2d.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
box_2d.b2DebugDraw = Box2D.Dynamics.b2DebugDraw
box_2d.b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
box_2d.b2ContactListener = Box2D.Dynamics.b2ContactListener
box_2d.b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;

box_2d.WALL_BIT = 0x0001;
box_2d.PLAYER_BIT = 0x0002;
box_2d.ENEMY_BIT = 0x0004;
box_2d.BOSS_ONE_BIT = 0x0008;
box_2d.BOSS_THREE_BIT = 0x0010;
box_2d.BOSS_FOUR_BIT = 0x0011;
box_2d.BOSS_BITS = 0x0018;

module.exports = box_2d;

},{}],98:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Buzz, a Javascript HTML5 Audio library
// v 1.0.6
// Licensed under the MIT license.
// http://buzz.jaysalvat.com/
// ----------------------------------------------------------------------------
// Copyright (C) 2013 Jay Salvat
// http://jaysalvat.com/
// ----------------------------------------------------------------------------
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files ( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ----------------------------------------------------------------------------

var buzz = {
    defaults: {
        autoplay: false,
        duration: 5000,
        formats: [],
        loop: false,
        placeholder: '--',
        preload: 'metadata',
        volume: 80
    },
    types: {
        'mp3': 'audio/mpeg',
        'ogg': 'audio/ogg',
        'wav': 'audio/wav',
        'aac': 'audio/aac',
        'm4a': 'audio/x-m4a'
    },
    sounds: [],
    el: document.createElement( 'audio' ),

    sound: function( src, options ) {
        options = options || {};

        var pid = 0,
            events = [],
            eventsOnce = {},
            supported = buzz.isSupported();

        // publics
        this.load = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.load();
            return this;
        };

        this.play = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.play();
            return this;
        };

        this.togglePlay = function() {
            if ( !supported ) {
              return this;
            }

            if ( this.sound.paused ) {
                this.sound.play();
            } else {
                this.sound.pause();
            }
            return this;
        };

        this.pause = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.pause();
            return this;
        };

        this.isPaused = function() {
            if ( !supported ) {
              return null;
            }

            return this.sound.paused;
        };

        this.stop = function() {
            if ( !supported  ) {
              return this;
            }

            this.setTime( 0 );
            this.sound.pause();
            return this;
        };

        this.isEnded = function() {
            if ( !supported ) {
              return null;
            }

            return this.sound.ended;
        };

        this.loop = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.loop = 'loop';
            this.bind( 'ended.buzzloop', function() {
                this.currentTime = 0;
                this.play();
            });
            return this;
        };

        this.unloop = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.removeAttribute( 'loop' );
            this.unbind( 'ended.buzzloop' );
            return this;
        };

        this.mute = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.muted = true;
            return this;
        };

        this.unmute = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.muted = false;
            return this;
        };

        this.toggleMute = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.muted = !this.sound.muted;
            return this;
        };

        this.isMuted = function() {
            if ( !supported ) {
              return null;
            }

            return this.sound.muted;
        };

        this.setVolume = function( volume ) {
            if ( !supported ) {
              return this;
            }

            if ( volume < 0 ) {
              volume = 0;
            }
            if ( volume > 100 ) {
              volume = 100;
            }

            this.volume = volume;
            this.sound.volume = volume / 100;
            return this;
        };

        this.getVolume = function() {
            if ( !supported ) {
              return this;
            }

            return this.volume;
        };

        this.increaseVolume = function( value ) {
            return this.setVolume( this.volume + ( value || 1 ) );
        };

        this.decreaseVolume = function( value ) {
            return this.setVolume( this.volume - ( value || 1 ) );
        };

        this.setTime = function( time ) {
            if ( !supported ) {
              return this;
            }

            this.whenReady( function() {
                this.sound.currentTime = time;
            });
            return this;
        };

        this.getTime = function() {
            if ( !supported ) {
              return null;
            }

            var time = Math.round( this.sound.currentTime * 100 ) / 100;
            return isNaN( time ) ? buzz.defaults.placeholder : time;
        };

        this.setPercent = function( percent ) {
            if ( !supported ) {
              return this;
            }

            return this.setTime( buzz.fromPercent( percent, this.sound.duration ) );
        };

        this.getPercent = function() {
            if ( !supported ) {
              return null;
            }

			var percent = Math.round( buzz.toPercent( this.sound.currentTime, this.sound.duration ) );
            return isNaN( percent ) ? buzz.defaults.placeholder : percent;
        };

        this.setSpeed = function( duration ) {
			if ( !supported ) {
              return this;
            }

            this.sound.playbackRate = duration;
        };

        this.getSpeed = function() {
			if ( !supported ) {
              return null;
            }

            return this.sound.playbackRate;
        };

        this.getDuration = function() {
            if ( !supported ) {
              return null;
            }

            var duration = Math.round( this.sound.duration * 100 ) / 100;
            return isNaN( duration ) ? buzz.defaults.placeholder : duration;
        };

        this.getPlayed = function() {
			if ( !supported ) {
              return null;
            }

            return timerangeToArray( this.sound.played );
        };

        this.getBuffered = function() {
			if ( !supported ) {
              return null;
            }

            return timerangeToArray( this.sound.buffered );
        };

        this.getSeekable = function() {
			if ( !supported ) {
              return null;
            }

            return timerangeToArray( this.sound.seekable );
        };

        this.getErrorCode = function() {
            if ( supported && this.sound.error ) {
                return this.sound.error.code;
            }
            return 0;
        };

        this.getErrorMessage = function() {
			if ( !supported ) {
              return null;
            }

            switch( this.getErrorCode() ) {
                case 1:
                    return 'MEDIA_ERR_ABORTED';
                case 2:
                    return 'MEDIA_ERR_NETWORK';
                case 3:
                    return 'MEDIA_ERR_DECODE';
                case 4:
                    return 'MEDIA_ERR_SRC_NOT_SUPPORTED';
                default:
                    return null;
            }
        };

        this.getStateCode = function() {
			if ( !supported ) {
              return null;
            }

            return this.sound.readyState;
        };

        this.getStateMessage = function() {
			if ( !supported ) {
              return null;
            }

            switch( this.getStateCode() ) {
                case 0:
                    return 'HAVE_NOTHING';
                case 1:
                    return 'HAVE_METADATA';
                case 2:
                    return 'HAVE_CURRENT_DATA';
                case 3:
                    return 'HAVE_FUTURE_DATA';
                case 4:
                    return 'HAVE_ENOUGH_DATA';
                default:
                    return null;
            }
        };

        this.getNetworkStateCode = function() {
			if ( !supported ) {
              return null;
            }

            return this.sound.networkState;
        };

        this.getNetworkStateMessage = function() {
			if ( !supported ) {
              return null;
            }

            switch( this.getNetworkStateCode() ) {
                case 0:
                    return 'NETWORK_EMPTY';
                case 1:
                    return 'NETWORK_IDLE';
                case 2:
                    return 'NETWORK_LOADING';
                case 3:
                    return 'NETWORK_NO_SOURCE';
                default:
                    return null;
            }
        };

        this.set = function( key, value ) {
            if ( !supported ) {
              return this;
            }

            this.sound[ key ] = value;
            return this;
        };

        this.get = function( key ) {
            if ( !supported ) {
              return null;
            }

            return key ? this.sound[ key ] : this.sound;
        };

        this.bind = function( types, func ) {
            if ( !supported ) {
              return this;
            }

            types = types.split( ' ' );

            var that = this,
				efunc = function( e ) { func.call( that, e ); };

            for( var t = 0; t < types.length; t++ ) {
                var type = types[ t ],
                    idx = type;
                    type = idx.split( '.' )[ 0 ];

                    events.push( { idx: idx, func: efunc } );
                    this.sound.addEventListener( type, efunc, true );
            }
            return this;
        };

        this.unbind = function( types ) {
            if ( !supported ) {
              return this;
            }

            types = types.split( ' ' );

            for( var t = 0; t < types.length; t++ ) {
                var idx = types[ t ],
                    type = idx.split( '.' )[ 0 ];

                for( var i = 0; i < events.length; i++ ) {
                    var namespace = events[ i ].idx.split( '.' );
                    if ( events[ i ].idx == idx || ( namespace[ 1 ] && namespace[ 1 ] == idx.replace( '.', '' ) ) ) {
                        this.sound.removeEventListener( type, events[ i ].func, true );
                        // remove event
                        events.splice(i, 1);
                    }
                }
            }
            return this;
        };

        this.bindOnce = function( type, func ) {
            if ( !supported ) {
              return this;
            }

            var that = this;

            eventsOnce[ pid++ ] = false;
            this.bind( type + '.' + pid, function() {
               if ( !eventsOnce[ pid ] ) {
                   eventsOnce[ pid ] = true;
                   func.call( that );
               }
               that.unbind( type + '.' + pid );
            });
        };

        this.trigger = function( types ) {
            if ( !supported ) {
              return this;
            }

            types = types.split( ' ' );

            for( var t = 0; t < types.length; t++ ) {
                var idx = types[ t ];

                for( var i = 0; i < events.length; i++ ) {
                    var eventType = events[ i ].idx.split( '.' );
                    if ( events[ i ].idx == idx || ( eventType[ 0 ] && eventType[ 0 ] == idx.replace( '.', '' ) ) ) {
                        var evt = document.createEvent('HTMLEvents');
                        evt.initEvent( eventType[ 0 ], false, true );
                        this.sound.dispatchEvent( evt );
                    }
                }
            }
            return this;
        };

        this.fadeTo = function( to, duration, callback ) {
			if ( !supported ) {
              return this;
            }

            if ( duration instanceof Function ) {
                callback = duration;
                duration = buzz.defaults.duration;
            } else {
                duration = duration || buzz.defaults.duration;
            }

            var from = this.volume,
				delay = duration / Math.abs( from - to ),
                that = this;
            this.play();

            function doFade() {
                setTimeout( function() {
                    if ( from < to && that.volume < to ) {
                        that.setVolume( that.volume += 1 );
                        doFade();
                    } else if ( from > to && that.volume > to ) {
                        that.setVolume( that.volume -= 1 );
                        doFade();
                    } else if ( callback instanceof Function ) {
                        callback.apply( that );
                    }
                }, delay );
            }
            this.whenReady( function() {
                doFade();
            });

            return this;
        };

        this.fadeIn = function( duration, callback ) {
            if ( !supported ) {
              return this;
            }

            return this.setVolume(0).fadeTo( 100, duration, callback );
        };

        this.fadeOut = function( duration, callback ) {
			if ( !supported ) {
              return this;
            }

            return this.fadeTo( 0, duration, callback );
        };

        this.fadeWith = function( sound, duration ) {
            if ( !supported ) {
              return this;
            }

            this.fadeOut( duration, function() {
                this.stop();
            });

            sound.play().fadeIn( duration );

            return this;
        };

        this.whenReady = function( func ) {
            if ( !supported ) {
              return null;
            }

            var that = this;
            if ( this.sound.readyState === 0 ) {
                this.bind( 'canplay.buzzwhenready', function() {
                    func.call( that );
                });
            } else {
                func.call( that );
            }
        };

        // privates
        function timerangeToArray( timeRange ) {
            var array = [],
                length = timeRange.length - 1;

            for( var i = 0; i <= length; i++ ) {
                array.push({
                    start: timeRange.start( length ),
                    end: timeRange.end( length )
                });
            }
            return array;
        }

        function getExt( filename ) {
            return filename.split('.').pop();
        }

        function addSource( sound, src ) {
            var source = document.createElement( 'source' );
            source.src = src;
            if ( buzz.types[ getExt( src ) ] ) {
                source.type = buzz.types[ getExt( src ) ];
            }
            sound.appendChild( source );
        }

        // init
        if ( supported && src ) {

            for(var i in buzz.defaults ) {
              if(buzz.defaults.hasOwnProperty(i)) {
                options[ i ] = options[ i ] || buzz.defaults[ i ];
              }
            }

            this.sound = document.createElement( 'audio' );

            if ( src instanceof Array ) {
                for( var j in src ) {
                  if(src.hasOwnProperty(j)) {
                    addSource( this.sound, src[ j ] );
                  }
                }
            } else if ( options.formats.length ) {
                for( var k in options.formats ) {
                  if(options.formats.hasOwnProperty(k)) {
                    addSource( this.sound, src + '.' + options.formats[ k ] );
                  }
                }
            } else {
                addSource( this.sound, src );
            }

            if ( options.loop ) {
                this.loop();
            }

            if ( options.autoplay ) {
                this.sound.autoplay = 'autoplay';
            }

            if ( options.preload === true ) {
                this.sound.preload = 'auto';
            } else if ( options.preload === false ) {
                this.sound.preload = 'none';
            } else {
                this.sound.preload = options.preload;
            }

            this.setVolume( options.volume );

            buzz.sounds.push( this );
        }
    },

    group: function( sounds ) {
        sounds = argsToArray( sounds, arguments );

        // publics
        this.getSounds = function() {
            return sounds;
        };

        this.add = function( soundArray ) {
            soundArray = argsToArray( soundArray, arguments );
            for( var a = 0; a < soundArray.length; a++ ) {
                sounds.push( soundArray[ a ] );
            }
        };

        this.remove = function( soundArray ) {
            soundArray = argsToArray( soundArray, arguments );
            for( var a = 0; a < soundArray.length; a++ ) {
                for( var i = 0; i < sounds.length; i++ ) {
                    if ( sounds[ i ] == soundArray[ a ] ) {
                        sounds.splice(i, 1);
                        break;
                    }
                }
            }
        };

        this.load = function() {
            fn( 'load' );
            return this;
        };

        this.play = function() {
            fn( 'play' );
            return this;
        };

        this.togglePlay = function( ) {
            fn( 'togglePlay' );
            return this;
        };

        this.pause = function( time ) {
            fn( 'pause', time );
            return this;
        };

        this.stop = function() {
            fn( 'stop' );
            return this;
        };

        this.mute = function() {
            fn( 'mute' );
            return this;
        };

        this.unmute = function() {
            fn( 'unmute' );
            return this;
        };

        this.toggleMute = function() {
            fn( 'toggleMute' );
            return this;
        };

        this.setVolume = function( volume ) {
            fn( 'setVolume', volume );
            return this;
        };

        this.increaseVolume = function( value ) {
            fn( 'increaseVolume', value );
            return this;
        };

        this.decreaseVolume = function( value ) {
            fn( 'decreaseVolume', value );
            return this;
        };

        this.loop = function() {
            fn( 'loop' );
            return this;
        };

        this.unloop = function() {
            fn( 'unloop' );
            return this;
        };

        this.setTime = function( time ) {
            fn( 'setTime', time );
            return this;
        };

        this.set = function( key, value ) {
            fn( 'set', key, value );
            return this;
        };

        this.bind = function( type, func ) {
            fn( 'bind', type, func );
            return this;
        };

        this.unbind = function( type ) {
            fn( 'unbind', type );
            return this;
        };

        this.bindOnce = function( type, func ) {
            fn( 'bindOnce', type, func );
            return this;
        };

        this.trigger = function( type ) {
            fn( 'trigger', type );
            return this;
        };

        this.fade = function( from, to, duration, callback ) {
            fn( 'fade', from, to, duration, callback );
            return this;
        };

        this.fadeIn = function( duration, callback ) {
            fn( 'fadeIn', duration, callback );
            return this;
        };

        this.fadeOut = function( duration, callback ) {
            fn( 'fadeOut', duration, callback );
            return this;
        };

        // privates
        function fn() {
            var args = argsToArray( null, arguments ),
                func = args.shift();

            for( var i = 0; i < sounds.length; i++ ) {
                sounds[ i ][ func ].apply( sounds[ i ], args );
            }
        }

        function argsToArray( array, args ) {
            return ( array instanceof Array ) ? array : Array.prototype.slice.call( args );
        }
    },

    all: function() {
      return new buzz.group( buzz.sounds );
    },

    isSupported: function() {
        return !!buzz.el.canPlayType;
    },

    isOGGSupported: function() {
        return !!buzz.el.canPlayType && buzz.el.canPlayType( 'audio/ogg; codecs="vorbis"' );
    },

    isWAVSupported: function() {
        return !!buzz.el.canPlayType && buzz.el.canPlayType( 'audio/wav; codecs="1"' );
    },

    isMP3Supported: function() {
        return !!buzz.el.canPlayType && buzz.el.canPlayType( 'audio/mpeg;' );
    },

    isAACSupported: function() {
        return !!buzz.el.canPlayType && ( buzz.el.canPlayType( 'audio/x-m4a;' ) || buzz.el.canPlayType( 'audio/aac;' ) );
    },

    toTimer: function( time, withHours ) {
        var h, m, s;
        h = Math.floor( time / 3600 );
        h = isNaN( h ) ? '--' : ( h >= 10 ) ? h : '0' + h;
        m = withHours ? Math.floor( time / 60 % 60 ) : Math.floor( time / 60 );
        m = isNaN( m ) ? '--' : ( m >= 10 ) ? m : '0' + m;
        s = Math.floor( time % 60 );
        s = isNaN( s ) ? '--' : ( s >= 10 ) ? s : '0' + s;
        return withHours ? h + ':' + m + ':' + s : m + ':' + s;
    },

    fromTimer: function( time ) {
        var splits = time.toString().split( ':' );
        if ( splits && splits.length == 3 ) {
            time = ( parseInt( splits[ 0 ], 10 ) * 3600 ) + ( parseInt(splits[ 1 ], 10 ) * 60 ) + parseInt( splits[ 2 ], 10 );
        }
        if ( splits && splits.length == 2 ) {
            time = ( parseInt( splits[ 0 ], 10 ) * 60 ) + parseInt( splits[ 1 ], 10 );
        }
        return time;
    },

    toPercent: function( value, total, decimal ) {
		var r = Math.pow( 10, decimal || 0 );

		return Math.round( ( ( value * 100 ) / total ) * r ) / r;
    },

    fromPercent: function( percent, total, decimal ) {
		var r = Math.pow( 10, decimal || 0 );

        return  Math.round( ( ( total / 100 ) * percent ) * r ) / r;
    }
};

module.exports = buzz;

},{}],99:[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);
